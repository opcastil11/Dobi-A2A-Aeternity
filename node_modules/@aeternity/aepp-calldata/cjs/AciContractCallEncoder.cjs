"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _ContractByteArrayEncoder = _interopRequireDefault(require("./ContractByteArrayEncoder.cjs"));
var _AciTypeResolver = _interopRequireDefault(require("./AciTypeResolver.cjs"));
var _ApiEncoder = _interopRequireDefault(require("./ApiEncoder.cjs"));
var _EventEncoder = _interopRequireDefault(require("./EventEncoder.cjs"));
var _CanonicalMapper = _interopRequireDefault(require("./Mapper/CanonicalMapper.cjs"));
var _FateTypes = require("./FateTypes.cjs");
var _EncoderError = _interopRequireDefault(require("./Errors/EncoderError.cjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class AciContractCallEncoder {
  /**
   * Creates contract encoder using ACI as type info provider
   *
   * @example
   * const ACI = require('./Test.json')
   * const encoder = new AciContractCallEncoder(ACI)
   *
   * @param {Object} aci - The contract ACI in a canonical (CLI compiler) form as POJO.
  */
  constructor(aci) {
    /** @type {ContractByteArrayEncoder} */
    this._byteArrayEncoder = new _ContractByteArrayEncoder.default();

    /** @type {AciTypeResolver} */
    this._typeResolver = new _AciTypeResolver.default(aci);

    /** @type {ApiEncoder} */
    this._apiEncoder = new _ApiEncoder.default();

    /** @type {EventEncoder} */
    this._eventEncoder = new _EventEncoder.default();

    /** @type {CanonicalMapper} */
    this._canonicalMapper = new _CanonicalMapper.default();
  }

  /**
   * Creates contract call data
   *
   * @example
   * const encoded = encoder.encodeCall('Test', 'test_string', ["whoolymoly"])
   * console.log(`Encoded data: ${encoded}`)
   * // Outputs:
   * // Encoded data: cb_KxHwzCuVGyl3aG9vbHltb2x5zwMSnw==
   *
   * @param {string} contract - The contract name as defined in the ACI.
   * @param {string} funName - The function name as defined in the ACI.
   * @param {Array} args - An array of call arguments as Javascript data structures. See README.md
   * @returns {string} Encoded calldata
  */
  encodeCall(contract, funName, args) {
    const {
      types,
      required
    } = this._typeResolver.getCallTypes(contract, funName);
    if (args.length > types.length || args.length < required) {
      throw new _EncoderError.default('Non matching number of arguments. ' + `${funName} expects between ${required} and ${types.length} number of arguments but got ${args.length}`);
    }

    // fill in the options arguments
    while (args.length < types.length) {
      args.push(undefined);
    }
    return this._byteArrayEncoder.encode((0, _FateTypes.FateTypeCalldata)(funName, types), args);
  }

  /**
   * Decodes contract calldata
   *
   * @example
   * const data = encoder.decodeCall('Test', 'test_string', 'cb_KxHwzCuVGyl3aG9vbHltb2x5zwMSnw==')
   * console.log(`Decoded data: ${data}`)
   * // Outputs:
   * // Decoded data: ["whoolymoly"]
   *
   * @param {string} contract - The contract name as defined in the ACI.
   * @param {string} funName - The function name as defined in the ACI.
   * @param {string} data - Encoded calldata in canonical format.
   * @returns {string} Decoded data
  */
  decodeCall(contract, funName, data) {
    const {
      types,
      _required
    } = this._typeResolver.getCallTypes(contract, funName);
    const calldataType = (0, _FateTypes.FateTypeCalldata)(funName, types);
    return this._byteArrayEncoder.decodeWithType(data, calldataType);
  }

  /**
   * Decodes successful (resultType = ok) contract call return data
   *
   * @example
   * const decoded = encoder.decode('Test', 'test_string', 'cb_KXdob29seW1vbHlGazSE')
   * console.log(`Decoded data: ${decoded}`)
   * // Outputs:
   * // Decoded data: whoolymoly
   *
   * @param {string} contract - The contract name as defined in the ACI.
   * @param {string} funName - The function name as defined in the ACI.
   * @param {string} data - The call return value in a canonical format.
   * @param {'ok'|'revert'|'error'} resultType - The call result type.
   * @returns {boolean|string|BigInt|Array|Map|Object}
   *  Decoded value as Javascript data structures. See README.md
  */
  decodeResult(contract, funName, data, resultType = 'ok') {
    if (resultType === 'ok') {
      const type = this._typeResolver.getReturnType(contract, funName);
      return this._byteArrayEncoder.decodeWithType(data, type);
    }
    if (resultType === 'error') {
      const decoder = new TextDecoder();
      const bytes = this._apiEncoder.decodeWithType(data, 'contract_bytearray');
      return decoder.decode(bytes);
    }
    if (resultType === 'revert') {
      return this._byteArrayEncoder.decodeWithType(data, (0, _FateTypes.FateTypeString)());
    }
    throw new _EncoderError.default(`Unknown call result type: "${resultType}"`);
  }

  /**
   * Decodes contract event
   *
   * @example
   * const data = encoder.decodeEvent('Test', 'cb_dHJpZ2dlcmVk1FYuYA==', [
   *     34853523142692495808479485503424878684430196596020091237715106250497712463899n,
   *     17
   * ])
   * console.log(data)
   * // Outputs:
   * // {EventTwo: [17n, 'triggered']}
   *
   * @param {string} contract - The contract name as defined in the ACI.
   * @param {string} encodedData - Event encoded data
   * @param {BigInt[]} topics - A list of event topics.
   * First element should be the implicit topic that carry the event constructor name.
   */
  decodeEvent(contract, data, topics) {
    const type = this._typeResolver.getEventType(contract, topics);
    return this._eventEncoder.decodeWithType(data, type);
  }
}
var _default = exports.default = AciContractCallEncoder;