"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _FateData = _interopRequireDefault(require("./FateData.cjs"));
var _int2ByteArray = require("../utils/int2ByteArray.cjs");
var _hexStringToByteArray = _interopRequireDefault(require("../utils/hexStringToByteArray.cjs"));
var _FateTypeError = _interopRequireDefault(require("../Errors/FateTypeError.cjs"));
var _FateTypes = require("../FateTypes.cjs");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const toByteArray = (value, size = 0) => {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return new Uint8Array(value);
  }
  if (typeof value === 'string') {
    return (0, _hexStringToByteArray.default)(value);
  }
  if (typeof value !== 'bigint' && !Number.isInteger(value)) {
    throw new _FateTypeError.default('byte_array', `Should be one of: Array, ArrayBuffer, hex string, Number, BigInt; got ${value} instead`);
  }
  const bytes = (0, _int2ByteArray.int2ByteArray)(value);
  if (bytes.length >= size) {
    return bytes;
  }

  // pad the byte array with 0 significant bytes, because int representation lost
  const fixedSize = new Uint8Array(size);
  fixedSize.set(bytes, size - bytes.length);
  return fixedSize;
};
class FateBytes extends _FateData.default {
  constructor(value, size, name = 'bytes') {
    super(name);
    this._value = toByteArray(value, size);
    if (size && this._value.byteLength !== size) {
      throw new _FateTypeError.default(name, `Invalid length: got ${this._value.byteLength} bytes instead of ${size} bytes`);
    }
    this._size = size;
  }
  get value() {
    return this._value;
  }
  get size() {
    return this._size;
  }
  get type() {
    return (0, _FateTypes.FateTypeBytes)(this._size);
  }
  valueOf() {
    return this._value;
  }
}
var _default = exports.default = FateBytes;