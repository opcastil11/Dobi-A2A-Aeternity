"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _ContractByteArrayEncoder = _interopRequireDefault(require("./ContractByteArrayEncoder.cjs"));
var _BytecodeTypeResolver = _interopRequireDefault(require("./BytecodeTypeResolver.cjs"));
var _ApiEncoder = _interopRequireDefault(require("./ApiEncoder.cjs"));
var _EventEncoder = _interopRequireDefault(require("./EventEncoder.cjs"));
var _FateTypes = require("./FateTypes.cjs");
var _EncoderError = _interopRequireDefault(require("./Errors/EncoderError.cjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class BytecodeContractCallEncoder {
  /**
   * Creates contract encoder using bytecode as type info provider
   *
   * @example
   * const bytecode = require('./Test.aeb')
   * const encoder = new BytecodeContractCallEncoder(bytecode)
   *
   * @param {string} bytecode - Contract bytecode using cannonical format.
  */
  constructor(bytecode) {
    /** @type {ContractByteArrayEncoder} */
    this._byteArrayEncoder = new _ContractByteArrayEncoder.default();

    /** @type {BytecodeTypeResolver} */
    this._typeResolver = new _BytecodeTypeResolver.default(bytecode);

    /** @type {ApiEncoder} */
    this._apiEncoder = new _ApiEncoder.default();

    /** @type {EventEncoder} */
    this._eventEncoder = new _EventEncoder.default();
  }

  /**
   * Creates contract call data
   *
   * @example
   * const encoded = encoder.encodeCall('test_string', ["whoolymoly"])
   * console.log(`Encoded data: ${encoded}`)
   * // Outputs:
   * // Encoded data: cb_KxHwzCuVGyl3aG9vbHltb2x5zwMSnw==
   *
   * @param {string} funName - The function name as defined in the bytecode.
   * @param {Array} args - An array of call arguments as Javascript data structures. See README.md
   * @returns {string} Encoded calldata
  */
  encodeCall(funName, args) {
    const {
      types,
      required
    } = this._typeResolver.getCallTypes(funName);
    if (args.length > types.length || args.length < required) {
      throw new _EncoderError.default('Non matching number of arguments. ' + `${funName} expects between ${required} and ${types.length} number of arguments but got ${args.length}`);
    }
    return this._byteArrayEncoder.encode((0, _FateTypes.FateTypeCalldata)(funName, types), args);
  }

  /**
   * Decodes contract calldata
   *
   * @example
   * const data = encoder.decodeCall('cb_KxHwzCuVGyl3aG9vbHltb2x5zwMSnw==')
   * console.log('Decoded data:', data)
   * // Outputs:
   * // Decoded data: {
   * //   functionId: 'aee52c3c',
   * //   functionName: 'test_template_maze',
   * //   args: [ 'whoolymoly' ]
   * // }
   *
   * @param {string} data - Encoded calldata in canonical format.
   * @returns {object} Decoded calldata
  */
  decodeCall(data) {
    const {
      functionId,
      args
    } = this._byteArrayEncoder.decodeWithType(data, (0, _FateTypes.FateTypeCalldata)());
    const functionName = this._typeResolver.getFunctionName(functionId);
    return {
      functionId,
      functionName,
      args
    };
  }

  /**
   * Decodes successful (resultType = ok) contract call return data
   *
   * @example
   * const decoded = encoder.decode('test_string', 'cb_KXdob29seW1vbHlGazSE')
   * console.log(`Decoded data: ${decoded}`)
   * // Outputs:
   * // Decoded data: whoolymoly
   *
   * @param {string} funName - The function name as defined in the bytecode.
   * @param {string} data - The call return value in a canonical format.
   * @param {'ok'|'revert'|'error'} resultType - The call result type.
   * @returns {boolean|string|BigInt|Array|Map|Object}
   *  Decoded value as Javascript data structures. See README.md
  */
  decodeResult(funName, data, resultType = 'ok') {
    if (resultType === 'ok') {
      const type = this._typeResolver.getReturnType(funName);
      return this._byteArrayEncoder.decodeWithType(data, type);
    }
    if (resultType === 'error') {
      const decoder = new TextDecoder();
      const bytes = this._apiEncoder.decodeWithType(data, 'contract_bytearray');
      return decoder.decode(bytes);
    }
    if (resultType === 'revert') {
      return this._byteArrayEncoder.decodeWithType(data, (0, _FateTypes.FateTypeString)());
    }
    throw new _EncoderError.default(`Unknown call resutls type: "${resultType}"`);
  }
}
var _default = exports.default = BytecodeContractCallEncoder;