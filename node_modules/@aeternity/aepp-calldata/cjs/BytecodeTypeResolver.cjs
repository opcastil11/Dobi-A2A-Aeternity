"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _ContractEncoder = _interopRequireDefault(require("./ContractEncoder.cjs"));
var _TypeResolveError = _interopRequireDefault(require("./Errors/TypeResolveError.cjs"));
var _FateTypes = require("./FateTypes.cjs");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class BytecodeTypeResolver {
  constructor(encodedContract) {
    this._contractEncoder = new _ContractEncoder.default();
    this._encodedContract = encodedContract;
    this._contract = null;
  }
  get _bytecode() {
    if (this._contract === null) {
      this._contract = this._contractEncoder.decode(this._encodedContract);
    }
    return this._contract.bytecode;
  }
  getFunctionId(funName) {
    const {
      symbols
    } = this._bytecode;
    return Object.keys(symbols).find(key => symbols[key] === funName);
  }
  getFunction(id) {
    const {
      functions
    } = this._bytecode;
    return functions.find(f => f.id === id);
  }
  getFunctionName(id) {
    const {
      name
    } = this.getFunction(id);
    return name;
  }
  getCallTypes(funName) {
    const fun = this.getFunction(this.getFunctionId(funName));
    if (fun) {
      const types = fun.args.valueTypes.map(t => this.resolveType(t));
      return {
        types,
        required: types.length
      };
    }
    if (funName === 'init') {
      return {
        types: [],
        required: 0
      };
    }
    throw new _TypeResolveError.default(`Unknown function ${funName}`);
  }
  getReturnType(funName) {
    if (funName === 'init') {
      return (0, _FateTypes.FateTypeVoid)();
    }
    const fun = this.getFunction(this.getFunctionId(funName));
    if (fun) {
      return this.resolveType(fun.returnType);
    }
    throw new _TypeResolveError.default(`Unknown function ${funName}`);
  }
  getEventType(topics) {
    const fun = this.getFunction(this.getFunctionId('Chain.event'));
    if (!fun) {
      throw new _TypeResolveError.default('The contract does not have event declaration');
    }
    const variantType = fun.args.valueTypes[0];
    return (0, _FateTypes.FateTypeEvent)(this.resolveType(variantType), topics);
  }
  resolveType(type) {
    if (type.name === 'variant') {
      const variants = type.variants.map((el, idx) => {
        const valueTypes = el.valueTypes.map(v => this.resolveType(v));
        return {
          [idx]: valueTypes
        };
      });
      return (0, _FateTypes.FateTypeVariant)(variants);
    }
    let resolvedTypes = [];
    if (Array.isArray(type.valueTypes)) {
      resolvedTypes = type.valueTypes.map(t => this.resolveType(t));
    }
    if (type.name === 'tuple') {
      return (0, _FateTypes.FateTypeTuple)(resolvedTypes);
    }
    if (type.name === 'list') {
      return (0, _FateTypes.FateTypeList)(...resolvedTypes);
    }
    if (type.name === 'map') {
      return (0, _FateTypes.FateTypeMap)(...resolvedTypes);
    }
    if (type.name === 'oracle') {
      return (0, _FateTypes.FateTypeOracleAddress)(...resolvedTypes);
    }
    if (type.name === 'oracle_query') {
      return (0, _FateTypes.FateTypeOracleQueryAddress)(...resolvedTypes);
    }
    return type;
  }
}
var _default = exports.default = BytecodeTypeResolver;