"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _TypeResolveError = _interopRequireDefault(require("./Errors/TypeResolveError.cjs"));
var _FateTypes = require("./FateTypes.cjs");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const isObject = value => {
  return value && typeof value === 'object' && value.constructor === Object;
};
class TypeResolver {
  isCustomType() {
    return false;
  }
  resolveTypeDef(type, valueTypes) {
    return [type, valueTypes];
  }
  resolveValueTypes(valueTypes, vars) {
    if (!Array.isArray(valueTypes)) {
      return [];
    }
    return valueTypes.map(v => {
      const tpl = v.hasOwnProperty('type') ? v.type : v;
      const t = vars.hasOwnProperty(tpl) ? vars[tpl] : tpl;
      return this.resolveType(t, vars);
    });
  }
  resolveType(type, vars = {}) {
    let key = type;
    let valueTypes = [];
    let resolvedTypes = [];
    if (isObject(type)) {
      [[key, valueTypes]] = Object.entries(type);
    }
    if (this.isCustomType(key)) {
      const [typeDef, typeVars] = this.resolveTypeDef(key, valueTypes);
      return this.resolveType(typeDef, typeVars);
    }

    // variant value types are resolved in its own method
    if (key !== 'variant') {
      resolvedTypes = this.resolveValueTypes(valueTypes, vars);
    }
    if (key === 'void') {
      return (0, _FateTypes.FateTypeVoid)();
    }
    if (key === 'unit') {
      return (0, _FateTypes.FateTypeTuple)([]);
    }
    if (key === 'int') {
      return (0, _FateTypes.FateTypeInt)();
    }
    if (key === 'bool') {
      return (0, _FateTypes.FateTypeBool)();
    }
    if (key === 'string') {
      return (0, _FateTypes.FateTypeString)();
    }
    if (key === 'bits') {
      return (0, _FateTypes.FateTypeBits)();
    }
    if (key === 'hash') {
      return (0, _FateTypes.FateTypeHash)();
    }
    if (key === 'signature') {
      return (0, _FateTypes.FateTypeSignature)();
    }
    if (key === 'address') {
      return (0, _FateTypes.FateTypeAccountAddress)();
    }
    if (key === 'contract_pubkey') {
      return (0, _FateTypes.FateTypeContractAddress)();
    }
    if (key === 'Chain.ttl') {
      return (0, _FateTypes.FateTypeChainTTL)();
    }
    if (key === 'Chain.ga_meta_tx') {
      return (0, _FateTypes.FateTypeChainGAMetaTx)();
    }
    if (key === 'Chain.paying_for_tx') {
      return (0, _FateTypes.FateTypeChainPayingForTx)();
    }
    if (key === 'Chain.base_tx') {
      return (0, _FateTypes.FateTypeChainBaseTx)();
    }
    if (key === 'AENS.pointee') {
      return (0, _FateTypes.FateTypeAENSPointee)();
    }
    if (key === 'AENSv2.pointee') {
      return (0, _FateTypes.FateTypeAENSv2Pointee)();
    }
    if (key === 'AENS.name') {
      return (0, _FateTypes.FateTypeAENSName)();
    }
    if (key === 'AENSv2.name') {
      return (0, _FateTypes.FateTypeAENSv2Name)();
    }
    if (key === 'Set.set') {
      return (0, _FateTypes.FateTypeSet)(...resolvedTypes);
    }
    if (key === 'MCL_BLS12_381.fr') {
      return (0, _FateTypes.FateTypeBls12381Fr)();
    }
    if (key === 'MCL_BLS12_381.fp') {
      return (0, _FateTypes.FateTypeBls12381Fp)();
    }
    if (key === 'bytes') {
      return (0, _FateTypes.FateTypeBytes)(valueTypes === 'any' ? undefined : valueTypes);
    }
    if (key === 'list') {
      return (0, _FateTypes.FateTypeList)(...resolvedTypes);
    }
    if (key === 'map') {
      return (0, _FateTypes.FateTypeMap)(...resolvedTypes);
    }

    // Unbox singleton tuples and records
    // https://github.com/aeternity/aesophia/pull/205
    // https://github.com/aeternity/aesophia/commit/a403a9d227ac56266cf5bb8fbc916f17e6141d15
    if ((key === 'tuple' || key === 'record') && resolvedTypes.length === 1) {
      return resolvedTypes[0];
    }
    if (key === 'tuple') {
      return (0, _FateTypes.FateTypeTuple)(resolvedTypes);
    }
    if (key === 'record') {
      const keys = valueTypes.map(e => e.name);
      return (0, _FateTypes.FateTypeRecord)(keys, resolvedTypes);
    }
    if (key === 'variant') {
      return this.resolveVariant(valueTypes, vars);
    }
    if (key === 'option') {
      return (0, _FateTypes.FateTypeOption)(resolvedTypes);
    }
    if (key === 'oracle') {
      return (0, _FateTypes.FateTypeOracleAddress)(...resolvedTypes);
    }
    if (key === 'oracle_query') {
      return (0, _FateTypes.FateTypeOracleQueryAddress)(...resolvedTypes);
    }
    throw new _TypeResolveError.default('Cannot resolve type: ' + JSON.stringify(type));
  }
  resolveVariant(valueTypes, vars) {
    const variants = valueTypes.map(e => {
      const [[variant, args]] = Object.entries(e);
      const resolvedArgs = args.map(v => {
        const t = vars.hasOwnProperty(v) ? vars[v] : v;
        return this.resolveType(t, vars);
      });
      return {
        [variant]: resolvedArgs
      };
    });
    return (0, _FateTypes.FateTypeVariant)(variants);
  }
}
var _default = exports.default = TypeResolver;