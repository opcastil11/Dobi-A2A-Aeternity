"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _BaseSerializer = _interopRequireDefault(require("./BaseSerializer.cjs"));
var _FateTypes = require("../FateTypes.cjs");
var _FateMap = _interopRequireDefault(require("../types/FateMap.cjs"));
var _FateTuple = _interopRequireDefault(require("../types/FateTuple.cjs"));
var _FateSet = _interopRequireDefault(require("../types/FateSet.cjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
// This serializer takes advantages of the singular tuple optimization directly
// An alternative implementation would be building the full structure
// and pass it upstream for optimization.
// Unbox singleton tuples and records
// https://github.com/aeternity/aesophia/pull/205
// https://github.com/aeternity/aesophia/commit/a403a9d227ac56266cf5bb8fbc916f17e6141d15

class SetSerializer extends _BaseSerializer.default {
  serialize(set) {
    return this.globalSerializer.serialize(new _FateMap.default(set.itemsType, (0, _FateTypes.FateTypeTuple)(), set.items.map(i => [i, new _FateTuple.default()])));
  }
  deserializeStream(data, typeInfo) {
    const mapType = (0, _FateTypes.FateTypeMap)(typeInfo.valuesType, (0, _FateTypes.FateTypeTuple)());
    const [map, rest] = this.globalSerializer.deserializeStream(data, mapType);
    return [new _FateSet.default(typeInfo.valuesType, map.keys), rest];
  }
}
var _default = exports.default = SetSerializer;