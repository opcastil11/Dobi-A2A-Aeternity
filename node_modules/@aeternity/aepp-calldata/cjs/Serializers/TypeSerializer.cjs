"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _FateTag = _interopRequireDefault(require("../FateTag.cjs"));
var _BaseSerializer = _interopRequireDefault(require("./BaseSerializer.cjs"));
var _IntSerializer = _interopRequireDefault(require("./IntSerializer.cjs"));
var _FatePrefixError = _interopRequireDefault(require("../Errors/FatePrefixError.cjs"));
var _FateTypeError = _interopRequireDefault(require("../Errors/FateTypeError.cjs"));
var _FateTypes = require("../FateTypes.cjs");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const BASIC_TYPES = {
  [_FateTag.default.TYPE_INTEGER]: (0, _FateTypes.FateTypeInt)(),
  [_FateTag.default.TYPE_BOOLEAN]: (0, _FateTypes.FateTypeBool)(),
  [_FateTag.default.TYPE_BITS]: (0, _FateTypes.FateTypeBits)(),
  [_FateTag.default.TYPE_STRING]: (0, _FateTypes.FateTypeString)(),
  [_FateTag.default.TYPE_ANY]: (0, _FateTypes.FateTypeAny)()
};
const OBJECT_TYPES = {
  [_FateTag.default.OTYPE_ADDRESS]: (0, _FateTypes.FateTypeAccountAddress)(),
  [_FateTag.default.OTYPE_CONTRACT]: (0, _FateTypes.FateTypeContractAddress)(),
  [_FateTag.default.OTYPE_ORACLE]: (0, _FateTypes.FateTypeOracleAddress)(),
  [_FateTag.default.OTYPE_ORACLE_QUERY]: (0, _FateTypes.FateTypeOracleQueryAddress)(),
  [_FateTag.default.OTYPE_CHANNEL]: (0, _FateTypes.FateTypeChannelAddress)()
};
class TypeSerializer extends _BaseSerializer.default {
  constructor(globalSerializer) {
    super(globalSerializer);
    this._intSerializer = new _IntSerializer.default();
  }
  serialize(type) {
    const basicTypeTag = Object.entries(BASIC_TYPES).find(([_key, {
      name
    }]) => name === type.name)?.[0];
    if (basicTypeTag != null) {
      return new Uint8Array([basicTypeTag]);
    }
    const objectTypeTag = Object.entries(OBJECT_TYPES).find(([_key, {
      name
    }]) => name === type.name)?.[0];
    if (objectTypeTag != null) {
      return new Uint8Array([_FateTag.default.TYPE_OBJECT, objectTypeTag]);
    }
    if (type.name === 'tvar') {
      return new Uint8Array([_FateTag.default.TYPE_VAR, type.id]);
    }
    if (type.name === 'bytes') {
      return new Uint8Array([_FateTag.default.TYPE_BYTES, ...this._intSerializer.serialize(type.size)]);
    }
    if (type.name === 'list') {
      return new Uint8Array([_FateTag.default.TYPE_LIST, ...this.serialize(type.valuesType)]);
    }
    if (type.name === 'map') {
      return new Uint8Array([_FateTag.default.TYPE_MAP, ...this.serialize(type.keyType), ...this.serialize(type.valueType)]);
    }
    if (type.name === 'tuple') {
      return new Uint8Array([_FateTag.default.TYPE_TUPLE, type.valueTypes.length, ...type.valueTypes.map(t => [...this.serialize(t)]).flat()]);
    }
    if (type.name === 'variant') {
      return new Uint8Array([_FateTag.default.TYPE_VARIANT, type.variants.length, ...type.variants.map(t => [...this.serialize(t)]).flat()]);
    }
    throw new _FateTypeError.default(type.name, `Unsupported type: ${type.name}`);
  }
  deserializeStream(data) {
    const buffer = new Uint8Array(data);
    const prefix = buffer[0];
    if (BASIC_TYPES.hasOwnProperty(prefix)) {
      return [BASIC_TYPES[prefix], buffer.slice(1)];
    }
    if (prefix === _FateTag.default.TYPE_OBJECT) {
      const obj = buffer[1];
      if (!OBJECT_TYPES.hasOwnProperty(obj)) {
        throw new _FatePrefixError.default(obj, 'Unsupported object type');
      }
      return [OBJECT_TYPES[obj], buffer.slice(2)];
    }
    if (prefix === _FateTag.default.TYPE_VAR) {
      return [(0, _FateTypes.FateTypeVar)(buffer[1]), buffer.slice(2)];
    }
    if (prefix === _FateTag.default.TYPE_BYTES) {
      const [size, rest] = this._intSerializer.deserializeStream(buffer.slice(1));
      return [(0, _FateTypes.FateTypeBytes)(size.valueOf()), rest];
    }
    if (prefix === _FateTag.default.TYPE_LIST) {
      const [elementsType, rest] = this.deserializeStream(buffer.slice(1));
      return [(0, _FateTypes.FateTypeList)(elementsType), rest];
    }
    if (prefix === _FateTag.default.TYPE_MAP) {
      const [keyType, rest] = this.deserializeStream(buffer.slice(1));
      const [valueType, rest2] = this.deserializeStream(rest);
      return [(0, _FateTypes.FateTypeMap)(keyType, valueType), rest2];
    }
    if (prefix === _FateTag.default.TYPE_TUPLE) {
      const size = buffer[1];
      const elementTypes = [];
      let rest = buffer.slice(2);
      let el;
      for (let i = 0; i < size; i++) {
        [el, rest] = this.deserializeStream(rest);
        elementTypes.push(el);
      }
      return [(0, _FateTypes.FateTypeTuple)(elementTypes), rest];
    }
    if (prefix === _FateTag.default.TYPE_VARIANT) {
      const size = buffer[1];
      const variants = [];
      let rest = buffer.slice(2);
      let el;
      for (let i = 0; i < size; i++) {
        [el, rest] = this.deserializeStream(rest);
        variants.push(el);
      }
      return [(0, _FateTypes.FateTypeVariant)(variants), rest];
    }
    throw new _FatePrefixError.default(prefix);
  }
}
var _default = exports.default = TypeSerializer;