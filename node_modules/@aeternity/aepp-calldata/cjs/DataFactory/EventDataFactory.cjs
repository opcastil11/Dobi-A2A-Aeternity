"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _hash = require("../utils/hash.cjs");
var _int2ByteArray = require("../utils/int2ByteArray.cjs");
var _TypeResolveError = _interopRequireDefault(require("../Errors/TypeResolveError.cjs"));
var _BaseDataFactory = _interopRequireDefault(require("./BaseDataFactory.cjs"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const DATA_TYPES = ['string', 'signature', 'bytes'];
class EventDataFactory extends _BaseDataFactory.default {
  supports({
    name,
    _valueTypes
  }) {
    return 'event' === name;
  }
  create({
    variantType,
    topics
  }, data) {
    const [nameHash, ...args] = topics;
    if (typeof nameHash !== 'bigint') {
      throw new _TypeResolveError.default(`Event name hash (first topic) should be of type "BigInt", got "${typeof nameHash}" instead.`);
    }
    const idx = variantType.variants.map(v => (0, _int2ByteArray.byteArray2Int)((0, _hash.hash)(Object.keys(v)[0]))).findIndex(v => v === nameHash);
    if (idx === -1) {
      throw new _TypeResolveError.default('Event name hash does not match any event variant constructor');
    }
    const variant = variantType.variants[idx];
    const variantName = Object.keys(variant)[0];
    const [argTypes] = Object.values(variant);
    const resolvedArgs = argTypes.map(t => {
      if (this._isData(t)) {
        return data;
      }
      return args.shift();
    });
    return this.valueFactory.create(variantType, {
      [variantName]: resolvedArgs
    });
  }
  _isData(type) {
    if (!DATA_TYPES.includes(type.name)) {
      return false;
    }
    if (type.name === 'bytes' && type.size <= 32) {
      return false;
    }
    return true;
  }
}
var _default = exports.default = EventDataFactory;