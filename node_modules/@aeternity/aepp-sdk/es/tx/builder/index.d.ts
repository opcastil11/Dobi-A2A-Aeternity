import { Encoded, Encoding } from '../../utils/encoder.js';
import { Field } from './field-types/interface.js';
import { TxUnpacked, TxParams, TxParamsAsync } from './schema.generated.js';
import { Tag } from './constants.js';
/**
 * JavaScript-based Transaction builder
 */
export declare function getSchema(tag: Tag, version?: number): Array<[string, Field]>;
type TxEncoding = Encoding.Transaction | Encoding.Poi | Encoding.StateTrees | Encoding.CallStateTree;
/**
 * Build transaction
 * @category transaction builder
 * @param params - Transaction params
 */
export declare function buildTx(params: TxParams): Encoded.Transaction;
export type BuildTxOptions<TxType extends Tag, OmitFields extends string> = Omit<TxParamsAsync & {
    tag: TxType;
}, 'tag' | OmitFields>;
/**
 * Build transaction async (may request node for additional data)
 * @category transaction builder
 * @param params - Transaction params
 * @returns tx_-encoded transaction
 */
export declare function buildTxAsync(params: TxParamsAsync): Promise<Encoded.Transaction>;
/**
 * Unpack transaction encoded as string
 * @category transaction builder
 * @param encodedTx - Encoded transaction
 * @param txType - Expected transaction type
 * @returns Transaction params
 */
export declare function unpackTx<TxType extends Tag>(encodedTx: Encoded.Generic<TxEncoding>, txType?: TxType): TxUnpacked & {
    tag: TxType;
};
/**
 * Build a transaction hash
 * @category transaction builder
 * @param rawTx - base64 or rlp encoded transaction
 * @returns Transaction hash
 */
export declare function buildTxHash(rawTx: Encoded.Transaction | Uint8Array): Encoded.TxHash;
/**
 * Build a contract public key by contractCreateTx, gaAttach or signedTx
 * @category contract
 * @param contractTx - Transaction
 * @returns Contract public key
 */
export declare function buildContractIdByContractTx(contractTx: Encoded.Transaction): Encoded.ContractAddress;
export {};
