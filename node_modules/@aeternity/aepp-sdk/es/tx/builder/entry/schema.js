import abiVersion from '../field-types/abi-version.js';
import address, { idTagToEncoding } from '../field-types/address.js';
import array from '../field-types/array.js';
import boolean from '../field-types/boolean.js';
import coinAmount from '../field-types/coin-amount.js';
import ctVersion from '../field-types/ct-version.js';
import encoded from '../field-types/encoded.js';
import entry from '../field-types/entry.js';
import enumeration from '../field-types/enumeration.js';
import gasLimit from '../field-types/gas-limit.js';
import gasPrice from '../field-types/gas-price.js';
import map from '../field-types/map.js';
import mptree from '../field-types/mptree.js';
import pointers from '../field-types/pointers.js';
import raw from '../field-types/raw.js';
import shortUInt from '../field-types/short-u-int.js';
import shortUIntConst from '../field-types/short-u-int-const.js';
import string from '../field-types/string.js';
import uInt from '../field-types/u-int.js';
import wrapped from '../field-types/wrapped.js';
import { Encoding } from '../../../utils/encoder.js';
import { EntryTag, CallReturnType } from './constants.js';
const entryMtreeValueArray = array(entry(EntryTag.MtreeValue));
const mapContracts = map(Encoding.ContractAddress, EntryTag.Contract);
const mapAccounts = map(Encoding.AccountAddress, EntryTag.Account);
const mapCalls = map(Encoding.Bytearray, EntryTag.ContractCall);
const mapChannels = map(Encoding.Channel, EntryTag.Channel);
const mapNames = map(Encoding.Name, EntryTag.Name);
const mapOracles = map(Encoding.OracleAddress, EntryTag.Oracle);

/**
 * @see {@link https://github.com/aeternity/protocol/blob/8a9d1d1206174627f6aaef86159dc9c643080653/contracts/fate.md#from-ceres-serialized-signature-data}
 */
export const schemas = [{
  tag: shortUIntConst(EntryTag.Account),
  version: shortUIntConst(1),
  nonce: shortUInt,
  balance: uInt
}, {
  tag: shortUIntConst(EntryTag.Account),
  version: shortUIntConst(2, true),
  flags: uInt,
  nonce: shortUInt,
  balance: uInt,
  gaContract: address(Encoding.ContractAddress, Encoding.Name),
  gaAuthFun: encoded(Encoding.ContractBytearray)
}, {
  tag: shortUIntConst(EntryTag.Name),
  version: shortUIntConst(1, true),
  accountId: address(Encoding.AccountAddress),
  nameTtl: shortUInt,
  status: raw,
  /**
   * a suggestion as to how long any clients should cache this information
   */
  clientTtl: shortUInt,
  pointers
}, {
  tag: shortUIntConst(EntryTag.Contract),
  version: shortUIntConst(1, true),
  owner: address(Encoding.AccountAddress),
  ctVersion,
  code: encoded(Encoding.ContractBytearray),
  log: encoded(Encoding.ContractBytearray),
  active: boolean,
  referers: array(address(Encoding.AccountAddress)),
  deposit: coinAmount
}, {
  tag: shortUIntConst(EntryTag.ContractCall),
  version: shortUIntConst(2, true),
  callerId: address(Encoding.AccountAddress),
  callerNonce: shortUInt,
  height: shortUInt,
  contractId: address(Encoding.ContractAddress),
  // TODO: rename after resolving https://github.com/aeternity/protocol/issues/506
  gasPrice: uInt,
  gasUsed: shortUInt,
  returnValue: encoded(Encoding.ContractBytearray),
  returnType: enumeration(CallReturnType),
  // TODO: add serialization for
  //  <log> :: [ { <address> :: id, [ <topics> :: binary() }, <data> :: binary() } ]
  log: array(raw)
}, {
  tag: shortUIntConst(EntryTag.Oracle),
  version: shortUIntConst(1, true),
  accountId: address(Encoding.AccountAddress),
  queryFormat: string,
  responseFormat: string,
  queryFee: coinAmount,
  oracleTtlValue: shortUInt,
  abiVersion
}, {
  tag: shortUIntConst(EntryTag.Channel),
  version: shortUIntConst(3, true),
  initiator: address(Encoding.AccountAddress),
  responder: address(Encoding.AccountAddress),
  channelAmount: uInt,
  initiatorAmount: uInt,
  responderAmount: uInt,
  channelReserve: uInt,
  initiatorDelegateIds: array(address(...idTagToEncoding)),
  responderDelegateIds: array(address(...idTagToEncoding)),
  stateHash: encoded(Encoding.State),
  round: shortUInt,
  soloRound: uInt,
  lockPeriod: uInt,
  lockedUntil: uInt,
  initiatorAuth: encoded(Encoding.ContractBytearray),
  responderAuth: encoded(Encoding.ContractBytearray)
}, {
  tag: shortUIntConst(EntryTag.ChannelOffChainUpdateTransfer),
  version: shortUIntConst(1, true),
  from: address(Encoding.AccountAddress),
  to: address(Encoding.AccountAddress),
  amount: uInt
}, {
  tag: shortUIntConst(EntryTag.ChannelOffChainUpdateDeposit),
  version: shortUIntConst(1, true),
  from: address(Encoding.AccountAddress),
  amount: uInt
}, {
  tag: shortUIntConst(EntryTag.ChannelOffChainUpdateWithdraw),
  version: shortUIntConst(1, true),
  from: address(Encoding.AccountAddress),
  amount: uInt
}, {
  tag: shortUIntConst(EntryTag.ChannelOffChainUpdateCreateContract),
  version: shortUIntConst(1, true),
  owner: address(Encoding.AccountAddress),
  ctVersion,
  code: encoded(Encoding.ContractBytearray),
  deposit: uInt,
  callData: encoded(Encoding.ContractBytearray)
}, {
  tag: shortUIntConst(EntryTag.ChannelOffChainUpdateCallContract),
  version: shortUIntConst(1, true),
  caller: address(Encoding.AccountAddress),
  contract: address(Encoding.ContractAddress),
  abiVersion,
  amount: uInt,
  callData: encoded(Encoding.ContractBytearray),
  callStack: raw,
  gasPrice,
  gasLimit
}, {
  tag: shortUIntConst(EntryTag.TreesPoi),
  version: shortUIntConst(1, true),
  // TODO: inline an extra wrapping array after resolving https://github.com/aeternity/protocol/issues/505
  accounts: array(mptree(Encoding.AccountAddress, EntryTag.Account)),
  calls: array(mptree(Encoding.Bytearray, EntryTag.ContractCall)),
  channels: array(mptree(Encoding.Channel, EntryTag.Channel)),
  contracts: array(mptree(Encoding.ContractAddress, EntryTag.Contract)),
  ns: array(mptree(Encoding.Name, EntryTag.Name)),
  oracles: array(mptree(Encoding.OracleAddress, EntryTag.Oracle))
}, {
  tag: shortUIntConst(EntryTag.StateTrees),
  version: shortUIntConst(0, true),
  contracts: wrapped(EntryTag.ContractsMtree),
  calls: wrapped(EntryTag.CallsMtree),
  channels: wrapped(EntryTag.ChannelsMtree),
  ns: wrapped(EntryTag.NameserviceMtree),
  oracles: wrapped(EntryTag.OraclesMtree),
  accounts: wrapped(EntryTag.AccountsMtree)
}, {
  tag: shortUIntConst(EntryTag.Mtree),
  version: shortUIntConst(1, true),
  values: entryMtreeValueArray
}, {
  tag: shortUIntConst(EntryTag.MtreeValue),
  version: shortUIntConst(1, true),
  key: raw,
  value: raw
}, {
  tag: shortUIntConst(EntryTag.ContractsMtree),
  version: shortUIntConst(1, true),
  payload: mapContracts
}, {
  tag: shortUIntConst(EntryTag.CallsMtree),
  version: shortUIntConst(1, true),
  payload: mapCalls
}, {
  tag: shortUIntConst(EntryTag.ChannelsMtree),
  version: shortUIntConst(1, true),
  payload: mapChannels
}, {
  tag: shortUIntConst(EntryTag.NameserviceMtree),
  version: shortUIntConst(1, true),
  payload: mapNames
}, {
  tag: shortUIntConst(EntryTag.OraclesMtree),
  version: shortUIntConst(1, true),
  payload: mapOracles
}, {
  tag: shortUIntConst(EntryTag.AccountsMtree),
  version: shortUIntConst(1, true),
  payload: mapAccounts
}, {
  tag: shortUIntConst(EntryTag.GaMetaTxAuthData),
  version: shortUIntConst(1, true),
  fee: coinAmount,
  gasPrice,
  txHash: encoded(Encoding.TxHash)
}];
//# sourceMappingURL=schema.js.map