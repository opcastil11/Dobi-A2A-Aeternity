import SchemaTypes from '../SchemaTypes.js';
import { Encoded, Encoding } from '../../../utils/encoder.js';
import { EntryTag, CallReturnType } from './constants.js';
interface EntryMtreeValueArray {
    serialize: (value: Array<(EntParams & {
        tag: EntryTag.MtreeValue;
    }) | Uint8Array | Encoded.Transaction>) => Buffer[];
    deserialize: (value: Buffer[]) => Array<EntUnpacked & {
        tag: EntryTag.MtreeValue;
    }>;
    recursiveType: true;
}
interface MapContracts {
    serialize: (value: Record<Encoded.ContractAddress, EntParams & {
        tag: EntryTag.Contract;
    }>) => Buffer;
    deserialize: (value: Buffer) => Record<Encoded.ContractAddress, EntUnpacked & {
        tag: EntryTag.Contract;
    }>;
    recursiveType: true;
}
interface MapAccounts {
    serialize: (value: Record<Encoded.AccountAddress, EntParams & {
        tag: EntryTag.Account;
    }>) => Buffer;
    deserialize: (value: Buffer) => Record<Encoded.AccountAddress, EntUnpacked & {
        tag: EntryTag.Account;
    }>;
    recursiveType: true;
}
interface MapCalls {
    serialize: (value: Record<Encoded.Bytearray, EntParams & {
        tag: EntryTag.ContractCall;
    }>) => Buffer;
    deserialize: (value: Buffer) => Record<Encoded.Bytearray, EntUnpacked & {
        tag: EntryTag.ContractCall;
    }>;
    recursiveType: true;
}
interface MapChannels {
    serialize: (value: Record<Encoded.Channel, EntParams & {
        tag: EntryTag.Channel;
    }>) => Buffer;
    deserialize: (value: Buffer) => Record<Encoded.Channel, EntUnpacked & {
        tag: EntryTag.Channel;
    }>;
    recursiveType: true;
}
interface MapNames {
    serialize: (value: Record<Encoded.Name, EntParams & {
        tag: EntryTag.Name;
    }>) => Buffer;
    deserialize: (value: Buffer) => Record<Encoded.Name, EntUnpacked & {
        tag: EntryTag.Name;
    }>;
    recursiveType: true;
}
interface MapOracles {
    serialize: (value: Record<Encoded.OracleAddress, EntParams & {
        tag: EntryTag.Oracle;
    }>) => Buffer;
    deserialize: (value: Buffer) => Record<Encoded.OracleAddress, EntUnpacked & {
        tag: EntryTag.Oracle;
    }>;
    recursiveType: true;
}
/**
 * @see {@link https://github.com/aeternity/protocol/blob/8a9d1d1206174627f6aaef86159dc9c643080653/contracts/fate.md#from-ceres-serialized-signature-data}
 */
export declare const schemas: readonly [{
    readonly tag: {
        serialize: (value: EntryTag.Account) => Buffer;
        deserialize: (value: Buffer) => EntryTag.Account;
        constValue: EntryTag.Account;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value: 1) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly nonce: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly balance: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.Account) => Buffer;
        deserialize: (value: Buffer) => EntryTag.Account;
        constValue: EntryTag.Account;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 2 | undefined) => Buffer;
        deserialize: (value: Buffer) => 2;
        constValue: 2;
        constValueOptional: boolean;
    };
    readonly flags: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly balance: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gaContract: {
        serialize: (value: `ct_${string}` | `nm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ct_${string}` | `nm_${string}`;
    };
    readonly gaAuthFun: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.Name) => Buffer;
        deserialize: (value: Buffer) => EntryTag.Name;
        constValue: EntryTag.Name;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nameTtl: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly status: {
        serialize(buffer: Uint8Array): Buffer;
        deserialize(buffer: Buffer): Buffer;
    };
    /**
     * a suggestion as to how long any clients should cache this information
     */
    readonly clientTtl: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly pointers: <AllowRaw extends boolean>(allowRaw: AllowRaw) => {
        serialize: (pointers: Array<AllowRaw extends true ? import("../../../apis/node/index.js").NamePointer & {
            id: Encoded.Generic<import("../field-types/address.js").AddressEncodings | Encoding.Bytearray>;
        } : import("../../../apis/node/index.js").NamePointer & {
            id: Encoded.Generic<import("../field-types/address.js").AddressEncodings>;
        }>) => Buffer[][];
        deserialize: (pointers: Array<[key: Buffer, id: Buffer]>) => Array<AllowRaw extends true ? import("../../../apis/node/index.js").NamePointer & {
            id: Encoded.Generic<import("../field-types/address.js").AddressEncodings | Encoding.Bytearray>;
        } : import("../../../apis/node/index.js").NamePointer & {
            id: Encoded.Generic<import("../field-types/address.js").AddressEncodings>;
        }>;
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.Contract) => Buffer;
        deserialize: (value: Buffer) => EntryTag.Contract;
        constValue: EntryTag.Contract;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly owner: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly ctVersion: {
        serialize(value: import("../field-types/ct-version.js").CtVersion | undefined, params: {}, { consensusProtocolVersion, }: {
            consensusProtocolVersion?: import("../constants.js").ConsensusProtocolVersion;
        }): Buffer;
        prepare(value: import("../field-types/ct-version.js").CtVersion | undefined, params: {}, options: {
            consensusProtocolVersion?: import("../constants.js").ConsensusProtocolVersion;
            onNode?: import("../../../Node.js").default;
        }): Promise<import("../field-types/ct-version.js").CtVersion | undefined>;
        deserialize(buffer: Buffer): import("../field-types/ct-version.js").CtVersion;
    };
    readonly code: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly log: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly active: {
        serialize(value: boolean): Buffer;
        deserialize(buffer: Buffer): boolean;
    };
    readonly referers: {
        serialize: (value: readonly `ak_${string}`[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => `ak_${string}`[];
    };
    readonly deposit: {
        serializeAettos(value: string | undefined, params: {}, options: {}): string;
        serialize(value: import("../constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.ContractCall) => Buffer;
        deserialize: (value: Buffer) => EntryTag.ContractCall;
        constValue: EntryTag.ContractCall;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 2 | undefined) => Buffer;
        deserialize: (value: Buffer) => 2;
        constValue: 2;
        constValueOptional: boolean;
    };
    readonly callerId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly callerNonce: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly height: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly contractId: {
        serialize: (value: `ct_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ct_${string}`;
    };
    readonly gasPrice: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gasUsed: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly returnValue: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly returnType: {
        serialize: (value: CallReturnType) => Buffer;
        deserialize: (value: Buffer) => CallReturnType;
    };
    readonly log: {
        serialize: (value: readonly Uint8Array[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => Buffer[];
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.Oracle) => Buffer;
        deserialize: (value: Buffer) => EntryTag.Oracle;
        constValue: EntryTag.Oracle;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly queryFormat: {
        serialize(string: string): Buffer;
        deserialize(buffer: Buffer): string;
    };
    readonly responseFormat: {
        serialize(string: string): Buffer;
        deserialize(buffer: Buffer): string;
    };
    readonly queryFee: {
        serializeAettos(value: string | undefined, params: {}, options: {}): string;
        serialize(value: import("../constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly oracleTtlValue: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly abiVersion: {
        _getProtocolDetails(c: import("../constants.js").ConsensusProtocolVersion, tag: import("../constants.js").Tag): import("../constants.js").AbiVersion;
        serialize(value: import("../constants.js").AbiVersion | undefined, { tag }: {
            tag: import("../constants.js").Tag;
        }, { consensusProtocolVersion, }: {
            consensusProtocolVersion?: import("../constants.js").ConsensusProtocolVersion;
        }): Buffer;
        prepare(value: import("../constants.js").AbiVersion | undefined, { tag }: {
            tag: import("../constants.js").Tag;
        }, options: {
            consensusProtocolVersion?: import("../constants.js").ConsensusProtocolVersion;
            onNode?: import("../../../Node.js").default;
        }): Promise<import("../constants.js").AbiVersion | undefined>;
        deserialize(buffer: Buffer): import("../constants.js").AbiVersion;
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.Channel) => Buffer;
        deserialize: (value: Buffer) => EntryTag.Channel;
        constValue: EntryTag.Channel;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 3 | undefined) => Buffer;
        deserialize: (value: Buffer) => 3;
        constValue: 3;
        constValueOptional: boolean;
    };
    readonly initiator: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly responder: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly channelAmount: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly initiatorAmount: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly responderAmount: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly channelReserve: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly initiatorDelegateIds: {
        serialize: (value: readonly (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[];
    };
    readonly responderDelegateIds: {
        serialize: (value: readonly (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[];
    };
    readonly stateHash: {
        serialize: (value: `st_${string}`) => Buffer;
        deserialize: (value: Buffer) => `st_${string}`;
    };
    readonly round: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly soloRound: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly lockPeriod: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly lockedUntil: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly initiatorAuth: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly responderAuth: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.ChannelOffChainUpdateTransfer) => Buffer;
        deserialize: (value: Buffer) => EntryTag.ChannelOffChainUpdateTransfer;
        constValue: EntryTag.ChannelOffChainUpdateTransfer;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly from: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly to: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly amount: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.ChannelOffChainUpdateDeposit) => Buffer;
        deserialize: (value: Buffer) => EntryTag.ChannelOffChainUpdateDeposit;
        constValue: EntryTag.ChannelOffChainUpdateDeposit;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly from: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly amount: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.ChannelOffChainUpdateWithdraw) => Buffer;
        deserialize: (value: Buffer) => EntryTag.ChannelOffChainUpdateWithdraw;
        constValue: EntryTag.ChannelOffChainUpdateWithdraw;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly from: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly amount: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.ChannelOffChainUpdateCreateContract) => Buffer;
        deserialize: (value: Buffer) => EntryTag.ChannelOffChainUpdateCreateContract;
        constValue: EntryTag.ChannelOffChainUpdateCreateContract;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly owner: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly ctVersion: {
        serialize(value: import("../field-types/ct-version.js").CtVersion | undefined, params: {}, { consensusProtocolVersion, }: {
            consensusProtocolVersion?: import("../constants.js").ConsensusProtocolVersion;
        }): Buffer;
        prepare(value: import("../field-types/ct-version.js").CtVersion | undefined, params: {}, options: {
            consensusProtocolVersion?: import("../constants.js").ConsensusProtocolVersion;
            onNode?: import("../../../Node.js").default;
        }): Promise<import("../field-types/ct-version.js").CtVersion | undefined>;
        deserialize(buffer: Buffer): import("../field-types/ct-version.js").CtVersion;
    };
    readonly code: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly deposit: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly callData: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.ChannelOffChainUpdateCallContract) => Buffer;
        deserialize: (value: Buffer) => EntryTag.ChannelOffChainUpdateCallContract;
        constValue: EntryTag.ChannelOffChainUpdateCallContract;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly caller: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly contract: {
        serialize: (value: `ct_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ct_${string}`;
    };
    readonly abiVersion: {
        _getProtocolDetails(c: import("../constants.js").ConsensusProtocolVersion, tag: import("../constants.js").Tag): import("../constants.js").AbiVersion;
        serialize(value: import("../constants.js").AbiVersion | undefined, { tag }: {
            tag: import("../constants.js").Tag;
        }, { consensusProtocolVersion, }: {
            consensusProtocolVersion?: import("../constants.js").ConsensusProtocolVersion;
        }): Buffer;
        prepare(value: import("../constants.js").AbiVersion | undefined, { tag }: {
            tag: import("../constants.js").Tag;
        }, options: {
            consensusProtocolVersion?: import("../constants.js").ConsensusProtocolVersion;
            onNode?: import("../../../Node.js").default;
        }): Promise<import("../constants.js").AbiVersion | undefined>;
        deserialize(buffer: Buffer): import("../constants.js").AbiVersion;
    };
    readonly amount: {
        serialize(value: import("../constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly callData: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly callStack: {
        serialize(buffer: Uint8Array): Buffer;
        deserialize(buffer: Buffer): Buffer;
    };
    readonly gasPrice: {
        prepare(value: import("../constants.js").Int | undefined, params: {}, { onNode, denomination, }: {
            onNode?: import("../../../Node.js").default;
            denomination?: import("../../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Promise<import("../constants.js").Int | undefined>;
        serializeAettos(value?: string | undefined): string;
        serialize(value: import("../constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gasLimit: {
        serialize(_value: number | undefined, { tag, rebuildTx, unpackTx, buildTx, _computingGasLimit, }: {
            tag: import("../constants.js").Tag;
            rebuildTx: (params: any) => any;
            unpackTx: typeof import("../index.js").unpackTx;
            buildTx: typeof import("../index.js").buildTx;
            _computingGasLimit?: number;
        }, { gasMax }: {
            gasMax?: number;
        }): Buffer;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.TreesPoi) => Buffer;
        deserialize: (value: Buffer) => EntryTag.TreesPoi;
        constValue: EntryTag.TreesPoi;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accounts: {
        serialize: (value: readonly {
            readonly "__#2@#rootHash": string;
            "__#2@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#2@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#2@#encoding": Encoded.Encoding.AccountAddress;
            readonly "__#2@#tag": EntryTag.Account;
            readonly "__#2@#unpackEntry": typeof import("./index.js").unpackEntry;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#2@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ak_${string}`): (import("./schema.generated.js").EntUnpackedAccount1 & {
                tag: EntryTag.Account;
            }) | (import("./schema.generated.js").EntUnpackedAccount2 & {
                tag: EntryTag.Account;
            }) | undefined;
            "__#2@#entriesRaw"(): Array<[string, Buffer]>;
            toObject(): Record<`ak_${string}`, (import("./schema.generated.js").EntUnpackedAccount1 & {
                tag: EntryTag.Account;
            }) | (import("./schema.generated.js").EntUnpackedAccount2 & {
                tag: EntryTag.Account;
            })>;
        }[], params: unknown) => [Buffer, [Buffer, Buffer[]][]][];
        deserialize: (value: [Buffer, [Buffer, Buffer[]][]][], params: unknown) => {
            readonly "__#2@#rootHash": string;
            "__#2@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#2@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#2@#encoding": Encoded.Encoding.AccountAddress;
            readonly "__#2@#tag": EntryTag.Account;
            readonly "__#2@#unpackEntry": typeof import("./index.js").unpackEntry;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#2@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ak_${string}`): (import("./schema.generated.js").EntUnpackedAccount1 & {
                tag: EntryTag.Account;
            }) | (import("./schema.generated.js").EntUnpackedAccount2 & {
                tag: EntryTag.Account;
            }) | undefined;
            "__#2@#entriesRaw"(): Array<[string, Buffer]>;
            toObject(): Record<`ak_${string}`, (import("./schema.generated.js").EntUnpackedAccount1 & {
                tag: EntryTag.Account;
            }) | (import("./schema.generated.js").EntUnpackedAccount2 & {
                tag: EntryTag.Account;
            })>;
        }[];
    };
    readonly calls: {
        serialize: (value: readonly {
            readonly "__#2@#rootHash": string;
            "__#2@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#2@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#2@#encoding": Encoded.Encoding.Bytearray;
            readonly "__#2@#tag": EntryTag.ContractCall;
            readonly "__#2@#unpackEntry": typeof import("./index.js").unpackEntry;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#2@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ba_${string}`): (import("./schema.generated.js").EntUnpackedContractCall2 & {
                tag: EntryTag.ContractCall;
            }) | undefined;
            "__#2@#entriesRaw"(): Array<[string, Buffer]>;
            toObject(): Record<`ba_${string}`, import("./schema.generated.js").EntUnpackedContractCall2 & {
                tag: EntryTag.ContractCall;
            }>;
        }[], params: unknown) => [Buffer, [Buffer, Buffer[]][]][];
        deserialize: (value: [Buffer, [Buffer, Buffer[]][]][], params: unknown) => {
            readonly "__#2@#rootHash": string;
            "__#2@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#2@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#2@#encoding": Encoded.Encoding.Bytearray;
            readonly "__#2@#tag": EntryTag.ContractCall;
            readonly "__#2@#unpackEntry": typeof import("./index.js").unpackEntry;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#2@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ba_${string}`): (import("./schema.generated.js").EntUnpackedContractCall2 & {
                tag: EntryTag.ContractCall;
            }) | undefined;
            "__#2@#entriesRaw"(): Array<[string, Buffer]>;
            toObject(): Record<`ba_${string}`, import("./schema.generated.js").EntUnpackedContractCall2 & {
                tag: EntryTag.ContractCall;
            }>;
        }[];
    };
    readonly channels: {
        serialize: (value: readonly {
            readonly "__#2@#rootHash": string;
            "__#2@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#2@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#2@#encoding": Encoded.Encoding.Channel;
            readonly "__#2@#tag": EntryTag.Channel;
            readonly "__#2@#unpackEntry": typeof import("./index.js").unpackEntry;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#2@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ch_${string}`): (import("./schema.generated.js").EntUnpackedChannel3 & {
                tag: EntryTag.Channel;
            }) | undefined;
            "__#2@#entriesRaw"(): Array<[string, Buffer]>;
            toObject(): Record<`ch_${string}`, import("./schema.generated.js").EntUnpackedChannel3 & {
                tag: EntryTag.Channel;
            }>;
        }[], params: unknown) => [Buffer, [Buffer, Buffer[]][]][];
        deserialize: (value: [Buffer, [Buffer, Buffer[]][]][], params: unknown) => {
            readonly "__#2@#rootHash": string;
            "__#2@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#2@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#2@#encoding": Encoded.Encoding.Channel;
            readonly "__#2@#tag": EntryTag.Channel;
            readonly "__#2@#unpackEntry": typeof import("./index.js").unpackEntry;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#2@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ch_${string}`): (import("./schema.generated.js").EntUnpackedChannel3 & {
                tag: EntryTag.Channel;
            }) | undefined;
            "__#2@#entriesRaw"(): Array<[string, Buffer]>;
            toObject(): Record<`ch_${string}`, import("./schema.generated.js").EntUnpackedChannel3 & {
                tag: EntryTag.Channel;
            }>;
        }[];
    };
    readonly contracts: {
        serialize: (value: readonly {
            readonly "__#2@#rootHash": string;
            "__#2@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#2@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#2@#encoding": Encoded.Encoding.ContractAddress;
            readonly "__#2@#tag": EntryTag.Contract;
            readonly "__#2@#unpackEntry": typeof import("./index.js").unpackEntry;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#2@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ct_${string}`): (import("./schema.generated.js").EntUnpackedContract1 & {
                tag: EntryTag.Contract;
            }) | undefined;
            "__#2@#entriesRaw"(): Array<[string, Buffer]>;
            toObject(): Record<`ct_${string}`, import("./schema.generated.js").EntUnpackedContract1 & {
                tag: EntryTag.Contract;
            }>;
        }[], params: unknown) => [Buffer, [Buffer, Buffer[]][]][];
        deserialize: (value: [Buffer, [Buffer, Buffer[]][]][], params: unknown) => {
            readonly "__#2@#rootHash": string;
            "__#2@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#2@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#2@#encoding": Encoded.Encoding.ContractAddress;
            readonly "__#2@#tag": EntryTag.Contract;
            readonly "__#2@#unpackEntry": typeof import("./index.js").unpackEntry;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#2@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ct_${string}`): (import("./schema.generated.js").EntUnpackedContract1 & {
                tag: EntryTag.Contract;
            }) | undefined;
            "__#2@#entriesRaw"(): Array<[string, Buffer]>;
            toObject(): Record<`ct_${string}`, import("./schema.generated.js").EntUnpackedContract1 & {
                tag: EntryTag.Contract;
            }>;
        }[];
    };
    readonly ns: {
        serialize: (value: readonly {
            readonly "__#2@#rootHash": string;
            "__#2@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#2@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#2@#encoding": Encoded.Encoding.Name;
            readonly "__#2@#tag": EntryTag.Name;
            readonly "__#2@#unpackEntry": typeof import("./index.js").unpackEntry;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#2@#getRaw"(_key: string): Buffer | undefined;
            get(key: `nm_${string}`): (import("./schema.generated.js").EntUnpackedName1 & {
                tag: EntryTag.Name;
            }) | undefined;
            "__#2@#entriesRaw"(): Array<[string, Buffer]>;
            toObject(): Record<`nm_${string}`, import("./schema.generated.js").EntUnpackedName1 & {
                tag: EntryTag.Name;
            }>;
        }[], params: unknown) => [Buffer, [Buffer, Buffer[]][]][];
        deserialize: (value: [Buffer, [Buffer, Buffer[]][]][], params: unknown) => {
            readonly "__#2@#rootHash": string;
            "__#2@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#2@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#2@#encoding": Encoded.Encoding.Name;
            readonly "__#2@#tag": EntryTag.Name;
            readonly "__#2@#unpackEntry": typeof import("./index.js").unpackEntry;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#2@#getRaw"(_key: string): Buffer | undefined;
            get(key: `nm_${string}`): (import("./schema.generated.js").EntUnpackedName1 & {
                tag: EntryTag.Name;
            }) | undefined;
            "__#2@#entriesRaw"(): Array<[string, Buffer]>;
            toObject(): Record<`nm_${string}`, import("./schema.generated.js").EntUnpackedName1 & {
                tag: EntryTag.Name;
            }>;
        }[];
    };
    readonly oracles: {
        serialize: (value: readonly {
            readonly "__#2@#rootHash": string;
            "__#2@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#2@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#2@#encoding": Encoded.Encoding.OracleAddress;
            readonly "__#2@#tag": EntryTag.Oracle;
            readonly "__#2@#unpackEntry": typeof import("./index.js").unpackEntry;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#2@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ok_${string}`): (import("./schema.generated.js").EntUnpackedOracle1 & {
                tag: EntryTag.Oracle;
            }) | undefined;
            "__#2@#entriesRaw"(): Array<[string, Buffer]>;
            toObject(): Record<`ok_${string}`, import("./schema.generated.js").EntUnpackedOracle1 & {
                tag: EntryTag.Oracle;
            }>;
        }[], params: unknown) => [Buffer, [Buffer, Buffer[]][]][];
        deserialize: (value: [Buffer, [Buffer, Buffer[]][]][], params: unknown) => {
            readonly "__#2@#rootHash": string;
            "__#2@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#2@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#2@#encoding": Encoded.Encoding.OracleAddress;
            readonly "__#2@#tag": EntryTag.Oracle;
            readonly "__#2@#unpackEntry": typeof import("./index.js").unpackEntry;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#2@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ok_${string}`): (import("./schema.generated.js").EntUnpackedOracle1 & {
                tag: EntryTag.Oracle;
            }) | undefined;
            "__#2@#entriesRaw"(): Array<[string, Buffer]>;
            toObject(): Record<`ok_${string}`, import("./schema.generated.js").EntUnpackedOracle1 & {
                tag: EntryTag.Oracle;
            }>;
        }[];
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.StateTrees) => Buffer;
        deserialize: (value: Buffer) => EntryTag.StateTrees;
        constValue: EntryTag.StateTrees;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 0 | undefined) => Buffer;
        deserialize: (value: Buffer) => 0;
        constValue: 0;
        constValueOptional: boolean;
    };
    readonly contracts: MapContracts;
    readonly calls: MapCalls;
    readonly channels: MapChannels;
    readonly ns: MapNames;
    readonly oracles: MapOracles;
    readonly accounts: MapAccounts;
}, {
    readonly tag: {
        serialize: (value: EntryTag.Mtree) => Buffer;
        deserialize: (value: Buffer) => EntryTag.Mtree;
        constValue: EntryTag.Mtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly values: EntryMtreeValueArray;
}, {
    readonly tag: {
        serialize: (value: EntryTag.MtreeValue) => Buffer;
        deserialize: (value: Buffer) => EntryTag.MtreeValue;
        constValue: EntryTag.MtreeValue;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly key: {
        serialize(buffer: Uint8Array): Buffer;
        deserialize(buffer: Buffer): Buffer;
    };
    readonly value: {
        serialize(buffer: Uint8Array): Buffer;
        deserialize(buffer: Buffer): Buffer;
    };
}, {
    readonly tag: {
        serialize: (value: EntryTag.ContractsMtree) => Buffer;
        deserialize: (value: Buffer) => EntryTag.ContractsMtree;
        constValue: EntryTag.ContractsMtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payload: MapContracts;
}, {
    readonly tag: {
        serialize: (value: EntryTag.CallsMtree) => Buffer;
        deserialize: (value: Buffer) => EntryTag.CallsMtree;
        constValue: EntryTag.CallsMtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payload: MapCalls;
}, {
    readonly tag: {
        serialize: (value: EntryTag.ChannelsMtree) => Buffer;
        deserialize: (value: Buffer) => EntryTag.ChannelsMtree;
        constValue: EntryTag.ChannelsMtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payload: MapChannels;
}, {
    readonly tag: {
        serialize: (value: EntryTag.NameserviceMtree) => Buffer;
        deserialize: (value: Buffer) => EntryTag.NameserviceMtree;
        constValue: EntryTag.NameserviceMtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payload: MapNames;
}, {
    readonly tag: {
        serialize: (value: EntryTag.OraclesMtree) => Buffer;
        deserialize: (value: Buffer) => EntryTag.OraclesMtree;
        constValue: EntryTag.OraclesMtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payload: MapOracles;
}, {
    readonly tag: {
        serialize: (value: EntryTag.AccountsMtree) => Buffer;
        deserialize: (value: Buffer) => EntryTag.AccountsMtree;
        constValue: EntryTag.AccountsMtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payload: MapAccounts;
}, {
    readonly tag: {
        serialize: (value: EntryTag.GaMetaTxAuthData) => Buffer;
        deserialize: (value: Buffer) => EntryTag.GaMetaTxAuthData;
        constValue: EntryTag.GaMetaTxAuthData;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly fee: {
        serializeAettos(value: string | undefined, params: {}, options: {}): string;
        serialize(value: import("../constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gasPrice: {
        prepare(value: import("../constants.js").Int | undefined, params: {}, { onNode, denomination, }: {
            onNode?: import("../../../Node.js").default;
            denomination?: import("../../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Promise<import("../constants.js").Int | undefined>;
        serializeAettos(value?: string | undefined): string;
        serialize(value: import("../constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly txHash: {
        serialize: (value: `th_${string}`) => Buffer;
        deserialize: (value: Buffer) => `th_${string}`;
    };
}];
type Schemas = SchemaTypes<typeof schemas>;
export type EntParams = Schemas['TxParams'];
export type EntUnpacked = Schemas['TxUnpacked'];
export {};
