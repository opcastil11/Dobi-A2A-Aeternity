{"version":3,"file":"map.js","names":["EntryTag","encode","Encoding","decode","genMapField","encoding","tag","serialize","object","packEntry","Mtree","values","Object","entries","map","key","value","MtreeValue","deserialize","buffer","unpackEntry","Bytearray","fromEntries","filter","ContractAddress","length","recursiveType"],"sources":["../../../../src/tx/builder/field-types/map.ts"],"sourcesContent":["import { EntryTag } from '../entry/constants.js';\nimport { encode, Encoding, Encoded, decode } from '../../../utils/encoder.js';\nimport type { unpackEntry as unpackEntryType, packEntry as packEntryType } from '../entry/index.js';\n\nexport default function genMapField<E extends Encoding, T extends EntryTag>(\n  encoding: E,\n  tag: T,\n): {\n  serialize: (\n    // TODO: replace with `TxParams & { tag: T }`,\n    //  but fix TS2502 value is referenced directly or indirectly in its own type annotation\n    value: Record<Encoded.Generic<E>, any>,\n    options: { packEntry: typeof packEntryType },\n  ) => Buffer;\n  deserialize: (\n    value: Buffer,\n    options: { unpackEntry: typeof unpackEntryType },\n    // TODO: replace with `TxUnpacked & { tag: T }`,\n    //  TS2577 Return type annotation circularly references itself\n  ) => Record<Encoded.Generic<E>, any>;\n  recursiveType: true;\n} {\n  return {\n    serialize(object, { packEntry }) {\n      return decode(\n        packEntry({\n          tag: EntryTag.Mtree,\n          values: Object.entries(object).map(\n            ([key, value]) =>\n              ({\n                tag: EntryTag.MtreeValue,\n                key: decode(key as Encoded.Generic<E>),\n                value: decode(packEntry({ ...(value as any), tag })),\n              }) as const,\n          ),\n        }),\n      );\n    },\n\n    deserialize(buffer, { unpackEntry }) {\n      const { values } = unpackEntry(encode(buffer, Encoding.Bytearray), EntryTag.Mtree);\n      return Object.fromEntries(\n        values\n          // TODO: remove after resolving https://github.com/aeternity/aeternity/issues/4066\n          .filter(({ key }) => encoding !== Encoding.ContractAddress || key.length === 32)\n          .map(({ key, value }) => [\n            encode(key, encoding),\n            unpackEntry(encode(value, Encoding.Bytearray), tag),\n          ]),\n      ) as Record<Encoded.Generic<E>, any>;\n    },\n\n    recursiveType: true,\n  };\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,MAAM,EAAEC,QAAQ,EAAWC,MAAM,QAAQ,2BAA2B;AAG7E,eAAe,SAASC,WAAWA,CACjCC,QAAW,EACXC,GAAM,EAeN;EACA,OAAO;IACLC,SAASA,CAACC,MAAM,EAAE;MAAEC;IAAU,CAAC,EAAE;MAC/B,OAAON,MAAM,CACXM,SAAS,CAAC;QACRH,GAAG,EAAEN,QAAQ,CAACU,KAAK;QACnBC,MAAM,EAAEC,MAAM,CAACC,OAAO,CAACL,MAAM,CAAC,CAACM,GAAG,CAChC,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,MACV;UACCV,GAAG,EAAEN,QAAQ,CAACiB,UAAU;UACxBF,GAAG,EAAEZ,MAAM,CAACY,GAAyB,CAAC;UACtCC,KAAK,EAAEb,MAAM,CAACM,SAAS,CAAC;YAAE,GAAIO,KAAa;YAAEV;UAAI,CAAC,CAAC;QACrD,CAAC,CACL;MACF,CAAC,CACH,CAAC;IACH,CAAC;IAEDY,WAAWA,CAACC,MAAM,EAAE;MAAEC;IAAY,CAAC,EAAE;MACnC,MAAM;QAAET;MAAO,CAAC,GAAGS,WAAW,CAACnB,MAAM,CAACkB,MAAM,EAAEjB,QAAQ,CAACmB,SAAS,CAAC,EAAErB,QAAQ,CAACU,KAAK,CAAC;MAClF,OAAOE,MAAM,CAACU,WAAW,CACvBX;MACE;MAAA,CACCY,MAAM,CAAC,CAAC;QAAER;MAAI,CAAC,KAAKV,QAAQ,KAAKH,QAAQ,CAACsB,eAAe,IAAIT,GAAG,CAACU,MAAM,KAAK,EAAE,CAAC,CAC/EX,GAAG,CAAC,CAAC;QAAEC,GAAG;QAAEC;MAAM,CAAC,KAAK,CACvBf,MAAM,CAACc,GAAG,EAAEV,QAAQ,CAAC,EACrBe,WAAW,CAACnB,MAAM,CAACe,KAAK,EAAEd,QAAQ,CAACmB,SAAS,CAAC,EAAEf,GAAG,CAAC,CACpD,CACL,CAAC;IACH,CAAC;IAEDoB,aAAa,EAAE;EACjB,CAAC;AACH","ignoreList":[]}