{"version":3,"file":"wrapped.js","names":["encode","Encoding","decode","genWrappedField","tag","serialize","payload","packEntry","deserialize","buffer","unpackEntry","Bytearray","recursiveType"],"sources":["../../../../src/tx/builder/field-types/wrapped.ts"],"sourcesContent":["import { EntryTag } from '../entry/constants.js';\nimport { encode, Encoding, decode } from '../../../utils/encoder.js';\nimport type { unpackEntry as unpackEntryType, packEntry as packEntryType } from '../entry/index.js';\n\ntype TagWrapping =\n  | EntryTag.AccountsMtree\n  | EntryTag.CallsMtree\n  | EntryTag.ChannelsMtree\n  | EntryTag.ContractsMtree\n  | EntryTag.NameserviceMtree\n  | EntryTag.OraclesMtree;\n\nexport default function genWrappedField<T extends TagWrapping>(\n  tag: T,\n): {\n  serialize: (\n    // TODO: replace with `(EntParams & { tag: T })['payload']`,\n    //  but fix TS2502 value is referenced directly or indirectly in its own type annotation\n    value: any,\n    options: { packEntry: typeof packEntryType },\n  ) => Buffer;\n  deserialize: (\n    value: Buffer,\n    options: { unpackEntry: typeof unpackEntryType },\n    // TODO: replace with `(EntUnpacked & { tag: T })['payload']`,\n    //  TS2577 Return type annotation circularly references itself\n  ) => any;\n  recursiveType: true;\n} {\n  return {\n    serialize(payload, { packEntry }) {\n      return decode(packEntry({ tag, payload }));\n    },\n\n    deserialize(buffer, { unpackEntry }) {\n      return unpackEntry<TagWrapping>(encode(buffer, Encoding.Bytearray), tag).payload;\n    },\n\n    recursiveType: true,\n  };\n}\n"],"mappings":"AACA,SAASA,MAAM,EAAEC,QAAQ,EAAEC,MAAM,QAAQ,2BAA2B;AAWpE,eAAe,SAASC,eAAeA,CACrCC,GAAM,EAeN;EACA,OAAO;IACLC,SAASA,CAACC,OAAO,EAAE;MAAEC;IAAU,CAAC,EAAE;MAChC,OAAOL,MAAM,CAACK,SAAS,CAAC;QAAEH,GAAG;QAAEE;MAAQ,CAAC,CAAC,CAAC;IAC5C,CAAC;IAEDE,WAAWA,CAACC,MAAM,EAAE;MAAEC;IAAY,CAAC,EAAE;MACnC,OAAOA,WAAW,CAAcV,MAAM,CAACS,MAAM,EAAER,QAAQ,CAACU,SAAS,CAAC,EAAEP,GAAG,CAAC,CAACE,OAAO;IAClF,CAAC;IAEDM,aAAa,EAAE;EACjB,CAAC;AACH","ignoreList":[]}