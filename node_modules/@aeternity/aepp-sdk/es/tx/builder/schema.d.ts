/**
 * Transaction Schema for TxBuilder
 */
import { Tag } from './constants.js';
import SchemaTypes from './SchemaTypes.js';
import coinAmount from './field-types/coin-amount.js';
import { Encoded, Encoding } from '../../utils/encoder.js';
import { EntryTag } from './entry/constants.js';
import { EntParams, EntUnpacked } from './entry/schema.generated.js';
/**
 * @category oracle
 */
export declare enum ORACLE_TTL_TYPES {
    delta = 0,
    block = 1
}
interface TransactionAny {
    serialize: (value: TxParams | Uint8Array | Encoded.Transaction) => Buffer;
    deserialize: (value: Buffer) => TxUnpacked;
    recursiveType: true;
}
interface TransactionSignedTx {
    serialize: (value: (TxParams & {
        tag: Tag.SignedTx;
    }) | Uint8Array | Encoded.Transaction) => Buffer;
    deserialize: (value: Buffer) => TxUnpacked & {
        tag: Tag.SignedTx;
    };
    recursiveType: true;
}
interface EntryTreesPoi {
    serialize: (value: (EntParams & {
        tag: EntryTag.TreesPoi;
    }) | Uint8Array | Encoded.Transaction) => Buffer;
    deserialize: (value: Buffer) => EntUnpacked & {
        tag: EntryTag.TreesPoi;
    };
    recursiveType: true;
}
/**
 * @see {@link https://github.com/aeternity/protocol/blob/c007deeac4a01e401238412801ac7084ac72d60e/serializations.md#accounts-version-1-basic-accounts}
 */
export declare const txSchema: readonly [{
    readonly tag: {
        serialize: (value: Tag.SignedTx) => Buffer;
        deserialize: (value: Buffer) => Tag.SignedTx;
        constValue: Tag.SignedTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly signatures: {
        serialize: (value: readonly Uint8Array[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => Buffer[];
    };
    readonly encodedTx: TransactionAny;
}, {
    readonly tag: {
        serialize: (value: Tag.SpendTx) => Buffer;
        deserialize: (value: Buffer) => Tag.SpendTx;
        constValue: Tag.SpendTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly senderId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly recipientId: {
        serialize: (value: `ct_${string}` | `ak_${string}` | `nm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ct_${string}` | `ak_${string}` | `nm_${string}`;
    };
    readonly amount: {
        serializeAettos(value: string | undefined, params: {}, options: {}): string;
        serialize(value: import("./constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            senderId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly payload: {
        serialize: (value?: `ba_${string}` | undefined) => Buffer;
        deserialize: (value: Buffer) => `ba_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.NamePreclaimTx) => Buffer;
        deserialize: (value: Buffer) => Tag.NamePreclaimTx;
        constValue: Tag.NamePreclaimTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            accountId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly commitmentId: {
        serialize: (value: `cm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cm_${string}`;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.NameClaimTx) => Buffer;
        deserialize: (value: Buffer) => Tag.NameClaimTx;
        constValue: Tag.NameClaimTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 2 | undefined) => Buffer;
        deserialize: (value: Buffer) => 2;
        constValue: 2;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            accountId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly name: {
        serialize(value: import("./constants.js").AensName): Buffer;
        deserialize(value: Buffer): import("./constants.js").AensName;
    };
    readonly nameSalt: {
        serialize: (value: import("./constants.js").Int | undefined, params: unknown) => Buffer;
        deserialize: (value: Buffer, params: unknown) => string;
    };
    readonly nameFee: {
        serializeAettos(_value: string | undefined, txFields: {
            name: import("./constants.js").AensName;
        }): string;
        serialize(value: import("./constants.js").Int | undefined, txFields: {
            name: import("./constants.js").AensName;
        } & Parameters<(typeof coinAmount)["serialize"]>[1], parameters: Parameters<(typeof coinAmount)["serialize"]>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.NameUpdateTx) => Buffer;
        deserialize: (value: Buffer) => Tag.NameUpdateTx;
        constValue: Tag.NameUpdateTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            accountId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly nameId: {
        serialize(value: import("./constants.js").AensName | Encoded.Name): Buffer;
        deserialize: (value: Buffer) => `nm_${string}`;
    };
    readonly nameTtl: {
        serialize: (value: number | undefined, params: unknown, options: unknown) => Buffer;
        deserialize: (value: Buffer) => number;
    };
    readonly pointers: {
        serialize: (pointers: (import("../../apis/node/index.js").NamePointer & {
            id: Encoded.Generic<import("./field-types/address.js").AddressEncodings>;
        })[]) => Buffer[][];
        deserialize: (pointers: Array<[key: Buffer, id: Buffer]>) => (import("../../apis/node/index.js").NamePointer & {
            id: Encoded.Generic<import("./field-types/address.js").AddressEncodings>;
        })[];
    };
    readonly clientTtl: {
        serialize: (value: number | undefined, params: unknown) => Buffer;
        deserialize: (value: Buffer, params: unknown) => number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.NameUpdateTx) => Buffer;
        deserialize: (value: Buffer) => Tag.NameUpdateTx;
        constValue: Tag.NameUpdateTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value: 2) => Buffer;
        deserialize: (value: Buffer) => 2;
        constValue: 2;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            accountId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly nameId: {
        serialize(value: import("./constants.js").AensName | Encoded.Name): Buffer;
        deserialize: (value: Buffer) => `nm_${string}`;
    };
    readonly nameTtl: {
        serialize: (value: number | undefined, params: unknown, options: unknown) => Buffer;
        deserialize: (value: Buffer) => number;
    };
    readonly pointers: {
        serialize: (pointers: (import("../../apis/node/index.js").NamePointer & {
            id: Encoded.Generic<import("./field-types/address.js").AddressEncodings | Encoding.Bytearray>;
        })[]) => Buffer[][];
        deserialize: (pointers: Array<[key: Buffer, id: Buffer]>) => (import("../../apis/node/index.js").NamePointer & {
            id: Encoded.Generic<import("./field-types/address.js").AddressEncodings | Encoding.Bytearray>;
        })[];
    };
    readonly clientTtl: {
        serialize: (value: number | undefined, params: unknown) => Buffer;
        deserialize: (value: Buffer, params: unknown) => number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.NameTransferTx) => Buffer;
        deserialize: (value: Buffer) => Tag.NameTransferTx;
        constValue: Tag.NameTransferTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            accountId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly nameId: {
        serialize(value: import("./constants.js").AensName | Encoded.Name): Buffer;
        deserialize: (value: Buffer) => `nm_${string}`;
    };
    readonly recipientId: {
        serialize: (value: `ak_${string}` | `nm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}` | `nm_${string}`;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.NameRevokeTx) => Buffer;
        deserialize: (value: Buffer) => Tag.NameRevokeTx;
        constValue: Tag.NameRevokeTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            accountId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly nameId: {
        serialize(value: import("./constants.js").AensName | Encoded.Name): Buffer;
        deserialize: (value: Buffer) => `nm_${string}`;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ContractCreateTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ContractCreateTx;
        constValue: Tag.ContractCreateTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly ownerId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            ownerId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly code: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly ctVersion: {
        serialize(value: import("./field-types/ct-version.js").CtVersion | undefined, params: {}, { consensusProtocolVersion, }: {
            consensusProtocolVersion?: import("./constants.js").ConsensusProtocolVersion;
        }): Buffer;
        prepare(value: import("./field-types/ct-version.js").CtVersion | undefined, params: {}, options: {
            consensusProtocolVersion?: import("./constants.js").ConsensusProtocolVersion;
            onNode?: import("../../Node.js").default;
        }): Promise<import("./field-types/ct-version.js").CtVersion | undefined>;
        deserialize(buffer: Buffer): import("./field-types/ct-version.js").CtVersion;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly deposit: {
        serialize: (value: import("./constants.js").Int | undefined, params: {}, options: {
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }) => Buffer;
        deserialize: (value: Buffer) => string;
    };
    readonly amount: {
        serializeAettos(value: string | undefined, params: {}, options: {}): string;
        serialize(value: import("./constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gasLimit: {
        serialize(_value: number | undefined, { tag, rebuildTx, unpackTx, buildTx, _computingGasLimit, }: {
            tag: Tag;
            rebuildTx: (params: any) => any;
            unpackTx: typeof import("./index.js").unpackTx;
            buildTx: typeof import("./index.js").buildTx;
            _computingGasLimit?: number;
        }, { gasMax }: {
            gasMax?: number;
        }): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly gasPrice: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode, denomination, }: {
            onNode?: import("../../Node.js").default;
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(value?: string | undefined): string;
        serialize(value: import("./constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly callData: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ContractCallTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ContractCallTx;
        constValue: Tag.ContractCallTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly callerId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            callerId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly contractId: {
        serialize: (value: `ct_${string}` | `nm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ct_${string}` | `nm_${string}`;
    };
    readonly abiVersion: {
        _getProtocolDetails(c: import("./constants.js").ConsensusProtocolVersion, tag: Tag): import("./constants.js").AbiVersion;
        serialize(value: import("./constants.js").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, { consensusProtocolVersion, }: {
            consensusProtocolVersion?: import("./constants.js").ConsensusProtocolVersion;
        }): Buffer;
        prepare(value: import("./constants.js").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, options: {
            consensusProtocolVersion?: import("./constants.js").ConsensusProtocolVersion;
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").AbiVersion | undefined>;
        deserialize(buffer: Buffer): import("./constants.js").AbiVersion;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly amount: {
        serializeAettos(value: string | undefined, params: {}, options: {}): string;
        serialize(value: import("./constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gasLimit: {
        serialize(_value: number | undefined, { tag, rebuildTx, unpackTx, buildTx, _computingGasLimit, }: {
            tag: Tag;
            rebuildTx: (params: any) => any;
            unpackTx: typeof import("./index.js").unpackTx;
            buildTx: typeof import("./index.js").buildTx;
            _computingGasLimit?: number;
        }, { gasMax }: {
            gasMax?: number;
        }): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly gasPrice: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode, denomination, }: {
            onNode?: import("../../Node.js").default;
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(value?: string | undefined): string;
        serialize(value: import("./constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly callData: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.OracleRegisterTx) => Buffer;
        deserialize: (value: Buffer) => Tag.OracleRegisterTx;
        constValue: Tag.OracleRegisterTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            accountId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly queryFormat: {
        serialize(string: string): Buffer;
        deserialize(buffer: Buffer): string;
    };
    readonly responseFormat: {
        serialize(string: string): Buffer;
        deserialize(buffer: Buffer): string;
    };
    readonly queryFee: {
        serializeAettos(value: string | undefined, params: {}, options: {}): string;
        serialize(value: import("./constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly oracleTtlType: {
        serialize: (value: ORACLE_TTL_TYPES | undefined, params: unknown) => Buffer;
        deserialize: (value: Buffer, params: unknown) => ORACLE_TTL_TYPES;
    };
    readonly oracleTtlValue: {
        serialize: (value: number | undefined, params: unknown) => Buffer;
        deserialize: (value: Buffer, params: unknown) => number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly abiVersion: {
        _getProtocolDetails(c: import("./constants.js").ConsensusProtocolVersion, tag: Tag): import("./constants.js").AbiVersion;
        serialize(value: import("./constants.js").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, { consensusProtocolVersion, }: {
            consensusProtocolVersion?: import("./constants.js").ConsensusProtocolVersion;
        }): Buffer;
        prepare(value: import("./constants.js").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, options: {
            consensusProtocolVersion?: import("./constants.js").ConsensusProtocolVersion;
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").AbiVersion | undefined>;
        deserialize(buffer: Buffer): import("./constants.js").AbiVersion;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.OracleExtendTx) => Buffer;
        deserialize: (value: Buffer) => Tag.OracleExtendTx;
        constValue: Tag.OracleExtendTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly oracleId: {
        serialize: (value: `ok_${string}` | `nm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ok_${string}` | `nm_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            oracleId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly oracleTtlType: {
        serialize: (value: ORACLE_TTL_TYPES | undefined, params: unknown) => Buffer;
        deserialize: (value: Buffer, params: unknown) => ORACLE_TTL_TYPES;
    };
    readonly oracleTtlValue: {
        serialize: (value: number | undefined, params: unknown) => Buffer;
        deserialize: (value: Buffer, params: unknown) => number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.OracleQueryTx) => Buffer;
        deserialize: (value: Buffer) => Tag.OracleQueryTx;
        constValue: Tag.OracleQueryTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly senderId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            senderId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly oracleId: {
        serialize: (value: `ok_${string}` | `nm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ok_${string}` | `nm_${string}`;
    };
    readonly query: {
        serialize(string: string): Buffer;
        deserialize(buffer: Buffer): string;
    };
    readonly queryFee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, options: {
            oracleId?: Encoded.OracleAddress;
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int>;
        serializeAettos(value: string | undefined, params: {}, options: {}): string;
        serialize(value: import("./constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly queryTtlType: {
        serialize: (value: ORACLE_TTL_TYPES | undefined, params: unknown) => Buffer;
        deserialize: (value: Buffer, params: unknown) => ORACLE_TTL_TYPES;
    };
    readonly queryTtlValue: {
        serialize: (value: number | undefined, params: unknown) => Buffer;
        deserialize: (value: Buffer, params: unknown) => number;
    };
    readonly responseTtlType: {
        serialize: (value: ORACLE_TTL_TYPES | undefined, params: unknown) => Buffer;
        deserialize: (value: Buffer, params: unknown) => ORACLE_TTL_TYPES;
    };
    readonly responseTtlValue: {
        serialize: (value: number | undefined, params: unknown) => Buffer;
        deserialize: (value: Buffer, params: unknown) => number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.OracleResponseTx) => Buffer;
        deserialize: (value: Buffer) => Tag.OracleResponseTx;
        constValue: Tag.OracleResponseTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly oracleId: {
        serialize: (value: `ok_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ok_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            oracleId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly queryId: {
        serialize: (value: `oq_${string}`) => Buffer;
        deserialize: (value: Buffer) => `oq_${string}`;
    };
    readonly response: {
        serialize(string: string): Buffer;
        deserialize(buffer: Buffer): string;
    };
    readonly responseTtlType: {
        serialize: (value: ORACLE_TTL_TYPES | undefined, params: unknown) => Buffer;
        deserialize: (value: Buffer, params: unknown) => ORACLE_TTL_TYPES;
    };
    readonly responseTtlValue: {
        serialize: (value: number | undefined, params: unknown) => Buffer;
        deserialize: (value: Buffer, params: unknown) => number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelCreateTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelCreateTx;
        constValue: Tag.ChannelCreateTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 2 | undefined) => Buffer;
        deserialize: (value: Buffer) => 2;
        constValue: 2;
        constValueOptional: boolean;
    };
    readonly initiator: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly initiatorAmount: {
        serialize(value: import("./constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly responder: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly responderAmount: {
        serialize(value: import("./constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly channelReserve: {
        serialize(value: import("./constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly lockPeriod: {
        serialize(value: import("./constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly initiatorDelegateIds: {
        serialize: (value: readonly (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[];
    };
    readonly responderDelegateIds: {
        serialize: (value: readonly (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[];
    };
    readonly stateHash: {
        serialize: (value: `st_${string}`) => Buffer;
        deserialize: (value: Buffer) => `st_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            initiator: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelCloseMutualTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelCloseMutualTx;
        constValue: Tag.ChannelCloseMutualTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly initiatorAmountFinal: {
        serialize(value: import("./constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly responderAmountFinal: {
        serialize(value: import("./constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelCloseSoloTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelCloseSoloTx;
        constValue: Tag.ChannelCloseSoloTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly payload: {
        serialize: (value: `tx_${string}`) => Buffer;
        deserialize: (value: Buffer) => `tx_${string}`;
    };
    readonly poi: EntryTreesPoi;
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelSlashTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelSlashTx;
        constValue: Tag.ChannelSlashTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly payload: {
        serialize: (value: `tx_${string}`) => Buffer;
        deserialize: (value: Buffer) => `tx_${string}`;
    };
    readonly poi: EntryTreesPoi;
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelDepositTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelDepositTx;
        constValue: Tag.ChannelDepositTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly amount: {
        serialize(value: import("./constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly stateHash: {
        serialize: (value: `st_${string}`) => Buffer;
        deserialize: (value: Buffer) => `st_${string}`;
    };
    readonly round: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelWithdrawTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelWithdrawTx;
        constValue: Tag.ChannelWithdrawTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly toId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly amount: {
        serialize(value: import("./constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly stateHash: {
        serialize: (value: `st_${string}`) => Buffer;
        deserialize: (value: Buffer) => `st_${string}`;
    };
    readonly round: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelSettleTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelSettleTx;
        constValue: Tag.ChannelSettleTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly initiatorAmountFinal: {
        serialize(value: import("./constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly responderAmountFinal: {
        serialize(value: import("./constants.js").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelForceProgressTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelForceProgressTx;
        constValue: Tag.ChannelForceProgressTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly payload: {
        serialize: (value: `tx_${string}`) => Buffer;
        deserialize: (value: Buffer) => `tx_${string}`;
    };
    readonly round: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly update: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly stateHash: {
        serialize: (value: `st_${string}`) => Buffer;
        deserialize: (value: Buffer) => `st_${string}`;
    };
    readonly offChainTrees: {
        serialize: (value: `ss_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ss_${string}`;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelOffChainTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelOffChainTx;
        constValue: Tag.ChannelOffChainTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 2 | undefined) => Buffer;
        deserialize: (value: Buffer) => 2;
        constValue: 2;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly round: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly stateHash: {
        serialize: (value: `st_${string}`) => Buffer;
        deserialize: (value: Buffer) => `st_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelSnapshotSoloTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelSnapshotSoloTx;
        constValue: Tag.ChannelSnapshotSoloTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly payload: {
        serialize: (value: `tx_${string}`) => Buffer;
        deserialize: (value: Buffer) => `tx_${string}`;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.GaAttachTx) => Buffer;
        deserialize: (value: Buffer) => Tag.GaAttachTx;
        constValue: Tag.GaAttachTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly ownerId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            ownerId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly code: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly authFun: {
        serialize(buffer: Uint8Array): Buffer;
        deserialize(buffer: Buffer): Buffer;
    };
    readonly ctVersion: {
        serialize(value: import("./field-types/ct-version.js").CtVersion | undefined, params: {}, { consensusProtocolVersion, }: {
            consensusProtocolVersion?: import("./constants.js").ConsensusProtocolVersion;
        }): Buffer;
        prepare(value: import("./field-types/ct-version.js").CtVersion | undefined, params: {}, options: {
            consensusProtocolVersion?: import("./constants.js").ConsensusProtocolVersion;
            onNode?: import("../../Node.js").default;
        }): Promise<import("./field-types/ct-version.js").CtVersion | undefined>;
        deserialize(buffer: Buffer): import("./field-types/ct-version.js").CtVersion;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl, _isInternalBuild, ...options }: {
            onNode?: import("../../Node.js").default;
            absoluteTtl?: boolean;
            _isInternalBuild?: boolean;
        } & Omit<Parameters<typeof import("../../chain.js")._getPollInterval>[1], "onNode">): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly gasLimit: {
        serialize(_value: number | undefined, { tag, rebuildTx, unpackTx, buildTx, _computingGasLimit, }: {
            tag: Tag;
            rebuildTx: (params: any) => any;
            unpackTx: typeof import("./index.js").unpackTx;
            buildTx: typeof import("./index.js").buildTx;
            _computingGasLimit?: number;
        }, { gasMax }: {
            gasMax?: number;
        }): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly gasPrice: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode, denomination, }: {
            onNode?: import("../../Node.js").default;
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(value?: string | undefined): string;
        serialize(value: import("./constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly callData: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.GaMetaTx) => Buffer;
        deserialize: (value: Buffer) => Tag.GaMetaTx;
        constValue: Tag.GaMetaTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 2 | undefined) => Buffer;
        deserialize: (value: Buffer) => 2;
        constValue: 2;
        constValueOptional: boolean;
    };
    readonly gaId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly authData: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly abiVersion: {
        _getProtocolDetails(c: import("./constants.js").ConsensusProtocolVersion, tag: Tag): import("./constants.js").AbiVersion;
        serialize(value: import("./constants.js").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, { consensusProtocolVersion, }: {
            consensusProtocolVersion?: import("./constants.js").ConsensusProtocolVersion;
        }): Buffer;
        prepare(value: import("./constants.js").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, options: {
            consensusProtocolVersion?: import("./constants.js").ConsensusProtocolVersion;
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").AbiVersion | undefined>;
        deserialize(buffer: Buffer): import("./constants.js").AbiVersion;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gasLimit: {
        serialize(_value: number | undefined, { tag, rebuildTx, unpackTx, buildTx, _computingGasLimit, }: {
            tag: Tag;
            rebuildTx: (params: any) => any;
            unpackTx: typeof import("./index.js").unpackTx;
            buildTx: typeof import("./index.js").buildTx;
            _computingGasLimit?: number;
        }, { gasMax }: {
            gasMax?: number;
        }): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly gasPrice: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode, denomination, }: {
            onNode?: import("../../Node.js").default;
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(value?: string | undefined): string;
        serialize(value: import("./constants.js").Int | undefined, params: {}, { denomination, ...options }: {
            denomination?: import("../../index-browser.js").AE_AMOUNT_FORMATS;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly tx: TransactionSignedTx;
}, {
    readonly tag: {
        serialize: (value: Tag.PayingForTx) => Buffer;
        deserialize: (value: Buffer) => Tag.PayingForTx;
        constValue: Tag.PayingForTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payerId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number, params: {
            tag: Tag;
        }) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            payerId: string;
        } & {
            strategy?: import("../../apis/node/index.js").Enum1;
            onNode?: import("../../Node.js").default;
            _isInternalBuild?: boolean;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly fee: {
        prepare(value: import("./constants.js").Int | undefined, params: {}, { onNode }: {
            onNode?: import("../../Node.js").default;
        }): Promise<import("./constants.js").Int | undefined>;
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee }: import("./field-types/fee.js").SerializeAettosParams, { _canIncreaseFee }: {
            _canIncreaseFee?: boolean;
        }): string;
        serialize(value: Parameters<typeof coinAmount.serialize>[0], params: Parameters<typeof coinAmount.serialize>[1] & import("./field-types/fee.js").SerializeAettosParams, options: {
            _canIncreaseFee?: boolean;
        } & Parameters<typeof coinAmount.serialize>[2]): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly tx: TransactionSignedTx;
}];
type TxSchema = SchemaTypes<typeof txSchema>;
export type TxParams = TxSchema['TxParams'];
export type TxParamsAsync = TxSchema['TxParamsAsync'];
export type TxUnpacked = TxSchema['TxUnpacked'];
export {};
