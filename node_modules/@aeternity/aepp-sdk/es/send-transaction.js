import verifyTransaction from './tx/validator.js';
import { ensureError } from './utils/other.js';
import { TransactionError } from './utils/errors.js';
import { buildTxHash } from './tx/builder/index.js';
import { poll, waitForTxConfirm } from './chain.js';

/**
 * @category exception
 */
export class InvalidTxError extends TransactionError {
  constructor(message, validation, transaction) {
    super(message);
    this.name = 'InvalidTxError';
    this.validation = validation;
    this.transaction = transaction;
  }
}

/**
 * Signs and submits transaction for mining
 * @category chain
 * @param txUnsigned - Transaction to sign and submit
 * @param options - Options
 * @returns Transaction details
 */
export async function sendTransaction(txUnsigned, {
  onNode,
  onAccount,
  verify = true,
  waitMined = true,
  confirm,
  innerTx,
  ...options
}) {
  const tx = await onAccount.signTransaction(txUnsigned, {
    ...options,
    onNode,
    innerTx,
    networkId: await onNode.getNetworkId()
  });
  if (innerTx === true) return {
    hash: buildTxHash(tx),
    rawTx: tx
  };
  if (verify) {
    const validation = await verifyTransaction(tx, onNode);
    if (validation.length > 0) {
      const message = `Transaction verification errors: ${validation.map(v => v.message).join(', ')}`;
      throw new InvalidTxError(message, validation, tx);
    }
  }
  try {
    let __queue;
    try {
      __queue = onAccount != null ? `tx-${onAccount.address}` : null;
    } catch (error) {
      __queue = null;
    }
    const {
      txHash
    } = await onNode.postTransaction({
      tx
    }, {
      requestOptions: {
        customHeaders: {
          // TODO: remove __retry-code after fixing https://github.com/aeternity/aeternity/issues/3803
          '__retry-code': '400',
          ...(__queue != null ? {
            __queue
          } : {})
        }
      }
    });
    if (waitMined) {
      const pollResult = await poll(txHash, {
        onNode,
        ...options
      });
      const txData = {
        ...pollResult,
        hash: pollResult.hash,
        rawTx: tx
      };
      // wait for transaction confirmation
      if (confirm != null && +confirm > 0) {
        const c = typeof confirm === 'boolean' ? undefined : confirm;
        return {
          ...txData,
          confirmationHeight: await waitForTxConfirm(txHash, {
            onNode,
            confirm: c,
            ...options
          })
        };
      }
      return txData;
    }
    return {
      hash: txHash,
      rawTx: tx
    };
  } catch (error) {
    ensureError(error);
    throw Object.assign(error, {
      rawTx: tx,
      verifyTx: async () => verifyTransaction(tx, onNode)
    });
  }
}
//# sourceMappingURL=send-transaction.js.map