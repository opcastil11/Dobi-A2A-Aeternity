import BigNumber from 'bignumber.js';
import type Channel from './Base.js';
import { Encoded } from '../utils/encoder.js';
import { BaseError } from '../utils/errors.js';
export interface ChannelEvents {
    statusChanged: (status: ChannelStatus) => void;
    stateChanged: (tx: Encoded.Transaction | '') => void;
    depositLocked: () => void;
    ownDepositLocked: () => void;
    withdrawLocked: () => void;
    ownWithdrawLocked: () => void;
    peerDisconnected: () => void;
    channelReestablished: () => void;
    error: (error: Error) => void;
    onChainTx: (tx: Encoded.Transaction, details: {
        info: string;
        type: string;
    }) => void;
    message: (message: string | Object) => void;
    newContract: (contractAddress: Encoded.ContractAddress) => void;
}
export interface ChannelAction {
    guard: (channel: Channel, state?: ChannelFsm) => boolean;
    action: (channel: Channel, state?: ChannelFsm) => ChannelFsm;
}
interface SignOptions {
    updates?: any[];
    [k: string]: any;
}
export type SignTxWithTag = (tag: string, tx: Encoded.Transaction, options?: SignOptions) => Promise<Encoded.Transaction>;
export type SignTx = (tx: Encoded.Transaction, options?: SignOptions) => Promise<Encoded.Transaction | number | null>;
/**
 * @see {@link https://github.com/aeternity/protocol/blob/6734de2e4c7cce7e5e626caa8305fb535785131d/node/api/channels_api_usage.md#channel-establishing-parameters}
 */
interface CommonChannelOptions {
    /**
     * Channel url (for example: "ws://localhost:3001")
     */
    url: string;
    /**
     * Initiator's public key
     */
    initiatorId: Encoded.AccountAddress;
    /**
     * Responder's public key
     */
    responderId: Encoded.AccountAddress;
    /**
     * Amount of blocks for disputing a solo close
     */
    lockPeriod: number;
    /**
     * Initial deposit in favour of the responder by the initiator
     */
    pushAmount: BigNumber | number;
    /**
     * Amount of coins the initiator has committed to the channel
     */
    initiatorAmount: BigNumber | number;
    /**
     * Amount of coins the responder has committed to the channel
     */
    responderAmount: BigNumber | number;
    /**
     * The minimum amount both peers need to maintain
     */
    channelReserve?: BigNumber | number;
    /**
     * Minimum block height to include the channel_create_tx
     */
    ttl?: number;
    /**
     * The port of the responder's node
     */
    port: number;
    /**
     * How to calculate minimum depth (default: txfee)
     */
    minimumDepthStrategy?: 'txfee' | 'plain';
    /**
     * The minimum amount of blocks to be mined
     */
    minimumDepth?: number;
    /**
     * The fee to be used for the channel open transaction
     */
    fee?: BigNumber | number;
    /**
     * Used for the fee computation of the channel open transaction
     */
    gasPrice?: BigNumber | number;
    signedTx?: Encoded.Transaction;
    /**
     * Existing channel id (required if reestablishing a channel)
     */
    existingChannelId?: Encoded.Channel;
    /**
     * Existing FSM id (required if reestablishing a channel)
     */
    existingFsmId?: Encoded.Bytearray;
    /**
     * Needs to be provided if reconnecting with calling `leave` before
     */
    reestablish?: boolean;
    /**
     * The time waiting for a new event to be initiated (default: 600000)
     */
    timeoutIdle?: number;
    /**
     * The time waiting for the initiator to produce the create channel transaction after the noise
     * session had been established (default: 120000)
     */
    timeoutFundingCreate?: number;
    /**
     * The time frame the other client has to sign an off-chain update after our client had initiated
     * and signed it. This applies only for double signed on-chain intended updates: channel create
     * transaction, deposit, withdrawal and etc. (default: 120000)
     */
    timeoutFundingSign?: number;
    /**
     * The time frame the other client has to confirm an on-chain transaction reaching maturity
     * (passing minimum depth) after the local node has detected this. This applies only for double
     * signed on-chain intended updates: channel create transaction, deposit, withdrawal and etc.
     * (default: 360000)
     */
    timeoutFundingLock?: number;
    /**
     * The time frame the client has to return a signed off-chain update or to decline it.
     * This applies for all off-chain updates (default: 500000)
     */
    timeoutSign?: number;
    /**
     * The time frame the other client has to react to an event. This applies for all off-chain
     * updates that are not meant to land on-chain, as well as some special cases: opening a noise
     * connection, mutual closing acknowledgement and reestablishing an existing channel
     * (default: 120000)
     */
    timeoutAccept?: number;
    /**
     * the time frame the responder has to accept an incoming noise session.
     * Applicable only for initiator (default: timeout_accept's value)
     */
    timeoutInitialized?: number;
    /**
     * The time frame the initiator has to start an outgoing noise session to the responder's node.
     * Applicable only for responder (default: timeout_idle's value)
     */
    timeoutAwaitingOpen?: number;
    /**
     * Log websocket communication and state changes
     */
    debug?: boolean;
    /**
     * Function which verifies and signs transactions
     */
    sign: SignTxWithTag;
}
export type ChannelOptions = CommonChannelOptions & ({
    /**
     * Participant role
     */
    role: 'initiator';
    /**
     * Host of the responder's node
     */
    host: string;
} | {
    /**
     * Participant role
     */
    role: 'responder';
});
export interface ChannelHandler extends Function {
    enter?: Function;
}
export interface ChannelState {
    signedTx: Encoded.Transaction;
    resolve: (r?: any) => void;
    reject: (e: BaseError) => void;
    sign: SignTx;
    handler?: ChannelHandler;
    /**
     * Called when transaction has been posted on chain
     */
    onOnChainTx?: (tx: Encoded.Transaction) => void;
    onOwnWithdrawLocked?: () => void;
    onWithdrawLocked?: () => void;
    onOwnDepositLocked?: () => void;
    onDepositLocked?: () => void;
    closeTx?: string;
}
export interface ChannelFsm {
    handler: ChannelHandler;
    state?: ChannelState | {
        resolve: Function;
        reject: Function;
    };
}
export interface ChannelMessage {
    id?: number;
    method: string;
    params: any;
    payload?: any;
    data?: any;
    error?: ChannelMessageError;
}
interface ChannelMessageError {
    code: number;
    message: string;
    data: [
        {
            message: string;
            code: number;
        }
    ];
    request: ChannelMessage;
}
export declare function emit<E extends keyof ChannelEvents>(channel: Channel, ...args: [E, ...Parameters<ChannelEvents[E]>]): void;
export type ChannelStatus = 'connecting' | 'connected' | 'accepted' | 'halfSigned' | 'signed' | 'open' | 'closing' | 'closed' | 'died' | 'disconnected';
export declare function changeStatus(channel: Channel, newStatus: ChannelStatus, debug?: unknown): void;
export declare function changeState(channel: Channel, newState: Encoded.Transaction | ''): void;
export declare function notify(channel: Channel, method: string, params?: object): void;
export declare function enqueueAction(channel: Channel, guard: ChannelAction['guard'], action: () => {
    handler: ChannelHandler;
    state?: Partial<ChannelState>;
}): Promise<any>;
export declare function disconnect(channel: Channel): void;
export declare function call(channel: Channel, method: string, params: any): Promise<any>;
export declare function initialize(channel: Channel, connectionHandler: Function, openHandler: Function, { url, ...channelOptions }: ChannelOptions): Promise<void>;
export {};
