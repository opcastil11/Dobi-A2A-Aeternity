import EventEmitter from 'events';
import { w3cwebsocket as W3CWebSocket } from 'websocket';
import { Tag } from '../tx/builder/constants.js';
import { SignTx, ChannelOptions, ChannelState, ChannelHandler, ChannelAction, ChannelStatus, ChannelFsm, ChannelMessage, ChannelEvents } from './internal.js';
import { Encoded } from '../utils/encoder.js';
import { TxUnpacked } from '../tx/builder/schema.generated.js';
import { EntryTag } from '../tx/builder/entry/constants.js';
import { EntUnpacked } from '../tx/builder/entry/schema.generated.js';
/**
 * Channel
 * @example
 * ```js
 * await Channel.initialize({
 *   url: 'ws://localhost:3001',
 *   role: 'initiator'
 *   initiatorId: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
 *   responderId: 'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',
 *   initiatorAmount: 1e18,
 *   responderAmount: 1e18,
 *   pushAmount: 0,
 *   channelReserve: 0,
 *   ttl: 1000,
 *   host: 'localhost',
 *   port: 3002,
 *   lockPeriod: 10,
 *   async sign (tag, tx) => await account.signTransaction(tx)
 * })
 * ```
 */
export default class Channel {
    #private;
    _eventEmitter: EventEmitter<[never]>;
    _pingTimeoutId: NodeJS.Timeout;
    _nextRpcMessageId: number;
    _rpcCallbacks: Map<number, (message: object) => void>;
    _fsmId?: Encoded.Bytearray;
    _messageQueue: ChannelMessage[];
    _isMessageQueueLocked: boolean;
    _actionQueue: ChannelAction[];
    _isActionQueueLocked: boolean;
    _status: ChannelStatus;
    _fsm: ChannelFsm;
    _websocket: W3CWebSocket;
    _state: Encoded.Transaction | '';
    _options: ChannelOptions;
    _channelId?: Encoded.Channel;
    protected constructor();
    _debug(...args: any[]): void;
    /**
     * @param options - Channel params
     */
    static initialize(options: ChannelOptions): Promise<Channel>;
    static _initialize<T extends Channel>(channel: T, options: ChannelOptions): Promise<T>;
    /**
     * Register event listener function
     *
     * Possible events:
     *
     *   - "error"
     *   - "stateChanged"
     *   - "statusChanged"
     *   - "message"
     *   - "peerDisconnected"
     *   - "onChainTx"
     *   - "ownWithdrawLocked"
     *   - "withdrawLocked"
     *   - "ownDepositLocked"
     *   - "depositLocked"
     *   - "channelReestablished"
     *   - "newContract"
     *
     *
     * @param eventName - Event name
     * @param callback - Callback function
     */
    on<E extends keyof ChannelEvents>(eventName: E, callback: ChannelEvents[E]): void;
    /**
     * Remove event listener function
     * @param eventName - Event name
     * @param callback - Callback function
     */
    off<E extends keyof ChannelEvents>(eventName: E, callback: ChannelEvents[E]): void;
    /**
     * Close the connection
     */
    disconnect(): void;
    /**
     * Get current status
     */
    status(): ChannelStatus;
    /**
     * Get current state
     */
    state(): Promise<{
        calls: EntUnpacked & {
            tag: EntryTag.CallsMtree;
        };
        halfSignedTx?: TxUnpacked & {
            tag: Tag.SignedTx;
        };
        signedTx?: TxUnpacked & {
            tag: Tag.SignedTx;
        };
        trees: EntUnpacked & {
            tag: EntryTag.StateTrees;
        };
    }>;
    /**
     * Get current round
     *
     * If round cannot be determined (for example when channel has not been opened)
     * it will return `null`.
     */
    round(): number | null;
    /**
     * Get channel id
     *
     */
    id(): Encoded.Channel;
    /**
     * Get channel's fsm id
     *
     */
    fsmId(): Encoded.Bytearray;
    protected enqueueAction(action: () => {
        handler: ChannelHandler;
        state?: Partial<ChannelState>;
    }): Promise<any>;
    /**
     * Leave channel
     *
     * It is possible to leave a channel and then later reestablish the channel
     * off-chain state and continue operation. When a leave method is called,
     * the channel fsm passes it on to the peer fsm, reports the current mutually
     * signed state and then terminates.
     *
     * The channel can be reestablished by instantiating another Channel instance
     * with two extra params: existingChannelId and existingFsmId.
     *
     * @example
     * ```js
     * channel.leave().then(({ channelId, signedTx }) => {
     *   console.log(channelId)
     *   console.log(signedTx)
     * })
     * ```
     */
    leave(): Promise<{
        channelId: Encoded.Channel;
        signedTx: Encoded.Transaction;
    }>;
    /**
     * Trigger mutual close
     *
     * At any moment after the channel is opened, a closing procedure can be triggered.
     * This can be done by either of the parties. The process is similar to the off-chain updates.
     *
     * @param sign - Function which verifies and signs mutual close transaction
     * @example
     * ```js
     * channel.shutdown(
     *   async (tx) => await account.signTransaction(tx)
     * ).then(tx => console.log('on_chain_tx', tx))
     * ```
     */
    shutdown(sign: SignTx): Promise<Encoded.Transaction>;
}
