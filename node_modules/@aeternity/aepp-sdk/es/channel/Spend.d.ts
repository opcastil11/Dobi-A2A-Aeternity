import BigNumber from 'bignumber.js';
import { SignTx, ChannelState } from './internal.js';
import { Encoded } from '../utils/encoder.js';
import Channel from './Base.js';
import { EntryTag } from '../tx/builder/entry/constants.js';
import { EntUnpacked } from '../tx/builder/entry/schema.generated.js';
export default class ChannelSpend extends Channel {
    /**
     * Trigger a transfer update
     *
     * The transfer update is moving coins from one channel account to another.
     * The update is a change to be applied on top of the latest state.
     *
     * Sender and receiver are the channel parties. Both the initiator and responder
     * can take those roles. Any public key outside the channel is considered invalid.
     *
     * @param from - Sender's public address
     * @param to - Receiver's public address
     * @param amount - Transaction amount
     * @param sign - Function which verifies and signs offchain transaction
     * @param metadata - Metadata
  
     * @example
     * ```js
     * channel.update(
     *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
     *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',
     *   10,
     *   async (tx) => await account.signTransaction(tx)
     * ).then(({ accepted, signedTx }) =>
     *   if (accepted) {
     *     console.log('Update has been accepted')
     *   }
     * )
     * ```
     */
    update(from: Encoded.AccountAddress, to: Encoded.AccountAddress, amount: number | BigNumber, sign: SignTx, metadata?: string[]): Promise<{
        accepted: boolean;
        signedTx?: Encoded.Transaction;
        errorCode?: number;
        errorMessage?: string;
    }>;
    /**
     * Get proof of inclusion
     *
     * If a certain address of an account or a contract is not found
     * in the state tree - the response is an error.
     *
     * @param addresses - Addresses
     * @param addresses.accounts - List of account addresses to include in poi
     * @param addresses.contracts - List of contract addresses to include in poi
     * @example
     * ```js
     * channel.poi({
     *   accounts: [
     *     'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
     *     'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'
     *   ],
     *   contracts: ['ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA']
     * }).then(poi => console.log(poi))
     * ```
     */
    poi({ accounts, contracts, }: {
        accounts: Encoded.AccountAddress[];
        contracts?: Encoded.ContractAddress[];
    }): Promise<EntUnpacked & {
        tag: EntryTag.TreesPoi;
    }>;
    /**
     * Get balances
     *
     * The accounts param contains a list of addresses to fetch balances of.
     * Those can be either account balances or a contract ones, encoded as an account addresses.
     *
     * If a certain account address had not being found in the state tree - it is simply
     * skipped in the response.
     *
     * @param accounts - List of addresses to fetch balances from
     * @example
     * ```js
     * channel.balances([
     *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
     *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'
     *   'ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA'
     * ]).then(balances =>
     *   console.log(balances['ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'])
     * )
     * ```
     */
    balances(accounts: Encoded.AccountAddress[]): Promise<{
        [key: Encoded.AccountAddress]: string;
    }>;
    private awaitingActionTx;
    /**
     * Withdraw coins from the channel
     *
     * After the channel had been opened any of the participants can initiate a withdrawal.
     * The process closely resembles the update. The most notable difference is that the
     * transaction has been co-signed: it is channel_withdraw_tx and after the procedure
     * is finished - it is being posted on-chain.
     *
     * Any of the participants can initiate a withdrawal. The only requirements are:
     *
     *   - Channel is already opened
     *   - No off-chain update/deposit/withdrawal is currently being performed
     *   - Channel is not being closed or in a solo closing state
     *   - The withdrawal amount must be equal to or greater than zero, and cannot exceed
     *     the available balance on the channel (minus the channel_reserve)
     *
     * After the other party had signed the withdraw transaction, the transaction is posted
     * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.
     * After computing transaction hash it can be tracked on the chain: entering the mempool,
     * block inclusion and a number of confirmations.
     *
     * After the minimum_depth block confirmations onOwnWithdrawLocked callback is called
     * (without any arguments).
     *
     * When the other party had confirmed that the block height needed is reached
     * onWithdrawLocked callback is called (without any arguments).
     *
     * @param amount - Amount of coins to withdraw
     * @param sign - Function which verifies and signs withdraw transaction
     * @param callbacks - Callbacks
     * @example
     * ```js
     * channel.withdraw(
     *   100,
     *   async (tx) => await account.signTransaction(tx),
     *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }
     * ).then(({ accepted, signedTx }) => {
     *   if (accepted) {
     *     console.log('Withdrawal has been accepted')
     *   } else {
     *     console.log('Withdrawal has been rejected')
     *   }
     * })
     * ```
     */
    withdraw(amount: number | BigNumber, sign: SignTx, { onOnChainTx, onOwnWithdrawLocked, onWithdrawLocked, }?: Pick<ChannelState, 'onOnChainTx' | 'onOwnWithdrawLocked' | 'onWithdrawLocked'>): Promise<{
        accepted: boolean;
        signedTx: Encoded.Transaction;
    }>;
    /**
     * Deposit coins into the channel
     *
     * After the channel had been opened any of the participants can initiate a deposit.
     * The process closely resembles the update. The most notable difference is that the
     * transaction has been co-signed: it is channel_deposit_tx and after the procedure
     * is finished - it is being posted on-chain.
     *
     * Any of the participants can initiate a deposit. The only requirements are:
     *
     *   - Channel is already opened
     *   - No off-chain update/deposit/withdrawal is currently being performed
     *   - Channel is not being closed or in a solo closing state
     *   - The deposit amount must be equal to or greater than zero, and cannot exceed
     *     the available balance on the channel (minus the channel_reserve)
     *
     * After the other party had signed the deposit transaction, the transaction is posted
     * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.
     * After computing transaction hash it can be tracked on the chain: entering the mempool,
     * block inclusion and a number of confirmations.
     *
     * After the minimum_depth block confirmations onOwnDepositLocked callback is called
     * (without any arguments).
     *
     * When the other party had confirmed that the block height needed is reached
     * onDepositLocked callback is called (without any arguments).
     *
     * @param amount - Amount of coins to deposit
     * @param sign - Function which verifies and signs deposit transaction
     * @param callbacks - Callbacks
     * @example
     * ```js
     * channel.deposit(
     *   100,
     *   async (tx) => await account.signTransaction(tx),
     *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }
     * ).then(({ accepted, state }) => {
     *   if (accepted) {
     *     console.log('Deposit has been accepted')
     *     console.log('The new state is:', state)
     *   } else {
     *     console.log('Deposit has been rejected')
     *   }
     * })
     * ```
     */
    deposit(amount: number | BigNumber, sign: SignTx, { onOnChainTx, onOwnDepositLocked, onDepositLocked, }?: Pick<ChannelState, 'onOnChainTx' | 'onOwnDepositLocked' | 'onDepositLocked'>): Promise<{
        accepted: boolean;
        state: ChannelState;
    }>;
    /**
     * Send generic message
     *
     * If message is an object it will be serialized into JSON string
     * before sending.
     *
     * If there is ongoing update that has not yet been finished the message
     * will be sent after that update is finalized.
     *
     * @param message - Message
     * @param recipient - Address of the recipient
     * @example
     * ```js
     * channel.sendMessage(
     *   'hello world',
     *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'
     * )
     * ```
     */
    sendMessage(message: string | object, recipient: Encoded.AccountAddress): Promise<void>;
}
