function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import { RpcError, RpcInternalError, RpcMethodNotFoundError } from '../schema.js';
import { InvalidRpcMessageError, MissingCallbackError } from '../../utils/errors.js';
import { ensureError } from '../../utils/other.js';
var _callbacks = /*#__PURE__*/new WeakMap();
var _messageId = /*#__PURE__*/new WeakMap();
var _methods = /*#__PURE__*/new WeakMap();
var _RpcClient_brand = /*#__PURE__*/new WeakSet();
/**
 * Contain functionality for using RPC conection
 * @category aepp wallet communication
 * @param connection - Connection object
 * @param onDisconnect - Disconnect callback
 * @param methods - Object containing handlers for each request by name
 */
export default class RpcClient {
  constructor(connection, onDisconnect, methods) {
    _classPrivateMethodInitSpec(this, _RpcClient_brand);
    _classPrivateFieldInitSpec(this, _callbacks, new Map());
    _classPrivateFieldInitSpec(this, _messageId, 0);
    _classPrivateFieldInitSpec(this, _methods, void 0);
    this.connection = connection;
    _classPrivateFieldSet(_methods, this, methods);
    connection.connect(_assertClassBrand(_RpcClient_brand, this, _handleMessage).bind(this), onDisconnect);
  }
  /**
   * Make a request
   * @param name - Method name
   * @param params - Method params
   * @returns Promise which will be resolved after receiving response message
   */
  async request(name, params) {
    _assertClassBrand(_RpcClient_brand, this, _sendRequest).call(this, _classPrivateFieldSet(_messageId, this, _classPrivateFieldGet(_messageId, this) + 1), name, params);
    return new Promise((resolve, reject) => {
      _classPrivateFieldGet(_callbacks, this).set(_classPrivateFieldGet(_messageId, this), {
        resolve,
        reject
      });
    });
  }

  /**
   * Make a notification
   * @param name - Method name
   * @param params - Method params
   */
  notify(name, params) {
    _assertClassBrand(_RpcClient_brand, this, _sendRequest).call(this, undefined, name, params);
  }

  /**
   * Process response message
   * @param msg - Message object
   */
}
async function _handleMessage(msg, origin) {
  if (msg?.jsonrpc !== '2.0') throw new InvalidRpcMessageError(JSON.stringify(msg));
  if ('result' in msg || 'error' in msg) {
    _assertClassBrand(_RpcClient_brand, this, _processResponse).call(this, msg);
    return;
  }
  const request = msg;
  let result;
  let error;
  try {
    if (!(request.method in _classPrivateFieldGet(_methods, this))) throw new RpcMethodNotFoundError();
    const methodName = request.method;
    result = await _classPrivateFieldGet(_methods, this)[methodName](request.params, origin);
  } catch (e) {
    ensureError(e);
    error = e;
  }
  if (request.id != null) {
    _assertClassBrand(_RpcClient_brand, this, _sendResponse).call(this, request.id, request.method, result, error == null || error instanceof RpcError ? error : new RpcInternalError());
  }
  if (error != null && !(error instanceof RpcError)) throw error;
}
function _sendRequest(id, method, params) {
  this.connection.sendMessage({
    jsonrpc: '2.0',
    ...(id != null ? {
      id
    } : {}),
    method,
    ...(params != null ? {
      params
    } : {})
  });
}
function _sendResponse(id, method,
// TODO: remove as far it is not required in JSON RPC
result, error) {
  this.connection.sendMessage({
    jsonrpc: '2.0',
    id,
    method,
    ...(error != null ? {
      error: error.toJSON()
    } : {
      result
    })
  });
}
function _processResponse({
  id,
  error,
  result
}) {
  const callbacks = _classPrivateFieldGet(_callbacks, this).get(id);
  if (callbacks == null) throw new MissingCallbackError(id);
  if (error != null) callbacks.reject(RpcError.deserialize(error));else callbacks.resolve(result);
  _classPrivateFieldGet(_callbacks, this).delete(id);
}
//# sourceMappingURL=RpcClient.js.map