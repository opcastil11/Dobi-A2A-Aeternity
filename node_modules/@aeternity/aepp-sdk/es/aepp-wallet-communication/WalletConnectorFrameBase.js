function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import { EventEmitter } from 'eventemitter3';
import AccountRpc from '../account/Rpc.js';
import { RPC_VERSION } from './rpc/types.js';
import RpcClient from './rpc/RpcClient.js';
import { METHODS } from './schema.js';
import { NoWalletConnectedError } from '../utils/errors.js';
var _rpcClient = /*#__PURE__*/new WeakMap();
var _WalletConnectorFrameBase_brand = /*#__PURE__*/new WeakSet();
var _accounts = /*#__PURE__*/new WeakMap();
export default class WalletConnectorFrameBase extends EventEmitter {
  /**
   * Is connected to wallet
   */
  get isConnected() {
    return _classPrivateFieldGet(_rpcClient, this) != null;
  }
  /**
   * Accounts provided by wallet over subscription
   */
  get accounts() {
    return _classPrivateFieldGet(_accounts, this);
  }
  constructor() {
    super();
    _classPrivateMethodInitSpec(this, _WalletConnectorFrameBase_brand);
    _classPrivateFieldInitSpec(this, _rpcClient, void 0);
    _classPrivateFieldInitSpec(this, _accounts, []);
  }
  static async _connect(name, connection, connector, connectNode) {
    let disconnectParams;
    const client = new RpcClient(connection, () => {
      _classPrivateFieldSet(_rpcClient, connector, undefined);
      _classPrivateFieldSet(_accounts, connector, []);
      connector.emit('disconnect', disconnectParams);
    }, {
      [METHODS.updateAddress]: _assertClassBrand(_WalletConnectorFrameBase_brand, connector, _updateAccounts).bind(connector),
      [METHODS.updateNetwork]: connector._updateNetwork.bind(connector),
      [METHODS.closeConnection]: params => {
        disconnectParams = params;
        client.connection.disconnect();
      },
      [METHODS.readyToConnect]: () => {}
    });
    _classPrivateFieldSet(_rpcClient, connector, client);
    const walletInfo = await _classPrivateFieldGet(_rpcClient, connector).request(METHODS.connect, {
      name,
      version: RPC_VERSION,
      connectNode
    });
    connector._updateNetwork(walletInfo);
  }

  /**
   * Disconnect from wallet
   */
  disconnect() {
    const client = _assertClassBrand(_WalletConnectorFrameBase_brand, this, _getRpcClient).call(this);
    client.notify(METHODS.closeConnection, {
      reason: 'bye'
    });
    client.connection.disconnect();
  }

  /**
   * Request accounts from wallet
   */
  async getAccounts() {
    const client = _assertClassBrand(_WalletConnectorFrameBase_brand, this, _getRpcClient).call(this);
    const addresses = await client.request(METHODS.address, undefined);
    return addresses.map(address => new AccountRpc(client, address));
  }

  /**
   * Subscribe for wallet accounts, get account updates adding handler to `accountsChange` event
   * @param type - Subscription type
   * @param value - Should be one of 'current' (the selected account), 'connected' (all)
   * @returns Accounts from wallet
   */
  async subscribeAccounts(type, value) {
    const result = await _assertClassBrand(_WalletConnectorFrameBase_brand, this, _getRpcClient).call(this).request(METHODS.subscribeAddress, {
      type,
      value
    });
    _assertClassBrand(_WalletConnectorFrameBase_brand, this, _updateAccounts).call(this, result.address);
    return _classPrivateFieldGet(_accounts, this);
  }

  /**
   * Ask wallet to select a network
   */
  async askToSelectNetwork(network) {
    await _assertClassBrand(_WalletConnectorFrameBase_brand, this, _getRpcClient).call(this).request(METHODS.updateNetwork, network);
  }
}
function _getRpcClient() {
  if (_classPrivateFieldGet(_rpcClient, this) == null) throw new NoWalletConnectedError('You are not connected to Wallet');
  return _classPrivateFieldGet(_rpcClient, this);
}
function _updateAccounts(params) {
  const addresses = [...new Set([...Object.keys(params.current), ...Object.keys(params.connected)])];
  _classPrivateFieldSet(_accounts, this, addresses.map(address => new AccountRpc(_assertClassBrand(_WalletConnectorFrameBase_brand, this, _getRpcClient).call(this), address)));
  this.emit('accountsChange', _classPrivateFieldGet(_accounts, this));
}
//# sourceMappingURL=WalletConnectorFrameBase.js.map