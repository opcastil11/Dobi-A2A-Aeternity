function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import BrowserConnection from './Browser.js';
import { MESSAGE_DIRECTION } from '../schema.js';
import { InternalError, RpcConnectionError } from '../../utils/errors.js';
var _onDisconnect = /*#__PURE__*/new WeakMap();
var _target = /*#__PURE__*/new WeakMap();
var _self = /*#__PURE__*/new WeakMap();
/**
 * Browser window Post Message connector module
 * @category aepp wallet communication
 */
export default class BrowserWindowMessageConnection extends BrowserConnection {
  /**
   * @param options - Options
   * @param options.target Target window for message
   * @param options.self Host window for message
   * @param options.origin Origin of receiver
   * @param options.sendDirection Wrapping messages into additional struct
   * `({ type: 'to_aepp' || 'to_waellet', data })`
   * Used for handling messages between content script and page
   * @param options.receiveDirection Unwrapping messages from additional struct
   */
  constructor({
    target,
    self = window,
    origin,
    sendDirection,
    receiveDirection = MESSAGE_DIRECTION.to_aepp,
    ...options
  } = {}) {
    super(options);
    _classPrivateFieldInitSpec(this, _onDisconnect, void 0);
    _classPrivateFieldInitSpec(this, _target, void 0);
    _classPrivateFieldInitSpec(this, _self, void 0);
    _classPrivateFieldSet(_target, this, target);
    _classPrivateFieldSet(_self, this, self);
    this.origin = origin;
    this.sendDirection = sendDirection;
    this.receiveDirection = receiveDirection;
  }
  isConnected() {
    return this.listener != null;
  }
  connect(onMessage, onDisconnect) {
    super.connect(onMessage, onDisconnect);
    this.listener = message => {
      var _message$data$jsonrpc;
      // TODO: strict validate origin and source instead of checking message structure
      if (typeof message.data !== 'object' || ((_message$data$jsonrpc = message.data.jsonrpc) !== null && _message$data$jsonrpc !== void 0 ? _message$data$jsonrpc : message.data.data?.jsonrpc) !== '2.0') return;
      if (this.origin != null && this.origin !== message.origin) return;
      if (_classPrivateFieldGet(_target, this) != null && _classPrivateFieldGet(_target, this) !== message.source) return;
      this.receiveMessage(message);
      let {
        data
      } = message;
      if (data.type != null) {
        if (message.data.type !== this.receiveDirection) return;
        data = data.data;
      }
      onMessage(data, message.origin, message.source);
    };
    _classPrivateFieldGet(_self, this).addEventListener('message', this.listener);
    _classPrivateFieldSet(_onDisconnect, this, onDisconnect);
  }
  disconnect() {
    super.disconnect();
    if (this.listener == null || _classPrivateFieldGet(_onDisconnect, this) == null) {
      throw new InternalError('Expected to not happen, required for TS');
    }
    _classPrivateFieldGet(_self, this).removeEventListener('message', this.listener);
    delete this.listener;
    _classPrivateFieldGet(_onDisconnect, this).call(this);
    _classPrivateFieldSet(_onDisconnect, this, undefined);
  }
  sendMessage(msg) {
    var _this$origin;
    if (_classPrivateFieldGet(_target, this) == null) throw new RpcConnectionError("Can't send messages without target");
    const message = this.sendDirection != null ? {
      type: this.sendDirection,
      data: msg
    } : msg;
    super.sendMessage(message);
    _classPrivateFieldGet(_target, this).postMessage(message, (_this$origin = this.origin) !== null && _this$origin !== void 0 ? _this$origin : '*');
  }
}
//# sourceMappingURL=BrowserWindowMessage.js.map