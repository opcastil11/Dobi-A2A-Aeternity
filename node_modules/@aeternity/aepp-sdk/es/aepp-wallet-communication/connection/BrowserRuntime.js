function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import BrowserConnection from './Browser.js';
import { UnexpectedTsError } from '../../utils/errors.js';

/**
 * BrowserRuntimeConnection
 * Handle browser runtime communication
 * @category aepp wallet communication
 */
var _listeners = /*#__PURE__*/new WeakMap();
export default class BrowserRuntimeConnection extends BrowserConnection {
  /**
   * @param options - Options
   */
  constructor({
    port,
    ...options
  }) {
    super(options);
    _classPrivateFieldInitSpec(this, _listeners, void 0);
    this.port = port;
  }
  disconnect() {
    super.disconnect();
    this.port.disconnect();
    if (_classPrivateFieldGet(_listeners, this) == null) throw new UnexpectedTsError();
    this.port.onMessage.removeListener(_classPrivateFieldGet(_listeners, this)[0]);
    this.port.onDisconnect.removeListener(_classPrivateFieldGet(_listeners, this)[1]);
    _classPrivateFieldSet(_listeners, this, undefined);
  }
  connect(onMessage, onDisconnect) {
    super.connect(onMessage, onDisconnect);
    _classPrivateFieldSet(_listeners, this, [(message, port) => {
      var _port$sender$url;
      this.receiveMessage(message);
      // TODO: make `origin` optional because sender url is not available on aepp side
      onMessage(message, (_port$sender$url = port.sender?.url) !== null && _port$sender$url !== void 0 ? _port$sender$url : '', port);
    }, onDisconnect]);
    this.port.onMessage.addListener(_classPrivateFieldGet(_listeners, this)[0]);
    this.port.onDisconnect.addListener(_classPrivateFieldGet(_listeners, this)[1]);
  }
  sendMessage(message) {
    super.sendMessage(message);
    this.port.postMessage(message);
  }
  isConnected() {
    return _classPrivateFieldGet(_listeners, this) != null;
  }
}
//# sourceMappingURL=BrowserRuntime.js.map