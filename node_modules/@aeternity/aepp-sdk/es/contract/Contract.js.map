{"version":3,"file":"Contract.js","names":["Encoder","Calldata","Tag","DRY_RUN_ACCOUNT","buildContractIdByContractTx","unpackTx","buildTxAsync","buildTxHash","decode","MissingContractDefError","MissingContractAddressError","InactiveContractError","BytecodeMismatchError","DuplicateContractError","MissingFunctionNameError","InvalidMethodInvocationError","NotPayableFunctionError","TypeError","NodeInvocationError","IllegalArgumentError","NoSuchContractFunctionError","MissingEventDefinitionError","AmbiguousEventDefinitionError","UnexpectedTsError","InternalError","NoWalletConnectedError","ContractError","hash","calcHash","getAccount","resolveName","txDryRun","sendTransaction","isAccountNotFoundError","isName","produceNameId","_Contract_brand","WeakSet","_aciContract","WeakMap","Contract","$compile","$options","bytecode","onCompiler","sourceCode","compileBySourceCode","fileSystem","sourceCodePath","compile","$getCallResultByTxHash","fnName","options","callInfo","onNode","getTransactionInfoByHash","callInfoTyped","_assertClassBrand","_getCallResult","call","undefined","result","_estimateGas","name","params","$call","callStatic","gasUsed","Math","floor","$deploy","_opt$gasLimit","opt","address","onAccount","ownerId","tx","_isInternalBuild","tag","ContractCreateTx","gasLimit","callData","_calldata","encode","_name","code","other","_sendAndProcess","rawTx","log","decodedEvents","$decodeEvents","owner","transaction","fn","_opt$gasLimit2","top","fnAci","_getFunctionAci","contractId","amount","Number","payable","callerId","error","useFallbackAccount","message","pub","nonce","topOption","account","catch","kind","txOpt","ContractCallTx","callObj","dryRunOther","txData","events","omitUnknown","map","event","contractName","_getContractNameByEvent","topics","decoded","decodeEvent","data","args","Object","entries","contract","filter","e","initialize","aci","validateBytecode","otherOptions","res","resolveByNode","getContract","active","onChanBytecode","getContractCode","isValid","validateBySourceCode","validate","ContractWithMethods","constructor","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_aci","aciLast","length","keys","_classPrivateFieldSet","_classPrivateFieldGet","assign","fromEntries","functions","arguments","aciArgs","stateful","pop","_Contract","returnType","returnValue","decodedResult","decodeFateString","toString","test","blockHeight","find","f","returns","ctAddress","nameHash","contractAddressToName","addressToName","isEqual","a","b","JSON","stringify","contracts","matchedEvents","variant","values","flat","eventName","BigInt","type","idx","arr","slice","some","el"],"sources":["../../src/contract/Contract.ts"],"sourcesContent":["/**\n * Contract module - routines to interact with the Ã¦ternity contract\n *\n * High level documentation of the contracts are available at\n * https://github.com/aeternity/protocol/tree/master/contracts and\n */\n\nimport { Encoder as Calldata } from '@aeternity/aepp-calldata';\nimport { Tag, AensName, DRY_RUN_ACCOUNT } from '../tx/builder/constants.js';\nimport {\n  buildContractIdByContractTx,\n  unpackTx,\n  buildTxAsync,\n  BuildTxOptions,\n  buildTxHash,\n} from '../tx/builder/index.js';\nimport { decode, Encoded } from '../utils/encoder.js';\nimport {\n  MissingContractDefError,\n  MissingContractAddressError,\n  InactiveContractError,\n  BytecodeMismatchError,\n  DuplicateContractError,\n  MissingFunctionNameError,\n  InvalidMethodInvocationError,\n  NotPayableFunctionError,\n  TypeError,\n  NodeInvocationError,\n  IllegalArgumentError,\n  NoSuchContractFunctionError,\n  MissingEventDefinitionError,\n  AmbiguousEventDefinitionError,\n  UnexpectedTsError,\n  InternalError,\n  NoWalletConnectedError,\n  ContractError,\n} from '../utils/errors.js';\nimport { hash as calcHash } from '../utils/crypto.js';\nimport {\n  ContractCallObject as NodeContractCallObject,\n  Event as NodeEvent,\n} from '../apis/node/index.js';\nimport CompilerBase, { Aci } from './compiler/Base.js';\nimport Node from '../Node.js';\nimport { getAccount, resolveName, txDryRun } from '../chain.js';\nimport { sendTransaction, SendTransactionOptions } from '../send-transaction.js';\nimport { TxUnpacked } from '../tx/builder/schema.generated.js';\nimport { Optional, isAccountNotFoundError } from '../utils/other.js';\nimport { isName, produceNameId } from '../tx/builder/helpers.js';\n\ntype ContractAci = NonNullable<Aci[0]['contract']>;\ntype FunctionAci = ContractAci['functions'][0];\n\ninterface Event extends NodeEvent {\n  address: Encoded.ContractAddress;\n  data: Encoded.ContractBytearray;\n}\n\nexport interface ContractCallObject extends NodeContractCallObject {\n  returnValue: Encoded.ContractBytearray;\n  log: Event[];\n}\n\ninterface DecodedEvent {\n  name: string;\n  args: unknown[];\n  contract: {\n    name: string;\n    address: Encoded.ContractAddress;\n  };\n}\n\ntype TxData = Awaited<ReturnType<typeof sendTransaction>>;\n\ninterface SendAndProcessReturnType {\n  result?: ContractCallObject;\n  hash: TxData['hash'];\n  tx: TxUnpacked & { tag: Tag.SignedTx | Tag.ContractCallTx | Tag.ContractCreateTx };\n  txData: TxData;\n  rawTx: Encoded.Transaction;\n}\n\n/**\n * @category contract\n */\nexport interface ContractMethodsBase {\n  [key: string]: (...args: any[]) => any;\n}\n\ntype MethodsToContractApi<M extends ContractMethodsBase> = {\n  [Name in keyof M]: M[Name] extends (...args: infer Args) => infer Ret\n    ? (\n        ...args: [\n          ...Args,\n          ...(\n            | []\n            | [\n                Name extends 'init'\n                  ? Parameters<Contract<M>['$deploy']>[1]\n                  : Parameters<Contract<M>['$call']>[2],\n              ]\n          ),\n        ]\n      ) => Promise<\n        Omit<Awaited<ReturnType<Contract<M>['$call']>>, 'decodedResult'> & {\n          // TODO: accurate would be to add `| undefined` because of `waitMined`, but better to drop `waitMined`\n          decodedResult: Ret;\n        }\n      >\n    : never;\n};\n\n/**\n * @category contract\n */\ntype ContractWithMethods<M extends ContractMethodsBase> = Contract<M> & MethodsToContractApi<M>;\n\ntype MethodNames<M extends ContractMethodsBase> = (keyof M & string) | 'init';\n\ntype MethodParameters<M extends ContractMethodsBase, Fn extends MethodNames<M>> = Fn extends 'init'\n  ? M extends { init: any }\n    ? Parameters<M['init']>\n    : []\n  : Parameters<M[Fn]>;\n\ninterface GetContractNameByEventOptions {\n  contractAddressToName?: { [key: Encoded.ContractAddress]: string };\n}\n\ninterface GetCallResultByHashReturnType<M extends ContractMethodsBase, Fn extends MethodNames<M>> {\n  decodedResult: ReturnType<M[Fn]>;\n  decodedEvents?: ReturnType<Contract<M>['$decodeEvents']>;\n}\n\n/**\n * Generate contract ACI object with predefined js methods for contract usage - can be used for\n * creating a reference to already deployed contracts\n * @category contract\n * @param options - Options object\n * @returns JS Contract API\n * @example\n * ```js\n * const contractIns = await Contract.initialize({ ...aeSdk.getContext(), sourceCode })\n * await contractIns.$deploy([321]) or await contractIns.init(321)\n * const callResult = await contractIns.$call('setState', [123])\n * const staticCallResult = await contractIns.$call('setState', [123], { callStatic: true })\n * ```\n * Also you can call contract like: `await contractIns.setState(123, options)`\n * Then sdk decide to make on-chain or static call (dry-run API) transaction based on function is\n * stateful or not\n */\nclass Contract<M extends ContractMethodsBase> {\n  /**\n   * Compile contract\n   * @returns bytecode\n   */\n  async $compile(): Promise<Encoded.ContractBytearray> {\n    if (this.$options.bytecode != null) return this.$options.bytecode;\n    if (this.$options.onCompiler == null)\n      throw new IllegalArgumentError(\"Can't compile without compiler\");\n    if (this.$options.sourceCode != null) {\n      const { bytecode } = await this.$options.onCompiler.compileBySourceCode(\n        this.$options.sourceCode,\n        this.$options.fileSystem,\n      );\n      this.$options.bytecode = bytecode;\n    }\n    if (this.$options.sourceCodePath != null) {\n      const { bytecode } = await this.$options.onCompiler.compile(this.$options.sourceCodePath);\n      this.$options.bytecode = bytecode;\n    }\n    if (this.$options.bytecode == null) {\n      throw new IllegalArgumentError(\"Can't compile without sourceCode and sourceCodePath\");\n    }\n    return this.$options.bytecode;\n  }\n\n  #getCallResult<Fn extends MethodNames<M>>(\n    { returnType, returnValue, log }: ContractCallObject,\n    fnName: Fn,\n    transaction: Encoded.Transaction | undefined,\n    options: Parameters<Contract<M>['$decodeEvents']>[1],\n  ): GetCallResultByHashReturnType<M, Fn> {\n    let message: string;\n    switch (returnType) {\n      case 'ok': {\n        const fnAci = this.#getFunctionAci(fnName);\n        return {\n          decodedResult: this._calldata.decode(this._name, fnAci.name, returnValue),\n          decodedEvents: this.$decodeEvents(log, options),\n        };\n      }\n      case 'revert':\n        message = this._calldata.decodeFateString(returnValue);\n        break;\n      case 'error':\n        message = decode(returnValue).toString();\n        if (/Expected \\d+ arguments, got \\d+/.test(message)) {\n          throw new BytecodeMismatchError('ACI', `. Error provided by node: \"${message}\".`);\n        }\n        if (/Trying to call undefined function: <<\\d+,\\d+,\\d+,\\d+>>/.test(message)) {\n          throw new BytecodeMismatchError(\n            'ACI',\n            `. Error provided by node: \"${message}\", function name: ${fnName}.`,\n          );\n        }\n        break;\n      default:\n        throw new InternalError(`Unknown return type: ${returnType}`);\n    }\n    throw new NodeInvocationError(message, transaction);\n  }\n\n  async #sendAndProcess<Fn extends MethodNames<M>>(\n    tx: Encoded.Transaction,\n    fnName: Fn,\n    options: SendTransactionOptions & Parameters<Contract<M>['$getCallResultByTxHash']>[2],\n  ): Promise<SendAndProcessReturnType & Partial<GetCallResultByHashReturnType<M, Fn>>> {\n    const txData = await sendTransaction(tx, { ...this.$options, ...options });\n    return {\n      hash: txData.hash,\n      tx: unpackTx<Tag.ContractCallTx | Tag.ContractCreateTx>(txData.rawTx),\n      txData,\n      rawTx: txData.rawTx,\n      // TODO: disallow `waitMined: false` to make `decodedResult` required\n      ...(txData.blockHeight != null &&\n        (await this.$getCallResultByTxHash(txData.hash, fnName, options))),\n    };\n  }\n\n  async $getCallResultByTxHash<Fn extends MethodNames<M>>(\n    hash: Encoded.TxHash,\n    fnName: Fn,\n    options?: Parameters<Contract<M>['$decodeEvents']>[1],\n  ): Promise<GetCallResultByHashReturnType<M, Fn> & { result: ContractCallObject }> {\n    const { callInfo } = await this.$options.onNode.getTransactionInfoByHash(hash);\n    if (callInfo == null) {\n      throw new ContractError(`callInfo is not available for transaction ${hash}`);\n    }\n    const callInfoTyped = callInfo as ContractCallObject;\n    return {\n      ...this.#getCallResult(callInfoTyped, fnName, undefined, options),\n      result: callInfoTyped,\n    };\n  }\n\n  async _estimateGas<Fn extends MethodNames<M>>(\n    name: Fn,\n    params: MethodParameters<M, Fn>,\n    options: Omit<Parameters<Contract<M>['$call']>[2], 'callStatic'> = {},\n  ): Promise<number> {\n    const { result } = await this.$call(name, params, { ...options, callStatic: true });\n    if (result == null) throw new UnexpectedTsError();\n    const { gasUsed } = result;\n    // taken from https://github.com/aeternity/aepp-sdk-js/issues/1286#issuecomment-977814771\n    return Math.floor(gasUsed * 1.25);\n  }\n\n  /**\n   * Deploy contract\n   * @param params - Contract init function arguments array\n   * @param options - Options\n   * @returns deploy info\n   */\n  async $deploy(\n    params: MethodParameters<M, 'init'>,\n    options?: Parameters<Contract<M>['$call']>[2] &\n      Partial<BuildTxOptions<Tag.ContractCreateTx, 'ownerId' | 'code' | 'callData'>>,\n  ): Promise<\n    Omit<SendAndProcessReturnType, 'hash'> & {\n      transaction?: Encoded.TxHash;\n      owner?: Encoded.AccountAddress;\n      address?: Encoded.ContractAddress;\n      decodedEvents?: ReturnType<Contract<M>['$decodeEvents']>;\n    }\n  > {\n    const { callStatic, ...opt } = { ...this.$options, ...options };\n    if (this.$options.bytecode == null) await this.$compile();\n    if (callStatic === true) return this.$call('init', params, { ...opt, callStatic });\n    if (this.$options.address != null) throw new DuplicateContractError();\n\n    if (opt.onAccount == null) throw new IllegalArgumentError(\"Can't deploy without account\");\n    const ownerId = opt.onAccount.address;\n    if (this.$options.bytecode == null)\n      throw new IllegalArgumentError(\"Can't deploy without bytecode\");\n    const tx = await buildTxAsync({\n      _isInternalBuild: true,\n      ...opt,\n      tag: Tag.ContractCreateTx,\n      gasLimit: opt.gasLimit ?? (await this._estimateGas('init', params, opt)),\n      callData: this._calldata.encode(this._name, 'init', params),\n      code: this.$options.bytecode,\n      ownerId,\n    });\n    const { hash, ...other } = await this.#sendAndProcess(tx, 'init', {\n      ...opt,\n      onAccount: opt.onAccount,\n    });\n    this.$options.address = buildContractIdByContractTx(other.rawTx);\n    return {\n      ...other,\n      ...(other.result?.log != null && {\n        decodedEvents: this.$decodeEvents(other.result.log, opt),\n      }),\n      owner: ownerId,\n      transaction: hash,\n      address: this.$options.address,\n    };\n  }\n\n  /**\n   * Get function schema from contract ACI object\n   * @param name - Function name\n   * @returns function ACI\n   */\n  #getFunctionAci(name: string): FunctionAci {\n    const fn = this.#aciContract.functions.find((f: { name: string }) => f.name === name);\n    if (fn != null) {\n      return fn;\n    }\n    if (name === 'init') {\n      return {\n        arguments: [],\n        name: 'init',\n        payable: false,\n        returns: 'unit',\n        stateful: true,\n      };\n    }\n    throw new NoSuchContractFunctionError(name);\n  }\n\n  /**\n   * Call contract function\n   * @param fn - Function name\n   * @param params - Array of function arguments\n   * @param options - Array of function arguments\n   * @returns CallResult\n   */\n  async $call<Fn extends MethodNames<M>>(\n    fn: Fn,\n    params: MethodParameters<M, Fn>,\n    options: Partial<BuildTxOptions<Tag.ContractCallTx, 'callerId' | 'contractId' | 'callData'>> &\n      Parameters<Contract<M>['$decodeEvents']>[1] &\n      Optional<SendTransactionOptions, 'onAccount' | 'onNode'> &\n      Omit<Parameters<typeof txDryRun>[2], 'onNode'> & { callStatic?: boolean } = {},\n  ): Promise<SendAndProcessReturnType & Partial<GetCallResultByHashReturnType<M, Fn>>> {\n    const { callStatic, top, ...opt } = { ...this.$options, ...options };\n    const fnAci = this.#getFunctionAci(fn);\n    const { address, name } = this.$options;\n    // TODO: call `produceNameId` on buildTx side\n    const contractId = name != null ? produceNameId(name) : address;\n    const { onNode } = opt;\n\n    if (fn == null) throw new MissingFunctionNameError();\n    if (fn === 'init' && callStatic !== true)\n      throw new InvalidMethodInvocationError('\"init\" can be called only via dryRun');\n    if (fn !== 'init' && opt.amount != null && Number(opt.amount) > 0 && !fnAci.payable) {\n      throw new NotPayableFunctionError(opt.amount, fn);\n    }\n\n    let callerId;\n    try {\n      if (opt.onAccount == null) throw new InternalError('Use fallback account');\n      callerId = opt.onAccount.address;\n    } catch (error) {\n      const useFallbackAccount =\n        callStatic === true &&\n        ((error instanceof TypeError &&\n          error.message ===\n            'Account should be an address (ak-prefixed string), or instance of AccountBase, got undefined instead') ||\n          error instanceof NoWalletConnectedError ||\n          (error instanceof InternalError && error.message === 'Use fallback account'));\n      if (!useFallbackAccount) throw error;\n      callerId = DRY_RUN_ACCOUNT.pub;\n    }\n    const callData = this._calldata.encode(this._name, fn, params);\n\n    if (callStatic === true) {\n      if (opt.nonce == null) {\n        const topOption = top != null && { [typeof top === 'number' ? 'height' : 'hash']: top };\n        const account = await getAccount(callerId, { ...topOption, onNode }).catch((error) => {\n          if (!isAccountNotFoundError(error)) throw error;\n          return { kind: 'basic', nonce: 0 };\n        });\n        opt.nonce = account.kind === 'generalized' ? 0 : account.nonce + 1;\n      }\n\n      const txOpt = { ...opt, onNode, callData };\n      let tx;\n      if (fn === 'init') {\n        if (this.$options.bytecode == null)\n          throw new IllegalArgumentError('Can\\'t dry-run \"init\" without bytecode');\n        tx = await buildTxAsync({\n          ...txOpt,\n          tag: Tag.ContractCreateTx,\n          code: this.$options.bytecode,\n          ownerId: callerId,\n        });\n      } else {\n        if (contractId == null)\n          throw new MissingContractAddressError(\"Can't dry-run contract without address\");\n        tx = await buildTxAsync({\n          ...txOpt,\n          tag: Tag.ContractCallTx,\n          callerId,\n          contractId,\n        });\n      }\n\n      const { callObj, ...dryRunOther } = await txDryRun(tx, callerId, { ...opt, top });\n      if (callObj == null) {\n        throw new InternalError(`callObj is not available for transaction ${tx}`);\n      }\n      const callInfoTyped = callObj as ContractCallObject;\n      return {\n        ...dryRunOther,\n        ...this.#getCallResult(callInfoTyped, fn, tx, opt),\n        tx: unpackTx(tx),\n        result: callInfoTyped,\n        rawTx: tx,\n        hash: buildTxHash(tx),\n        txData: undefined as any,\n      };\n    }\n\n    if (top != null)\n      throw new IllegalArgumentError(\"Can't handle `top` option in on-chain contract call\");\n    if (contractId == null)\n      throw new MissingContractAddressError(\"Can't call contract without address\");\n    const tx = await buildTxAsync({\n      _isInternalBuild: true,\n      ...opt,\n      tag: Tag.ContractCallTx,\n      gasLimit: opt.gasLimit ?? (await this._estimateGas(fn, params, opt)),\n      callerId,\n      contractId,\n      callData,\n    });\n    if (opt.onAccount == null)\n      throw new IllegalArgumentError(\"Can't call contract on chain without account\");\n    return this.#sendAndProcess(tx, fn, { ...opt, onAccount: opt.onAccount });\n  }\n\n  /**\n   * @param ctAddress - Contract address that emitted event\n   * @param nameHash - Hash of emitted event name\n   * @param options - Options\n   * @returns Contract name\n   * @throws {@link MissingEventDefinitionError}\n   * @throws {@link AmbiguousEventDefinitionError}\n   */\n  #getContractNameByEvent(\n    ctAddress: Encoded.ContractAddress,\n    nameHash: BigInt,\n    { contractAddressToName }: GetContractNameByEventOptions,\n  ): string {\n    const addressToName = { ...this.$options.contractAddressToName, ...contractAddressToName };\n    if (addressToName[ctAddress] != null) return addressToName[ctAddress];\n\n    // TODO: consider using a third-party library\n    const isEqual = (a: any, b: any): boolean => JSON.stringify(a) === JSON.stringify(b);\n\n    const contracts = this._aci\n      .map(({ contract }) => contract)\n      .filter((contract) => contract?.event) as ContractAci[];\n    const matchedEvents = contracts\n      .map((contract) => [contract.name, contract.event.variant])\n      .map(([name, events]) =>\n        events.map((event: {}) => [name, Object.keys(event)[0], Object.values(event)[0]]),\n      )\n      .flat()\n      .filter(([, eventName]) => BigInt(`0x${calcHash(eventName).toString('hex')}`) === nameHash)\n      .filter(([, , type], idx, arr) => !arr.slice(0, idx).some((el) => isEqual(el[2], type)));\n    switch (matchedEvents.length) {\n      case 0:\n        throw new MissingEventDefinitionError(nameHash.toString(), ctAddress);\n      case 1:\n        return matchedEvents[0][0];\n      default:\n        throw new AmbiguousEventDefinitionError(ctAddress, matchedEvents);\n    }\n  }\n\n  /**\n   * Decode Events\n   * @param events - Array of encoded events (callRes.result.log)\n   * @param options - Options\n   * @returns DecodedEvents\n   */\n  $decodeEvents(\n    events: Event[],\n    { omitUnknown, ...opt }: { omitUnknown?: boolean } & GetContractNameByEventOptions = {},\n  ): DecodedEvent[] {\n    return events\n      .map((event) => {\n        let contractName;\n        try {\n          contractName = this.#getContractNameByEvent(event.address, event.topics[0], opt);\n        } catch (error) {\n          if ((omitUnknown ?? false) && error instanceof MissingEventDefinitionError) return null;\n          throw error;\n        }\n        const decoded = this._calldata.decodeEvent(contractName, event.data, event.topics);\n        const [name, args] = Object.entries(decoded)[0];\n        return {\n          name,\n          args,\n          contract: {\n            name: contractName,\n            address: event.address,\n          },\n        };\n      })\n      .filter((e: DecodedEvent | null): e is DecodedEvent => e != null);\n  }\n\n  static async initialize<M extends ContractMethodsBase>({\n    onCompiler,\n    onNode,\n    bytecode,\n    aci,\n    address,\n    sourceCodePath,\n    sourceCode,\n    fileSystem,\n    validateBytecode,\n    ...otherOptions\n  }: Omit<ConstructorParameters<typeof Contract>[0], 'aci' | 'address'> & {\n    validateBytecode?: boolean;\n    aci?: Aci;\n    address?: Encoded.ContractAddress | AensName;\n  }): Promise<ContractWithMethods<M>> {\n    if (aci == null && onCompiler != null) {\n      let res;\n      if (sourceCodePath != null) res = await onCompiler.compile(sourceCodePath);\n      if (sourceCode != null) res = await onCompiler.compileBySourceCode(sourceCode, fileSystem);\n      if (res != null) {\n        aci = res.aci;\n        bytecode ??= res.bytecode;\n      }\n    }\n    if (aci == null) throw new MissingContractDefError();\n\n    let name;\n    if (address != null) {\n      address = (await resolveName(address, 'contract_pubkey', {\n        resolveByNode: true,\n        onNode,\n      })) as Encoded.ContractAddress;\n      if (isName(address)) name = address;\n    }\n\n    if (address == null && sourceCode == null && sourceCodePath == null && bytecode == null) {\n      throw new MissingContractAddressError(\"Can't create instance by ACI without address\");\n    }\n\n    if (address != null) {\n      const contract = await onNode.getContract(address);\n      if (contract.active == null) throw new InactiveContractError(address);\n    }\n\n    if (validateBytecode === true) {\n      if (address == null)\n        throw new MissingContractAddressError(\"Can't validate bytecode without contract address\");\n      const onChanBytecode = (await onNode.getContractCode(address)).bytecode;\n      let isValid = false;\n      if (bytecode != null) isValid = bytecode === onChanBytecode;\n      else if (sourceCode != null) {\n        if (onCompiler == null)\n          throw new IllegalArgumentError(\"Can't validate bytecode without compiler\");\n        isValid = await onCompiler.validateBySourceCode(onChanBytecode, sourceCode, fileSystem);\n      } else if (sourceCodePath != null) {\n        if (onCompiler == null)\n          throw new IllegalArgumentError(\"Can't validate bytecode without compiler\");\n        isValid = await onCompiler.validate(onChanBytecode, sourceCodePath);\n      }\n      if (!isValid) {\n        throw new BytecodeMismatchError(\n          (sourceCode ?? sourceCodePath) != null ? 'source code' : 'bytecode',\n        );\n      }\n    }\n\n    return new ContractWithMethods<M>({\n      onCompiler,\n      onNode,\n      sourceCode,\n      sourceCodePath,\n      bytecode,\n      aci,\n      address,\n      name,\n      fileSystem,\n      ...otherOptions,\n    });\n  }\n\n  _aci: Aci;\n\n  readonly #aciContract: ContractAci;\n\n  _name: string;\n\n  _calldata: Calldata;\n\n  $options: Omit<ConstructorParameters<typeof Contract>[0], 'aci'>;\n\n  /**\n   * @param options - Options\n   */\n  constructor({\n    aci,\n    ...otherOptions\n  }: {\n    onCompiler?: CompilerBase;\n    onNode: Node;\n    bytecode?: Encoded.ContractBytearray;\n    aci: Aci;\n    address?: Encoded.ContractAddress;\n    /**\n     * Supported only in Ceres\n     */\n    name?: AensName;\n    sourceCodePath?: Parameters<CompilerBase['compile']>[0];\n    sourceCode?: Parameters<CompilerBase['compileBySourceCode']>[0];\n    fileSystem?: Parameters<CompilerBase['compileBySourceCode']>[1];\n  } & Parameters<Contract<M>['$deploy']>[1]) {\n    this._aci = aci;\n    const aciLast = aci[aci.length - 1];\n    if (aciLast.contract == null) {\n      throw new IllegalArgumentError(\n        `The last 'aci' item should have 'contract' key, got ${Object.keys(aciLast)} keys instead`,\n      );\n    }\n    this.#aciContract = aciLast.contract;\n    this._name = this.#aciContract.name;\n    this._calldata = new Calldata(aci);\n    this.$options = otherOptions;\n\n    /**\n     * Generate proto function based on contract function using Contract ACI schema\n     * All function can be called like:\n     * ```js\n     * await contract.testFunction()\n     * ```\n     * then sdk will decide to use dry-run or send tx\n     * on-chain base on if function stateful or not.\n     * Also, you can manually do that:\n     * ```js\n     * await contract.testFunction({ callStatic: true }) // use call-static (dry-run)\n     * await contract.testFunction({ callStatic: false }) // send tx on-chain\n     * ```\n     */\n    Object.assign(\n      this,\n      Object.fromEntries(\n        this.#aciContract.functions.map(({ name, arguments: aciArgs, stateful }: FunctionAci) => {\n          const callStatic = name !== 'init' && !stateful;\n          return [\n            name,\n            async (...args: any) => {\n              const options = args.length === aciArgs.length + 1 ? args.pop() : {};\n              if (typeof options !== 'object')\n                throw new TypeError(`Options should be an object: ${options}`);\n              if (name === 'init') return this.$deploy(args, { callStatic, ...options });\n              return this.$call(name, args, { callStatic, ...options });\n            },\n          ];\n        }),\n      ),\n    );\n  }\n}\n\ninterface ContractWithMethodsClass {\n  new <M extends ContractMethodsBase>(\n    options: ConstructorParameters<typeof Contract>[0],\n  ): ContractWithMethods<M>;\n  initialize: (typeof Contract)['initialize'];\n}\n\n/**\n * @category contract\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nconst ContractWithMethods: ContractWithMethodsClass = Contract as any;\n\nexport default ContractWithMethods;\n"],"mappings":"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","ignoreList":[]}