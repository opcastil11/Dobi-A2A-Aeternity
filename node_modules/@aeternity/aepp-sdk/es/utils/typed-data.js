import { TypeResolver, ContractByteArrayEncoder } from '@aeternity/aepp-calldata';
import canonicalize from 'canonicalize';
import { decode } from './encoder.js';
import { hash, messagePrefixLength } from './crypto.js';
import { concatBuffers } from './other.js';

/**
 * Hashes arbitrary object, can be used to inline the aci hash to contract source code
 * @category typed data signing
 */
export function hashJson(data) {
  var _canonicalize;
  return hash((_canonicalize = canonicalize(data)) !== null && _canonicalize !== void 0 ? _canonicalize : '');
}

// TODO: move this type to calldata library https://github.com/aeternity/aepp-calldata-js/issues/215
// based on https://github.com/aeternity/aepp-calldata-js/blob/82b5a98f9b308482627da8d7484d213e9cf87151/src/AciTypeResolver.js#L129

/**
 * Hashes domain object, can be used to inline domain hash to contract source code
 * @category typed data signing
 */
export function hashDomain(domain) {
  const domainAci = {
    record: [{
      name: 'name',
      type: {
        option: ['string']
      }
    }, {
      name: 'version',
      type: {
        option: ['int']
      }
    }, {
      name: 'networkId',
      type: {
        option: ['string']
      }
    }, {
      name: 'contractAddress',
      type: {
        option: ['contract_pubkey']
      }
    }]
  };
  const domainType = new TypeResolver().resolveType(domainAci, {});
  const fateValue = new ContractByteArrayEncoder().encodeWithType(domain, domainType);
  return hash(decode(fateValue));
}

/**
 * @category typed data signing
 */
export function hashTypedData(data, aci, domain) {
  return hash(concatBuffers([messagePrefixLength, new Uint8Array([0]), hashDomain(domain), hashJson(aci), hash(decode(data))]));
}
//# sourceMappingURL=typed-data.js.map