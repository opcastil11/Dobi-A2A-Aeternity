import { Encoded } from './encoder.js';
/**
 * Hashes arbitrary object, can be used to inline the aci hash to contract source code
 * @category typed data signing
 */
export declare function hashJson(data: unknown): Buffer;
export type AciValue = 'void' | 'unit' | 'int' | 'bool' | 'string' | 'bits' | 'hash' | 'signature' | 'address' | 'contract_pubkey' | 'Chain.ttl' | 'Chain.ga_meta_tx' | 'Chain.paying_for_tx' | 'Chain.base_tx' | 'AENS.pointee' | 'AENS.name' | 'MCL_BLS12_381.fr' | 'MCL_BLS12_381.fp' | {
    'Set.set': readonly [AciValue];
} | {
    bytes: number;
} | {
    list: readonly [AciValue];
} | {
    map: readonly [AciValue, AciValue];
} | {
    tuple: readonly AciValue[];
} | {
    record: ReadonlyArray<{
        name: string;
        type: AciValue;
    }>;
} | {
    variant: ReadonlyArray<{
        [key: string]: readonly AciValue[];
    }>;
} | {
    option: readonly [AciValue];
} | {
    oracle: readonly [AciValue, AciValue];
} | {
    oracle_query: readonly [AciValue, AciValue];
};
export interface Domain {
    name?: string;
    version?: number;
    networkId?: string;
    contractAddress?: Encoded.ContractAddress;
}
/**
 * Hashes domain object, can be used to inline domain hash to contract source code
 * @category typed data signing
 */
export declare function hashDomain(domain: Domain): Buffer;
/**
 * @category typed data signing
 */
export declare function hashTypedData(data: Encoded.ContractBytearray, aci: AciValue, domain: Domain): Buffer;
