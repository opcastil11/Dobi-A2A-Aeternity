{"version":3,"file":"jwt.js","names":["canonicalize","Encoding","decode","encode","verifySignature","ArgumentError","InvalidSignatureError","toBase64Url","data","_Buffer","from","toString","replaceAll","replace","fromBase64Url","objectToBase64Url","_canonicalize","header","signJwt","originalPayload","account","payload","sub_jwk","kty","crv","x","address","undefined","body","signature","unsafeSign","unpackJwt","jwt","_payload$sub_jwk","components","split","length","h","payloadEncoded","JSON","parse","jwk","signer","AccountAddress","isJwt","maybeJwt","error","ensureJwt","verifyJwt"],"sources":["../../src/utils/jwt.ts"],"sourcesContent":["import canonicalize from 'canonicalize';\nimport AccountBase from '../account/Base.js';\nimport { Encoded, Encoding, decode, encode } from './encoder.js';\nimport { verifySignature } from './crypto.js';\nimport { ArgumentError, InvalidSignatureError } from './errors.js';\n\n// TODO: use Buffer.from(data, 'base64url') after solving https://github.com/feross/buffer/issues/309\nconst toBase64Url = (data: Buffer | Uint8Array | string): string =>\n  Buffer.from(data).toString('base64').replaceAll('/', '_').replaceAll('+', '-').replace(/=+$/, '');\n\nconst fromBase64Url = (data: string): Buffer =>\n  Buffer.from(data.replaceAll('_', '/').replaceAll('-', '+'), 'base64');\n\nconst objectToBase64Url = (data: any): string => toBase64Url(canonicalize(data) ?? '');\n\nconst header = 'eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9'; // objectToBase64Url({ alg: 'EdDSA', typ: 'JWT' })\n\n/**\n * JWT including specific header\n * @category JWT\n */\nexport type Jwt = `${typeof header}.${string}.${string}`;\n\n/**\n * Generate a signed JWT\n * Provide `\"sub_jwk\": undefined` in payload to omit signer public key added by default.\n * @param originalPayload - Payload to sign\n * @param account - Account to sign by\n * @category JWT\n */\nexport async function signJwt(originalPayload: any, account: AccountBase): Promise<Jwt> {\n  const payload = { ...originalPayload };\n  if (!('sub_jwk' in payload)) {\n    payload.sub_jwk = {\n      kty: 'OKP',\n      crv: 'Ed25519',\n      x: toBase64Url(decode(account.address)),\n    };\n  }\n  if (payload.sub_jwk === undefined) delete payload.sub_jwk;\n  const body = `${header}.${objectToBase64Url(payload)}` as const;\n  const signature = await account.unsafeSign(body);\n  return `${body}.${toBase64Url(signature)}`;\n}\n\n/**\n * Unpack JWT. It will check signature if address or \"sub_jwk\" provided.\n * @param jwt - JWT to unpack\n * @param address - Address to check signature\n * @category JWT\n */\nexport function unpackJwt(\n  jwt: Jwt,\n  address?: Encoded.AccountAddress,\n): {\n  /**\n   * JWT payload as object\n   */\n  payload: any;\n  /**\n   * Undefined returned in case signature is not checked\n   */\n  signer: Encoded.AccountAddress | undefined;\n} {\n  const components = jwt.split('.');\n  if (components.length !== 3)\n    throw new ArgumentError('JWT components count', 3, components.length);\n  const [h, payloadEncoded, signature] = components;\n  if (h !== header) throw new ArgumentError('JWT header', header, h);\n  const payload = JSON.parse(fromBase64Url(payloadEncoded).toString());\n  const jwk = payload.sub_jwk ?? {};\n  const signer =\n    jwk.x == null || jwk.kty !== 'OKP' || jwk.crv !== 'Ed25519'\n      ? address\n      : encode(fromBase64Url(jwk.x), Encoding.AccountAddress);\n  if (address != null && signer !== address) {\n    throw new ArgumentError('address', `${signer} (\"sub_jwk\")`, address);\n  }\n  if (\n    signer != null &&\n    !verifySignature(Buffer.from(`${h}.${payloadEncoded}`), fromBase64Url(signature), signer)\n  ) {\n    throw new InvalidSignatureError(`JWT is not signed by ${signer}`);\n  }\n  return { payload, signer };\n}\n\n/**\n * Check is string a JWT or not. Use to validate the user input.\n * @param maybeJwt - A string to check\n * @returns True if argument is a JWT\n * @category JWT\n */\nexport function isJwt(maybeJwt: string): maybeJwt is Jwt {\n  try {\n    unpackJwt(maybeJwt as Jwt);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Throws an error if argument is not JWT. Use to ensure that a value is JWT.\n * @param maybeJwt - A string to check\n * @category JWT\n */\nexport function ensureJwt(maybeJwt: string): asserts maybeJwt is Jwt {\n  unpackJwt(maybeJwt as Jwt);\n}\n\n/**\n * Check is JWT signed by address from arguments or \"sub_jwk\"\n * @param jwt - JWT to check\n * @param address - Address to check signature\n * @category JWT\n */\nexport function verifyJwt(jwt: Jwt, address?: Encoded.AccountAddress): boolean {\n  try {\n    const { signer } = unpackJwt(jwt, address);\n    return signer != null;\n  } catch (error) {\n    return false;\n  }\n}\n"],"mappings":"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","ignoreList":[]}