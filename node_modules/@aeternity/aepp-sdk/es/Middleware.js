import { userAgentPolicyName, setClientRequestIdPolicyName } from '@azure/core-rest-pipeline';
import { genRequestQueuesPolicy, genCombineGetRequestsPolicy, genErrorFormatterPolicy, parseBigIntPolicy, genVersionCheckPolicy, genRetryOnFailurePolicy } from './utils/autorest.js';
import { Middleware as MiddlewareApi } from './apis/middleware/index.js';
import { operationSpecs } from './apis/middleware/middleware.js';
import { IllegalArgumentError, InternalError } from './utils/errors.js';
import { MiddlewarePage, isMiddlewareRawPage } from './utils/MiddlewarePage.js';

/**
 * @category middleware
 */
export default class Middleware extends MiddlewareApi {
  /**
   * @param url - Url for middleware API
   * @param options - Options
   * @param options.ignoreVersion - Print warning instead of throwing exception if middleware
   * is not supported, use with caution
   * @param options.retryCount - Amount of extra requests to do in case of failure
   * @param options.retryOverallDelay - Time in ms to wait between all retries
   */
  constructor(url, {
    ignoreVersion = false,
    retryCount = 3,
    retryOverallDelay = 800,
    ...options
  } = {}) {
    let version;
    const getVersion = async opts => {
      if (version != null) return version;
      version = (await this.getStatus(opts)).mdwVersion;
      return version;
    };

    // eslint-disable-next-line constructor-super
    super(url, {
      allowInsecureConnection: true,
      additionalPolicies: [genVersionCheckPolicy('middleware', getVersion, '1.81.0', '2.0.0', ignoreVersion), genRequestQueuesPolicy(), genCombineGetRequestsPolicy(), genRetryOnFailurePolicy(retryCount, retryOverallDelay), genErrorFormatterPolicy(body => ` ${body.error}`)],
      ...options
    });
    this.pipeline.addPolicy(parseBigIntPolicy, {
      phase: 'Deserialize'
    });
    this.pipeline.removePolicy({
      name: userAgentPolicyName
    });
    this.pipeline.removePolicy({
      name: setClientRequestIdPolicyName
    });
    // TODO: use instead our retry policy
    this.pipeline.removePolicy({
      name: 'defaultRetryPolicy'
    });
  }

  /**
   * Get a middleware response by path instead of a method name and arguments.
   * @param pathWithQuery - a path to request starting with `/v3/`
   */
  async requestByPath(pathWithQuery) {
    const queryPos = pathWithQuery.indexOf('?');
    const path = pathWithQuery.slice(0, queryPos === -1 ? pathWithQuery.length : queryPos);
    const query = pathWithQuery.slice(queryPos === -1 ? pathWithQuery.length : queryPos + 1);
    const operationSpec = operationSpecs.find(os => {
      let p = path;
      if (os.path == null) return false;
      const groups = os.path.replace(/{\w+}/g, '{param}').split('{param}');
      while (groups.length > 0) {
        const part = groups.shift();
        if (part == null) throw new InternalError(`Unexpected operation spec path: ${os.path}`);
        if (!p.startsWith(part)) return false;
        p = p.replace(part, '');
        if (groups.length > 0) p = p.replace(/^[\w.]+/, '');
      }
      return p === '';
    });
    if (operationSpec == null) {
      throw new IllegalArgumentError(`Can't find operation spec corresponding to ${path}`);
    }
    return this.sendOperationRequest({}, {
      ...operationSpec,
      path,
      urlParameters: operationSpec.urlParameters?.filter(({
        parameterPath
      }) => parameterPath === '$host'),
      queryParameters: Array.from(new URLSearchParams(query)).map(([key, value]) => ({
        parameterPath: ['options', key],
        mapper: {
          defaultValue: value.toString(),
          serializedName: key,
          type: {
            name: 'String'
          }
        }
      }))
    });
  }
  async sendOperationRequest(operationArguments, operationSpec) {
    const response = await super.sendOperationRequest(operationArguments, operationSpec);
    if (!isMiddlewareRawPage(response)) return response;
    return new MiddlewarePage(response, this);
  }
}
//# sourceMappingURL=Middleware.js.map