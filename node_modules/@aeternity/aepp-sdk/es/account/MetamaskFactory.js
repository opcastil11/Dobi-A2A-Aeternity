function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import { InternalError, UnsupportedPlatformError, UnsupportedVersionError } from '../utils/errors.js';
import semverSatisfies from '../utils/semver-satisfies.js';
import AccountBaseFactory from './BaseFactory.js';
import AccountMetamask, { invokeSnap, snapId } from './Metamask.js';
const snapMinVersion = '0.0.9';
const snapMaxVersion = '0.1.0';
const metamaskVersionPrefix = 'MetaMask/v';
var _provider = /*#__PURE__*/new WeakMap();
var _AccountMetamaskFactory_brand = /*#__PURE__*/new WeakSet();
var _providerPromise = /*#__PURE__*/new WeakMap();
/**
 * A factory class that generates instances of AccountMetamask.
 * @see {@link https://www.npmjs.com/package/@aeternity-snap/plugin | Aeternity snap}
 * @category account
 */
export default class AccountMetamaskFactory extends AccountBaseFactory {
  /**
   * @deprecated this class is not intended to provide raw access to the provider
   */
  get provider() {
    if (_classPrivateFieldGet(_provider, this) == null) throw new UnsupportedPlatformError('Metamask is not detected yet');
    return _classPrivateFieldGet(_provider, this);
  }
  /**
   * @param provider - Connection to MetaMask to use
   */
  constructor(_provider2) {
    super();
    _classPrivateMethodInitSpec(this, _AccountMetamaskFactory_brand);
    // TODO: remove after removing `provider`
    _classPrivateFieldInitSpec(this, _provider, void 0);
    _classPrivateFieldInitSpec(this, _providerPromise, void 0);
    _classPrivateFieldSet(_provider, this, _provider2);
    if (_classPrivateFieldGet(_provider, this) == null && window == null) {
      throw new UnsupportedPlatformError('Window object not found, you can run AccountMetamaskFactory only in browser or setup a provider');
    }
  }

  /**
   * Request MetaMask to install Aeternity snap.
   * @deprecated use `requestSnap` instead
   */
  async installSnap() {
    const provider = await _assertClassBrand(_AccountMetamaskFactory_brand, this, _getProvider).call(this);
    const details = await provider.request({
      method: 'wallet_requestSnaps',
      params: {
        [snapId]: {
          version: snapMinVersion
        }
      }
    });
    return details[snapId];
  }

  /**
   * Request MetaMask to install Aeternity snap or connect it to the current aepp.
   * MetaMask can have only one Aeternity snap version installed at a time.
   * This method is intended to upgrade the snap to a specified version if needed by the aepp.
   * If Aeternity snap is installed but wasn't used by the aepp, then the user still needs to approve the connection.
   * If the currently installed version corresponds to the version range, then the snap won't be upgraded.
   * To downgrade the snap, the user must manually uninstall the current version.
   * @param version - Snap version range (e.g. `1`, `0.1.*`, `^0.0.9`, `~0.0.9`; `>=0.0.9 <0.1.0`)
   * (default: a version range supported by sdk)
   */
  async requestSnap(version = `>=${snapMinVersion} <${snapMaxVersion}`) {
    const provider = await _assertClassBrand(_AccountMetamaskFactory_brand, this, _getProvider).call(this);
    const details = await provider.request({
      method: 'wallet_requestSnaps',
      params: {
        [snapId]: {
          version
        }
      }
    });
    return details[snapId];
  }

  /**
   * It throws an exception if MetaMask or Aeternity snap has an incompatible version or is not
   * installed or is not connected to the aepp.
   * @deprecated use `requestSnap` instead
   */
  async ensureReady() {
    const snapVersion = await this.getSnapVersion();
    const args = [snapVersion, snapMinVersion, snapMaxVersion];
    if (!semverSatisfies(...args)) throw new UnsupportedVersionError('Aeternity snap in MetaMask', ...args);
  }

  /**
   * @returns the version of snap installed in MetaMask
   */
  async getSnapVersion() {
    const provider = await _assertClassBrand(_AccountMetamaskFactory_brand, this, _getProvider).call(this);
    const snaps = await provider.request({
      method: 'wallet_getSnaps'
    });
    const version = snaps[snapId]?.version;
    if (version == null) throw new UnsupportedPlatformError('Aeternity snap is not installed to MetaMask or not connected to this aepp');
    return version;
  }

  /**
   * Get an instance of AccountMetaMask for a given account index.
   * @param accountIndex - Index of account
   */
  async initialize(accountIndex) {
    await this.requestSnap();
    const provider = await _assertClassBrand(_AccountMetamaskFactory_brand, this, _getProvider).call(this);
    const address = await invokeSnap(provider, 'getPublicKey', {
      derivationPath: [`${accountIndex}'`, "0'", "0'"]
    }, 'publicKey');
    return new AccountMetamask(provider, accountIndex, address);
  }
}
async function _getMetamaskAsInjected() {
  if (!('ethereum' in window) || window.ethereum == null) return;
  const provider = window.ethereum;
  const version = await provider.request({
    method: 'web3_clientVersion'
  });
  if (version == null) throw new InternalError("Can't get Ethereum Provider version");
  if (!version.startsWith(metamaskVersionPrefix)) return;
  return provider;
}
async function _getMetamaskOverEip() {
  setTimeout(() => window.dispatchEvent(new Event('eip6963:requestProvider')));
  return new Promise(resolve => {
    const handler = event => {
      if (event.detail.info.rdns !== 'io.metamask') return;
      window.removeEventListener('eip6963:announceProvider', handler);
      resolve(event.detail.provider);
    };
    window.addEventListener('eip6963:announceProvider', handler);
    setTimeout(() => {
      window.removeEventListener('eip6963:announceProvider', handler);
      resolve(undefined);
    }, 500);
  });
}
async function _getProvider() {
  var _classPrivateFieldGet2;
  (_classPrivateFieldGet2 = _classPrivateFieldGet(_providerPromise, this)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : _classPrivateFieldSet(_providerPromise, this, (async (_classPrivateFieldGet3, _await$_assertClassBr) => {
    (_classPrivateFieldGet3 = _classPrivateFieldGet(_provider, this)) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : _classPrivateFieldSet(_provider, this, (_await$_assertClassBr = await _assertClassBrand(_AccountMetamaskFactory_brand, this, _getMetamaskAsInjected).call(this)) !== null && _await$_assertClassBr !== void 0 ? _await$_assertClassBr : await _assertClassBrand(_AccountMetamaskFactory_brand, this, _getMetamaskOverEip).call(this));
    if (_classPrivateFieldGet(_provider, this) == null) {
      throw new UnsupportedPlatformError("Can't find a Metamask extension as an injected provider and over EIP-6963. Ensure that Metamask is installed or setup a provider.");
    }
    const version = await _classPrivateFieldGet(_provider, this).request({
      method: 'web3_clientVersion'
    });
    if (version == null) throw new InternalError("Can't get Ethereum Provider version");
    const args = [version.slice(metamaskVersionPrefix.length), '12.2.4'];
    if (!semverSatisfies(...args)) throw new UnsupportedVersionError('Metamask', ...args);
    return _classPrivateFieldGet(_provider, this);
  })());
  return _classPrivateFieldGet(_providerPromise, this);
}
//# sourceMappingURL=MetamaskFactory.js.map