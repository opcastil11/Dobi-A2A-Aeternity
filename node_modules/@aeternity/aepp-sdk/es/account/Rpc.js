import { Buffer as _Buffer } from "buffer";
import AccountBase from './Base.js';
import { METHODS } from '../aepp-wallet-communication/schema.js';
import { ArgumentError, UnsupportedProtocolError } from '../utils/errors.js';
import { Encoding, decode, encode } from '../utils/encoder.js';
/**
 * Account provided by wallet
 * @param params - Params
 * @param params.rpcClient - RpcClient instance
 * @param params.address - RPC account address
 * @returns AccountRpc instance
 * @category account
 */
export default class AccountRpc extends AccountBase {
  constructor(rpcClient, address) {
    super();
    this._rpcClient = rpcClient;
    this.address = address;
  }

  /**
   * @deprecated Use `unsafeSign` method instead
   */
  async sign(dataRaw) {
    return this.unsafeSign(dataRaw);
  }
  async unsafeSign(dataRaw) {
    const data = encode(_Buffer.from(dataRaw), Encoding.Bytearray);
    const {
      signature
    } = await this._rpcClient.request(METHODS.unsafeSign, {
      onAccount: this.address,
      data
    });
    return decode(signature);
  }
  async signTransaction(tx, {
    innerTx,
    networkId
  } = {}) {
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    const res = await this._rpcClient.request(METHODS.sign, {
      onAccount: this.address,
      tx,
      returnSigned: true,
      networkId,
      innerTx
    });
    if (res.signedTransaction == null) {
      throw new UnsupportedProtocolError('signedTransaction is missed in wallet response');
    }
    return res.signedTransaction;
  }
  async signMessage(message) {
    const {
      signature
    } = await this._rpcClient.request(METHODS.signMessage, {
      onAccount: this.address,
      message
    });
    return _Buffer.from(signature, 'hex');
  }
  async signTypedData(data, aci, {
    name,
    version,
    contractAddress,
    networkId
  } = {}) {
    const {
      signature
    } = await this._rpcClient.request(METHODS.signTypedData, {
      onAccount: this.address,
      domain: {
        name,
        version,
        networkId,
        contractAddress
      },
      aci,
      data
    });
    return signature;
  }
  async signDelegation(delegation) {
    const {
      signature
    } = await this._rpcClient.request(METHODS.signDelegation, {
      delegation,
      onAccount: this.address
    });
    return signature;
  }
}
//# sourceMappingURL=Rpc.js.map