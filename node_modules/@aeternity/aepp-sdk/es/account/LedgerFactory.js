import { Buffer as _Buffer } from "buffer";
import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import AccountLedger, { CLA, GET_ADDRESS, GET_APP_CONFIGURATION } from './Ledger.js';
import { UnsupportedVersionError } from '../utils/errors.js';
import semverSatisfies from '../utils/semver-satisfies.js';
import AccountBaseFactory from './BaseFactory.js';
var _ensureReadyPromise = /*#__PURE__*/new WeakMap();
var _AccountLedgerFactory_brand = /*#__PURE__*/new WeakSet();
/**
 * A factory class that generates instances of AccountLedger based on provided transport.
 * @category account
 */
export default class AccountLedgerFactory extends AccountBaseFactory {
  /**
   * @param transport - Connection to Ledger to use
   */
  constructor(transport) {
    super();
    _classPrivateMethodInitSpec(this, _AccountLedgerFactory_brand);
    _classPrivateFieldInitSpec(this, _ensureReadyPromise, void 0);
    // TODO: remove after release Ledger app v1.0.0
    _defineProperty(this, "_enableExperimentalLedgerAppSupport", false);
    this.transport = transport;
    transport.decorateAppAPIMethods(this, ['getAddress', 'getAppConfiguration'], 'w0w');
  }
  /**
   * It throws an exception if Aeternity app on Ledger has an incompatible version, not opened or
   * not installed.
   */
  async ensureReady() {
    const {
      version
    } = await _assertClassBrand(_AccountLedgerFactory_brand, this, _getAppConfiguration).call(this);
    const oldApp = [version, '0.4.4', '0.5.0'];
    const newApp = [version, '1.0.0', '2.0.0'];
    if (!semverSatisfies(...oldApp) && (!this._enableExperimentalLedgerAppSupport || !semverSatisfies(...newApp))) throw new UnsupportedVersionError('Aeternity app on Ledger', ...oldApp);
    _classPrivateFieldSet(_ensureReadyPromise, this, Promise.resolve());
  }
  /**
   * @returns the version of Aeternity app installed on Ledger wallet
   */
  async getAppConfiguration() {
    return _assertClassBrand(_AccountLedgerFactory_brand, this, _getAppConfiguration).call(this);
  }

  /**
   * Get `ak_`-prefixed address for a given account index.
   * @param accountIndex - Index of account
   * @param verify - Ask user to confirm address by showing it on the device screen
   */
  async getAddress(accountIndex, verify = false) {
    await _assertClassBrand(_AccountLedgerFactory_brand, this, _ensureReady).call(this);
    const buffer = _Buffer.alloc(4);
    buffer.writeUInt32BE(accountIndex, 0);
    const response = await this.transport.send(CLA, GET_ADDRESS, verify ? 0x01 : 0x00, 0x00, buffer);
    const addressLength = response[0];
    return response.subarray(1, 1 + addressLength).toString('ascii');
  }

  /**
   * Get an instance of AccountLedger for a given account index.
   * @param accountIndex - Index of account
   */
  async initialize(accountIndex) {
    return new AccountLedger(this.transport, accountIndex, await this.getAddress(accountIndex));
  }
}
async function _ensureReady() {
  var _classPrivateFieldGet2;
  (_classPrivateFieldGet2 = _classPrivateFieldGet(_ensureReadyPromise, this)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : _classPrivateFieldSet(_ensureReadyPromise, this, this.ensureReady());
  return _classPrivateFieldGet(_ensureReadyPromise, this);
}
async function _getAppConfiguration() {
  let response = await this.transport.send(CLA, GET_APP_CONFIGURATION, 0x00, 0x00);
  if (response.length === 6) response = response.subarray(1);
  return {
    version: [response[0], response[1], response[2]].join('.')
  };
}
//# sourceMappingURL=LedgerFactory.js.map