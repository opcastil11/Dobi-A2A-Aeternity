import { Buffer as _Buffer } from "buffer";
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import { mnemonicToSeed, mnemonicToSeedSync } from '@scure/bip39';
import tweetnaclAuth from 'tweetnacl-auth';
import AccountBaseFactory from './BaseFactory.js';
import AccountMemory from './Memory.js';
import { encode, Encoding, decode } from '../utils/encoder.js';
import { concatBuffers } from '../utils/other.js';
import { ArgumentError } from '../utils/errors.js';
export const ED25519_CURVE = _Buffer.from('ed25519 seed');
const HARDENED_OFFSET = 0x80000000;
export function deriveKey(message, key) {
  const I = tweetnaclAuth.full(message, key);
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    secretKey: IL,
    chainCode: IR
  };
}
export function derivePathFromKey(key, segments) {
  return segments.reduce(({
    secretKey,
    chainCode
  }, segment) => {
    const indexBuffer = _Buffer.allocUnsafe(4);
    indexBuffer.writeUInt32BE(segment + HARDENED_OFFSET, 0);
    const data = concatBuffers([_Buffer.alloc(1, 0), secretKey, indexBuffer]);
    return deriveKey(data, chainCode);
  }, key);
}
var _mnemonicOrWalletOrSeed = /*#__PURE__*/new WeakMap();
var _AccountMnemonicFactory_brand = /*#__PURE__*/new WeakSet();
/**
 * A factory class that generates instances of AccountMemory based on provided mnemonic phrase.
 * @category account
 */
export default class AccountMnemonicFactory extends AccountBaseFactory {
  /**
   * @param mnemonicOrWalletOrSeed - BIP39-compatible mnemonic phrase or a wallet/seed derived from
   * mnemonic
   */
  constructor(mnemonicOrWalletOrSeed) {
    super();
    _classPrivateMethodInitSpec(this, _AccountMnemonicFactory_brand);
    _classPrivateFieldInitSpec(this, _mnemonicOrWalletOrSeed, void 0);
    _classPrivateFieldSet(_mnemonicOrWalletOrSeed, this, mnemonicOrWalletOrSeed);
  }
  /**
   * Get a wallet to initialize AccountMnemonicFactory instead mnemonic phrase.
   * In comparison with mnemonic, the wallet can be used to derive aeternity accounts only.
   */
  async getWallet() {
    return _assertClassBrand(_AccountMnemonicFactory_brand, this, _getWallet).call(this, false);
  }

  /**
   * The same as `getWallet` but synchronous.
   */
  getWalletSync() {
    return _assertClassBrand(_AccountMnemonicFactory_brand, this, _getWallet).call(this, true);
  }
  /**
   * Get an instance of AccountMemory for a given account index.
   * @param accountIndex - Index of account
   */
  async initialize(accountIndex) {
    const wallet = await this.getWallet();
    return _assertClassBrand(_AccountMnemonicFactory_brand, this, _getAccountByWallet).call(this, accountIndex, wallet);
  }

  /**
   * The same as `initialize` but synchronous.
   */
  initializeSync(accountIndex) {
    const wallet = this.getWalletSync();
    return _assertClassBrand(_AccountMnemonicFactory_brand, this, _getAccountByWallet).call(this, accountIndex, wallet);
  }
}
function _getWallet(sync) {
  const setWalletBySeed = seed => {
    const masterKey = deriveKey(seed, ED25519_CURVE);
    const walletKey = derivePathFromKey(masterKey, [44, 457]);
    _classPrivateFieldSet(_mnemonicOrWalletOrSeed, this, {
      secretKey: encode(walletKey.secretKey, Encoding.Bytearray),
      chainCode: encode(walletKey.chainCode, Encoding.Bytearray)
    });
    return _classPrivateFieldGet(_mnemonicOrWalletOrSeed, this);
  };
  if (ArrayBuffer.isView(_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this))) {
    if (_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this).length !== 64) {
      throw new ArgumentError('seed length', 64, _classPrivateFieldGet(_mnemonicOrWalletOrSeed, this).length);
    }
    return setWalletBySeed(_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this));
  }
  if (typeof _classPrivateFieldGet(_mnemonicOrWalletOrSeed, this) === 'object') return _classPrivateFieldGet(_mnemonicOrWalletOrSeed, this);
  return sync ? setWalletBySeed(mnemonicToSeedSync(_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this))) : mnemonicToSeed(_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this)).then(setWalletBySeed);
}
function _getAccountByWallet(accountIndex, wallet) {
  const walletKey = {
    secretKey: decode(wallet.secretKey),
    chainCode: decode(wallet.chainCode)
  };
  const raw = derivePathFromKey(walletKey, [accountIndex, 0, 0]).secretKey;
  return new AccountMemory(encode(raw, Encoding.AccountSecretKey));
}
//# sourceMappingURL=MnemonicFactory.js.map