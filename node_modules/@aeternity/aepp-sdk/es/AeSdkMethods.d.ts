import * as chainMethods from './chain.js';
import { sendTransaction } from './send-transaction.js';
import * as spendMethods from './spend.js';
import * as contractGaMethods from './contract/ga.js';
import { UnionToIntersection } from './utils/other.js';
import Node from './Node.js';
import { TxParamsAsync } from './tx/builder/schema.generated.js';
import AccountBase from './account/Base.js';
import { Encoded } from './utils/encoder.js';
import CompilerBase from './contract/compiler/Base.js';
export type OnAccount = Encoded.AccountAddress | AccountBase | undefined;
declare const methods: {
    readonly createGeneralizedAccount: typeof contractGaMethods.createGeneralizedAccount;
    readonly buildAuthTxHash: typeof contractGaMethods.buildAuthTxHash;
    readonly buildAuthTxHashByGaMetaTx: typeof contractGaMethods.buildAuthTxHashByGaMetaTx;
    readonly spend: typeof spendMethods.spend;
    readonly transferFunds: typeof spendMethods.transferFunds;
    readonly payForTransaction: typeof spendMethods.payForTransaction;
    readonly sendTransaction: typeof sendTransaction;
    readonly _getPollInterval: typeof chainMethods._getPollInterval;
    readonly getHeight: typeof chainMethods.getHeight;
    readonly poll: typeof chainMethods.poll;
    readonly awaitHeight: typeof chainMethods.awaitHeight;
    readonly waitForTxConfirm: typeof chainMethods.waitForTxConfirm;
    readonly getAccount: typeof chainMethods.getAccount;
    readonly getBalance: typeof chainMethods.getBalance;
    readonly getCurrentGeneration: typeof chainMethods.getCurrentGeneration;
    readonly getGeneration: typeof chainMethods.getGeneration;
    readonly getMicroBlockTransactions: typeof chainMethods.getMicroBlockTransactions;
    readonly getKeyBlock: typeof chainMethods.getKeyBlock;
    readonly getMicroBlockHeader: typeof chainMethods.getMicroBlockHeader;
    readonly txDryRun: typeof chainMethods.txDryRun;
    readonly getContractByteCode: typeof chainMethods.getContractByteCode;
    readonly getContract: typeof chainMethods.getContract;
    readonly getName: typeof chainMethods.getName;
    readonly resolveName: typeof chainMethods.resolveName;
};
type Decrement<Number extends number> = [-1, 0, 1, 2, 3, 4, 5][Number];
type GetMethodsOptions<Methods extends {
    [key: string]: Function;
}> = {
    [Name in keyof Methods]: Methods[Name] extends (...args: infer Args) => any ? Args[Decrement<Args['length']>] : never;
};
type MethodsOptions = GetMethodsOptions<typeof methods>;
export interface AeSdkMethodsOptions extends Partial<UnionToIntersection<MethodsOptions[keyof MethodsOptions]>> {
}
export interface WrappedOptions {
    onAccount: AccountBase;
    onCompiler: CompilerBase;
    onNode: Node;
}
/**
 * AeSdkMethods is the composition of:
 * - chain methods
 * - tx methods
 * - aens methods
 * - spend methods
 * - oracle methods
 * - contract methods
 * - contract ga methods
 *
 * While these methods can be used separately, this class provides a handy way to store
 * their context (current account, network, and compiler to use).
 */
declare class AeSdkMethods {
    #private;
    _options: AeSdkMethodsOptions;
    /**
     * @param options - Options
     */
    constructor(options?: AeSdkMethodsOptions);
    /**
     * Returns sdk instance options with references to current account, node, compiler.
     * Used to create an instance (Contract, Oracle) bound to AeSdk state.
     * @param mergeWith - Merge context with these extra options
     * @returns Context object
     */
    getContext(mergeWith?: AeSdkMethodsOptions): AeSdkMethodsOptions & WrappedOptions;
    buildTx(options: TxParamsAsync): Promise<Encoded.Transaction>;
}
type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];
type OptionalIfNotRequired<T extends [any]> = RequiredKeys<T[0]> extends never ? T | [] : T;
type ReplaceOnAccount<Options> = Options extends {
    onAccount: any;
} ? Omit<Options, 'onAccount'> & {
    /**
     * Make operation on specific account by providing address (to use account from sdk) or instance
     * of AccountBase (like AccountMemory)
     */
    onAccount: OnAccount;
} : Options;
type MakeOptional<Options> = OptionalIfNotRequired<[
    Omit<Options, 'onNode' | 'onCompiler' | 'onAccount'> & Partial<ReplaceOnAccount<Options>>
]>;
type TransformMethods<Methods extends {
    [key: string]: Function;
}> = {
    [Name in keyof Methods]: Methods[Name] extends (...args: [...infer Args, infer Options]) => infer Ret ? (...args: [...Args, ...MakeOptional<Options>]) => Ret : never;
};
interface AeSdkMethodsTransformed extends TransformMethods<typeof methods> {
}
type AeSdkMethodsTyped = AeSdkMethods & AeSdkMethodsTransformed;
declare const AeSdkMethodsTyped: new (options?: AeSdkMethodsOptions) => AeSdkMethodsTyped;
export default AeSdkMethodsTyped;
