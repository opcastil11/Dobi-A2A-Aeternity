function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
// eslint-disable-next-line max-classes-per-file

import { userAgentPolicyName, setClientRequestIdPolicyName } from '@azure/core-rest-pipeline';
import { genRequestQueuesPolicy, genCombineGetRequestsPolicy, genErrorFormatterPolicy, parseBigIntPolicy, genVersionCheckPolicy, genRetryOnFailurePolicy } from './utils/autorest.js';
import { Node as NodeApi } from './apis/node/index.js';
import { UnsupportedVersionError } from './utils/errors.js';
import { ConsensusProtocolVersion } from './tx/builder/constants.js';
var _ignoreVersion = /*#__PURE__*/new WeakMap();
var _cachedStatusPromise = /*#__PURE__*/new WeakMap();
var _isHyperchainPromise = /*#__PURE__*/new WeakMap();
/**
 * @category chain
 */
export default class Node extends NodeApi {
  /**
   * @param url - Url for node API
   * @param options - Options
   * @param options.ignoreVersion - Print warning instead of throwing exception if node
   * or consensus protocol version is not supported, use with caution
   * @param options.retryCount - Amount of extra requests to do in case of failure
   * @param options.retryOverallDelay - Time in ms to wait between all retries
   */
  constructor(url, {
    ignoreVersion = false,
    retryCount = 3,
    retryOverallDelay = 800,
    ...options
  } = {}) {
    const getVersion = async opts => (await this._getCachedStatus(opts)).nodeVersion;
    // eslint-disable-next-line constructor-super
    super(url, {
      allowInsecureConnection: true,
      additionalPolicies: [genVersionCheckPolicy('node', getVersion, '7.1.0', '8.0.0', ignoreVersion), genRequestQueuesPolicy(), genCombineGetRequestsPolicy(), genRetryOnFailurePolicy(retryCount, retryOverallDelay), genErrorFormatterPolicy(body => [' ', body.reason, body.errorCode == null ? '' : ` (${body.errorCode})`].join(''))],
      ...options
    });
    _classPrivateFieldInitSpec(this, _ignoreVersion, void 0);
    _classPrivateFieldInitSpec(this, _cachedStatusPromise, void 0);
    _classPrivateFieldInitSpec(this, _isHyperchainPromise, void 0);
    _classPrivateFieldSet(_ignoreVersion, this, ignoreVersion);
    this.pipeline.addPolicy(parseBigIntPolicy, {
      phase: 'Deserialize'
    });
    this.pipeline.removePolicy({
      name: userAgentPolicyName
    });
    this.pipeline.removePolicy({
      name: setClientRequestIdPolicyName
    });
    // TODO: use instead our retry policy
    this.pipeline.removePolicy({
      name: 'defaultRetryPolicy'
    });
  }
  async _getCachedStatus(options) {
    if (_classPrivateFieldGet(_cachedStatusPromise, this) != null) return _classPrivateFieldGet(_cachedStatusPromise, this);
    return this.getStatus(options);
  }
  async getStatus(...args) {
    const promise = super.getStatus(...args);
    promise.then(() => {
      _classPrivateFieldSet(_cachedStatusPromise, this, promise);
    }, () => {});
    return promise;
  }
  async _isHyperchain() {
    if (_classPrivateFieldGet(_isHyperchainPromise, this) != null) return _classPrivateFieldGet(_isHyperchainPromise, this);
    _classPrivateFieldSet(_isHyperchainPromise, this, this.getHyperchainContractPubkeys({
      requestOptions: {
        customHeaders: {
          '__no-retry': 'true'
        }
      }
    }).then(() => true, error => {
      if (error.message !== 'v3/hyperchain/contracts error: 404 status code') throw error;
      return false;
    }));
    return _classPrivateFieldGet(_isHyperchainPromise, this);
  }

  /**
   * Returns network ID provided by node.
   * This method won't do extra requests on subsequent calls.
   */
  async getNetworkId() {
    return (await this._getCachedStatus()).networkId;
  }
  async getNodeInfo() {
    const {
      nodeVersion,
      networkId: nodeNetworkId,
      protocols,
      topBlockHeight
    } = await this.getStatus();
    const consensusProtocolVersion = protocols.filter(({
      effectiveAtHeight
    }) => topBlockHeight >= effectiveAtHeight).reduce((acc, p) => p.effectiveAtHeight > acc.effectiveAtHeight ? p : acc, {
      effectiveAtHeight: -1,
      version: 0
    }).version;
    if (ConsensusProtocolVersion[consensusProtocolVersion] == null) {
      const version = consensusProtocolVersion.toString();
      const versions = Object.values(ConsensusProtocolVersion).filter(el => typeof el === 'number').map(el => +el);
      const geVersion = Math.min(...versions).toString();
      const ltVersion = (Math.max(...versions) + 1).toString();
      const error = new UnsupportedVersionError('consensus protocol', version, geVersion, ltVersion);
      if (_classPrivateFieldGet(_ignoreVersion, this)) console.warn(error.message);else throw error;
    }
    return {
      url: this.$host,
      nodeNetworkId,
      version: nodeVersion,
      consensusProtocolVersion
    };
  }
}
//# sourceMappingURL=Node.js.map