function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import { RpcConnectionError } from '../utils/errors.js';
import Node from '../Node.js';
import WalletConnectorFrameBase from './WalletConnectorFrameBase.js';
var _node = /*#__PURE__*/new WeakMap();
/**
 * Connect to wallet as iframe/web-extension, asks wallet to provide node url
 * In comparison with WalletConnectorFrame, this would work better for decentralized applications
 * @category aepp wallet communication
 */
export default class WalletConnectorFrameWithNode extends WalletConnectorFrameBase {
  constructor(...args) {
    super(...args);
    _classPrivateFieldInitSpec(this, _node, null);
  }
  /**
   * The node instance provided by wallet
   */
  get node() {
    return _classPrivateFieldGet(_node, this);
  }
  _updateNetwork(params) {
    if (params.node?.url == null) throw new RpcConnectionError('Missing URLs of the Node');
    _classPrivateFieldSet(_node, this, new Node(params.node.url));
    this.emit('nodeChange', _classPrivateFieldGet(_node, this));
  }

  /**
   * Connect to wallet
   * @param name - Aepp name
   * @param connection - Wallet connection object
   */
  static async connect(name, connection) {
    const connector = new WalletConnectorFrameWithNode();
    await super._connect(name, connection, connector, true);
    return connector;
  }
}
//# sourceMappingURL=WalletConnectorFrameWithNode.js.map