import { ValidatorResult } from './tx/validator.js';
import { TransactionError } from './utils/errors.js';
import Node from './Node.js';
import { SignedTx } from './apis/node/index.js';
import { Encoded } from './utils/encoder.js';
import AccountBase from './account/Base.js';
import { poll, waitForTxConfirm } from './chain.js';
/**
 * @category exception
 */
export declare class InvalidTxError extends TransactionError {
    validation: ValidatorResult[];
    transaction: Encoded.Transaction;
    constructor(message: string, validation: ValidatorResult[], transaction: Encoded.Transaction);
}
/**
 * Signs and submits transaction for mining
 * @category chain
 * @param txUnsigned - Transaction to sign and submit
 * @param options - Options
 * @returns Transaction details
 */
export declare function sendTransaction(txUnsigned: Encoded.Transaction, { onNode, onAccount, verify, waitMined, confirm, innerTx, ...options }: SendTransactionOptions): Promise<SendTransactionReturnType>;
type SendTransactionOptionsType = {
    /**
     * Node to use
     */
    onNode: Node;
    /**
     * Account to use
     */
    onAccount: AccountBase;
    /**
     * Verify transaction before broadcast, throw error if not
     */
    verify?: boolean;
    /**
     * Ensure that transaction get into block
     */
    waitMined?: boolean;
    /**
     * Number of micro blocks that should be mined after tx get included
     */
    confirm?: boolean | number;
} & Parameters<typeof poll>[1] & Omit<Parameters<typeof waitForTxConfirm>[1], 'confirm'> & Parameters<AccountBase['signTransaction']>[1];
export interface SendTransactionOptions extends SendTransactionOptionsType {
}
interface SendTransactionReturnType extends Partial<SignedTx> {
    hash: Encoded.TxHash;
    rawTx: Encoded.Transaction;
    confirmationHeight?: number;
}
export {};
