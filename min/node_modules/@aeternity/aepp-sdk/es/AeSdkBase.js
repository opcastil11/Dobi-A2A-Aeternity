import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import { CompilerError, DuplicateNodeError, NodeNotFoundError, NotImplementedError, TypeError as _TypeError } from './utils/errors.js';
import { wrapWithProxy } from './utils/wrap-proxy.js';
import AeSdkMethods from './AeSdkMethods.js';
var _wrappedOptions = /*#__PURE__*/new WeakMap();
/**
 * Basic AeSdk class implements:
 * - node selector,
 * - integrated compiler support,
 * - wrappers of account methods mapped to the current account.
 */
export default class AeSdkBase extends AeSdkMethods {
  /**
   * @param options - Options
   * @param options.nodes - Array of nodes
   */
  constructor({
    nodes = [],
    ...options
  } = {}) {
    super(options);
    _defineProperty(this, "pool", new Map());
    _classPrivateFieldInitSpec(this, _wrappedOptions, void 0);
    nodes.forEach(({
      name,
      instance
    }, i) => this.addNode(name, instance, i === 0));
    _classPrivateFieldSet(_wrappedOptions, this, {
      onNode: wrapWithProxy(() => this.api),
      onCompiler: wrapWithProxy(() => this.compilerApi),
      onAccount: wrapWithProxy(() => this._resolveAccount())
    });
  }

  // TODO: consider dropping this getter, because:
  // compiler is not intended to be used separately any more (functionality limited to sdk needs)
  // and user creates its instance by himself
  get compilerApi() {
    if (this._options.onCompiler == null) {
      throw new CompilerError("You can't use Compiler API. Compiler is not ready!");
    }
    return this._options.onCompiler;
  }
  get api() {
    this.ensureNodeConnected();
    return this.pool.get(this.selectedNodeName);
  }

  /**
   * Add Node
   * @param name - Node name
   * @param node - Node instance
   * @param select - Select this node as current
   * @example
   * ```js
   * // add and select new node with name 'testNode'
   * aeSdkBase.addNode('testNode', new Node({ url }), true)
   * ```
   */
  addNode(name, node, select = false) {
    if (this.pool.has(name)) throw new DuplicateNodeError(name);
    this.pool.set(name, node);
    if (select || this.selectedNodeName == null) {
      this.selectNode(name);
    }
  }

  /**
   * Select Node
   * @param name - Node name
   * @example
   * nodePool.selectNode('testNode')
   */
  selectNode(name) {
    if (!this.pool.has(name)) throw new NodeNotFoundError(`Node with name ${name} not in pool`);
    this.selectedNodeName = name;
  }

  /**
   * Check if you have selected node
   * @example
   * nodePool.isNodeConnected()
   */
  isNodeConnected() {
    return this.selectedNodeName != null;
  }
  ensureNodeConnected() {
    if (!this.isNodeConnected()) {
      throw new NodeNotFoundError("You can't use Node API. Node is not connected or not defined!");
    }
  }

  /**
   * Get information about node
   * @example
   * ```js
   * nodePool.getNodeInfo() // { name, version, networkId, protocol, ... }
   * ```
   */
  async getNodeInfo() {
    this.ensureNodeConnected();
    return {
      name: this.selectedNodeName,
      ...(await this.api.getNodeInfo())
    };
  }

  /**
   * Get array of available nodes
   * @example
   * nodePool.getNodesInPool()
   */
  async getNodesInPool() {
    return Promise.all(Array.from(this.pool.entries()).map(async ([name, node]) => ({
      name,
      ...(await node.getNodeInfo())
    })));
  }

  // eslint-disable-next-line class-methods-use-this
  addresses() {
    return [];
  }

  /**
   * Resolves an account
   * @param account - ak-address, instance of AccountBase, or keypair
   */
  _resolveAccount(account = this._options.onAccount) {
    if (typeof account === 'string') throw new NotImplementedError('Address in AccountResolver');
    if (typeof account === 'object') return account;
    throw new _TypeError('Account should be an address (ak-prefixed string), ' + `or instance of AccountBase, got ${String(account)} instead`);
  }
  get address() {
    return this._resolveAccount().address;
  }

  /**
   * Sign data blob
   * @param data - Data to sign
   * @param options - Options
   * @deprecated Use `unsafeSign` method instead
   */
  async sign(data, options = {}) {
    return this.unsafeSign(data, options);
  }

  /**
   * Sign data blob
   * @param data - Data to sign
   * @param options - Options
   */
  async unsafeSign(data, {
    onAccount,
    ...options
  } = {}) {
    return this._resolveAccount(onAccount).unsafeSign(data, options);
  }

  /**
   * Sign encoded transaction
   * @param tx - Transaction to sign
   * @param options - Options
   */
  async signTransaction(tx, {
    onAccount,
    ...options
  } = {}) {
    const networkId = this.selectedNodeName !== null ? await this.api.getNetworkId() : undefined;
    return this._resolveAccount(onAccount).signTransaction(tx, {
      networkId,
      ...options
    });
  }

  /**
   * Sign message
   * @param message - Message to sign
   * @param options - Options
   */
  async signMessage(message, {
    onAccount,
    ...options
  } = {}) {
    return this._resolveAccount(onAccount).signMessage(message, options);
  }

  /**
   * Sign typed data
   * @param data - Encoded data to sign
   * @param aci - Type of data to sign
   * @param options - Options
   */
  async signTypedData(data, aci, {
    onAccount,
    ...options
  } = {}) {
    return this._resolveAccount(onAccount).signTypedData(data, aci, options);
  }

  /**
   * Sign delegation, works only in Ceres
   * @param delegation - Delegation to sign
   * @param options - Options
   */
  async signDelegation(delegation, {
    onAccount,
    ...options
  } = {}) {
    var _options$networkId;
    (_options$networkId = options.networkId) !== null && _options$networkId !== void 0 ? _options$networkId : options.networkId = this.selectedNodeName !== null ? await this.api.getNetworkId() : undefined;
    return this._resolveAccount(onAccount).signDelegation(delegation, options);
  }

  /**
   * The same as AeSdkMethods:getContext, but it would resolve ak_-prefixed address in
   * `mergeWith.onAccount` to AccountBase.
   */
  getContext(mergeWith = {}) {
    return {
      ...this._options,
      ..._classPrivateFieldGet(_wrappedOptions, this),
      ...mergeWith,
      ...(mergeWith.onAccount != null && {
        onAccount: this._resolveAccount(mergeWith.onAccount)
      })
    };
  }
}
//# sourceMappingURL=AeSdkBase.js.map