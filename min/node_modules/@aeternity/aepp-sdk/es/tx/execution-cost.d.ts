import { Encoded } from '../utils/encoder.js';
import Node from '../Node.js';
/**
 * Calculates the cost of transaction execution
 * Provides an upper cost of contract-call-related transactions because of `gasLimit`.
 * Also assumes that oracle query fee is 0 unless it is provided in options.
 *
 * The idea is that if you need to show transaction details with some accuracy you can define
 * expense fields that you want to show separately. And to show `getExecutionCost` result as a fee,
 * subtracting all fields shown separately.
 *
 * @example
 * ```vue
 * <template>
 * Amount: {{ txUnpacked.amount }}
 * Name fee: {{ txUnpacked.nameFee }}
 * Other fees: {{ getExecutionCost(txEncoded) - txUnpacked.amount - txUnpacked.nameFee }}
 * </template>
 * ```
 *
 * Doing this way you won't worry to show wrong fee for a transaction you may not support. Because
 * the SDK calculates the overall price of any transaction on its side.
 *
 * @param transaction - Transaction to calculate the cost of
 * @param options - Options
 * @param options.innerTx - Should be provided if transaction wrapped with Tag.PayingForTx
 * @param options.gasUsed - Amount of gas actually used to make calculation more accurate
 * @param options.queryFee - Oracle query fee
 * @param options.isInitiator - Is transaction signer an initiator of state channel
 * @category utils
 */
export declare function getExecutionCost(transaction: Encoded.Transaction, { innerTx, gasUsed, queryFee, isInitiator, }?: {
    innerTx?: 'fee-payer' | 'freeloader';
    gasUsed?: number;
    queryFee?: string;
    isInitiator?: boolean;
}): bigint;
/**
 * Calculates the cost of signed transaction execution
 * @param transaction - Transaction to calculate the cost of
 * @param networkId - Network id used to sign the transaction
 * @param options - Options
 * @category utils
 */
export declare function getExecutionCostBySignedTx(transaction: Encoded.Transaction, networkId: string, options?: Omit<Parameters<typeof getExecutionCost>[1], 'innerTx'>): bigint;
/**
 * Calculates the cost of signed and not signed transaction execution using node
 * @param transaction - Transaction to calculate the cost of
 * @param node - Node to use
 * @param options - Options
 * @param options.isMined - Is transaction already mined or not
 * @category utils
 */
export declare function getExecutionCostUsingNode(transaction: Encoded.Transaction, node: Node, { isMined, ...options }?: {
    isMined?: boolean;
} & Parameters<typeof getExecutionCost>[1]): Promise<bigint>;
