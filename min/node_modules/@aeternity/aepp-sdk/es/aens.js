function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Aens methods - routines to interact with the Ã¦ternity naming system
 *
 * The high-level description of the naming system is
 * https://github.com/aeternity/protocol/blob/master/AENS.md in the protocol
 * repository.
 */

import { genSalt, isEncoded } from './utils/crypto.js';
import { commitmentHash, isAuctionName, produceNameId } from './tx/builder/helpers.js';
import { Tag } from './tx/builder/constants.js';
import { Encoding } from './utils/encoder.js';
import { LogicError } from './utils/errors.js';
import { sendTransaction } from './send-transaction.js';
import { buildTxAsync } from './tx/builder/index.js';
class NotAuctionNameError extends LogicError {
  constructor(name, action) {
    super(`Can't ${action} because ${name} is not an auction name`);
    this.name = 'NotAuctionNameError';
  }
}

/**
 * @category AENS
 * @example
 * ```js
 * const name = new Name('test.chain', aeSdk.getContext())
 * ```
 */
var _salt = /*#__PURE__*/new WeakMap();
export default class Name {
  /**
   * @param value - AENS name
   * @param options - Options
   * @param options.onNode - Node to use
   * @param options.onAccount - Account to use
   */
  constructor(value, options) {
    _classPrivateFieldInitSpec(this, _salt, void 0);
    this.value = value;
    this.options = options;
    this.options = options;
  }

  /**
   * Name ID encoded as nm_-prefixed string
   */
  get id() {
    return produceNameId(this.value);
  }

  /**
   * Revoke a name
   * @param options - Options
   * @returns mined transaction details
   * @example
   * ```js
   * await name.revoke({ fee, ttl, nonce })
   * ```
   */
  async revoke(options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.NameRevokeTx,
      nameId: this.value,
      accountId: opt.onAccount.address
    });
    return sendTransaction(tx, opt);
  }

  /**
   * Update a name
   * @param pointers - Map of pointer keys to corresponding addresses
   * @param options - Options
   * @example
   * ```js
   * const name = 'test.chain'
   * const channel = 'ch_2519mBs...'
   * const pointers = {
   *   account_pubkey: 'ak_asd23dasdas...,',
   *   contract_pubkey: 'ct_asdf34fasdasd...',
   *   [getDefaultPointerKey(channel)]: channel,
   * }
   * await name.update(pointers, { nameTtl, ttl, fee, nonce, clientTtl })
   * ```
   */
  async update(pointers, options = {}) {
    const {
      extendPointers,
      ...opt
    } = {
      ...this.options,
      ...options
    };
    const allPointers = {
      ...(extendPointers === true && Object.fromEntries((await opt.onNode.getNameEntryByName(this.value)).pointers.map(({
        key,
        id
      }) => [key, id]))),
      ...pointers
    };
    const hasRawPointers = Object.values(allPointers).some(v => isEncoded(v, Encoding.Bytearray));
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.NameUpdateTx,
      version: hasRawPointers ? 2 : 1,
      nameId: this.value,
      accountId: opt.onAccount.address,
      pointers: Object.entries(allPointers).map(([key, id]) => ({
        key,
        id
      }))
    });
    return sendTransaction(tx, opt);
  }

  /**
   * Transfer a name to another account
   * @param address - Recipient account public key
   * @param options - Options
   * @returns mined transaction details
   * @example
   * ```js
   * await name.transfer('ak_asd23dasdas...', { ttl, fee, nonce })
   * ```
   */
  async transfer(address, options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.NameTransferTx,
      nameId: this.value,
      accountId: opt.onAccount.address,
      recipientId: address
    });
    return sendTransaction(tx, opt);
  }

  /**
   * Query the AENS name info from the node and return the object with info
   * @param options - Options
   * @example
   * ```js
   * const nameEntry = await name.getState()
   * console.log(nameEntry.owner)
   * ```
   */
  async getState(options = {}) {
    var _options$onNode;
    const onNode = (_options$onNode = options.onNode) !== null && _options$onNode !== void 0 ? _options$onNode : this.options.onNode;
    const nameEntry = await onNode.getNameEntryByName(this.value);
    return {
      ...nameEntry,
      id: nameEntry.id,
      owner: nameEntry.owner
    };
  }

  /**
   * Query the AENS auction info from the node and return the object with info
   * @param options - Options
   * @example
   * ```js
   * const auctionEntry = await name.getAuctionState()
   * console.log(auctionEntry.highestBidder)
   * ```
   */
  async getAuctionState(options = {}) {
    var _options$onNode2;
    if (!isAuctionName(this.value)) throw new NotAuctionNameError(this.value, 'get auction state');
    const onNode = (_options$onNode2 = options.onNode) !== null && _options$onNode2 !== void 0 ? _options$onNode2 : this.options.onNode;
    const nameEntry = await onNode.getAuctionEntryByName(this.value);
    return {
      ...nameEntry,
      id: nameEntry.id,
      highestBidder: nameEntry.highestBidder
    };
  }

  /**
   *
   * @param nameTtl - represents in number of blocks (max and default is 180000)
   * @param options - Options
   * @returns mined transaction details
   */
  async extendTtl(nameTtl, options = {}) {
    return this.update({}, {
      ...options,
      nameTtl,
      extendPointers: true
    });
  }

  /**
   * Claim a previously preclaimed registration. This can only be done after the preclaim step
   * @param options - options
   * @returns mined transaction details
   * @example
   * ```js
   * await name.claim({ ttl, fee, nonce, nameFee })
   * ```
   */
  async claim(options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      nameSalt: _classPrivateFieldGet(_salt, this),
      ...opt,
      tag: Tag.NameClaimTx,
      accountId: opt.onAccount.address,
      name: this.value
    });
    return sendTransaction(tx, opt);
  }

  /**
   * Preclaim a name. Sends a hash of the name and a random salt to the node
   * @param options - Options
   * @example
   * ```js
   * await name.preclaim({ ttl, fee, nonce })
   * ```
   */
  async preclaim(options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    const nameSalt = genSalt();
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.NamePreclaimTx,
      accountId: opt.onAccount.address,
      commitmentId: commitmentHash(this.value, nameSalt)
    });
    const result = await sendTransaction(tx, opt);
    _classPrivateFieldSet(_salt, this, nameSalt);
    return {
      ...result,
      nameSalt
    };
  }

  /**
   * Bid to name auction
   * @param nameFee - Name fee (bid fee)
   * @param options - Options
   * @returns mined transaction details
   * @example
   * ```js
   * const bidFee = computeBidFee(name.value, { startFee, increment: 0.42 })
   * await name.bid(213109412839123, { ttl, fee, nonce })
   * ```
   */
  async bid(nameFee, options = {}) {
    if (!isAuctionName(this.value)) throw new NotAuctionNameError(this.value, 'make a bid');
    const opt = {
      ...this.options,
      ...options
    };
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.NameClaimTx,
      accountId: opt.onAccount.address,
      nameSalt: 0,
      name: this.value,
      nameFee
    });
    return sendTransaction(tx, opt);
  }
}
//# sourceMappingURL=aens.js.map