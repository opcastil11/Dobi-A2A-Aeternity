function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import AccountBase from './Base.js';
import { ArgumentError, InternalError, InvalidAuthDataError, NotImplementedError } from '../utils/errors.js';
import { decode } from '../utils/encoder.js';
import { getAccount } from '../chain.js';
import Contract from '../contract/Contract.js';
import { buildTxAsync, buildTx } from '../tx/builder/index.js';
import { Tag } from '../tx/builder/constants.js';

/**
 * Generalized account class
 * @category account generalized
 */
var _authFun = /*#__PURE__*/new WeakMap();
export default class AccountGeneralized extends AccountBase {
  /**
   * @param address - Address of generalized account
   */
  constructor(address) {
    super();
    _classPrivateFieldInitSpec(this, _authFun, void 0);
    decode(address);
    this.address = address;
  }

  /**
   * @deprecated Use `unsafeSign` method instead
   */
  // eslint-disable-next-line class-methods-use-this
  async sign() {
    return this.unsafeSign();
  }

  // eslint-disable-next-line class-methods-use-this
  async unsafeSign() {
    throw new NotImplementedError("Can't sign using generalized account");
  }

  // eslint-disable-next-line class-methods-use-this
  async signMessage() {
    throw new NotImplementedError("Can't sign using generalized account");
  }

  // eslint-disable-next-line class-methods-use-this
  async signTypedData() {
    throw new NotImplementedError("Can't sign using generalized account");
  }

  // eslint-disable-next-line class-methods-use-this
  async signDelegation() {
    throw new NotImplementedError('signing delegation using generalized account');
  }
  async signTransaction(tx, {
    authData,
    onCompiler,
    onNode
  }) {
    if (authData == null || onCompiler == null || onNode == null) {
      throw new ArgumentError('authData, onCompiler, onNode', 'provided', null);
    }
    const {
      callData,
      sourceCode,
      args,
      fee,
      gasLimit,
      gasPrice
    } = typeof authData === 'function' ? await authData(tx) : authData;
    const authCallData = callData !== null && callData !== void 0 ? callData : await (async () => {
      if (_classPrivateFieldGet(_authFun, this) == null) {
        const account = await getAccount(this.address, {
          onNode
        });
        if (account.kind !== 'generalized') {
          throw new ArgumentError('account kind', 'generalized', account.kind);
        }
        _classPrivateFieldSet(_authFun, this, account.authFun);
      }
      if (_classPrivateFieldGet(_authFun, this) == null) {
        throw new InternalError('Account in generalised, but authFun not provided');
      }
      if (sourceCode == null || args == null) {
        throw new InvalidAuthDataError('Auth data must contain sourceCode and args or callData.');
      }
      const contract = await Contract.initialize({
        onCompiler,
        onNode,
        sourceCode
      });
      return contract._calldata.encode(contract._name, _classPrivateFieldGet(_authFun, this), args);
    })();
    const gaMetaTx = await buildTxAsync({
      tag: Tag.GaMetaTx,
      tx: {
        tag: Tag.SignedTx,
        encodedTx: decode(tx),
        signatures: []
      },
      gaId: this.address,
      authData: authCallData,
      fee,
      gasLimit,
      gasPrice,
      onNode
    });
    return buildTx({
      tag: Tag.SignedTx,
      encodedTx: decode(gaMetaTx),
      signatures: []
    });
  }
}
//# sourceMappingURL=Generalized.js.map