import AccountBase from './Base.js';
import { Encoded } from '../utils/encoder.js';
import { AciValue } from '../utils/typed-data.js';
export declare function getBufferToSign(transaction: Encoded.Transaction, networkId: string, innerTx: boolean): Uint8Array;
/**
 * In-memory account class
 * @category account
 */
export default class AccountMemory extends AccountBase {
    #private;
    readonly secretKey: Encoded.AccountSecretKey;
    readonly address: Encoded.AccountAddress;
    /**
     * @param secretKey - Secret key
     */
    constructor(secretKey: Encoded.AccountSecretKey);
    /**
     * Generates a new AccountMemory using a random secret key
     */
    static generate(): AccountMemory;
    /**
     * @deprecated Use `unsafeSign` method instead
     */
    sign(data: string | Uint8Array, options?: any): Promise<Uint8Array>;
    unsafeSign(data: string | Uint8Array, options?: any): Promise<Uint8Array>;
    signTransaction(transaction: Encoded.Transaction, { innerTx, networkId, ...options }?: {
        innerTx?: boolean;
        networkId?: string;
    }): Promise<Encoded.Transaction>;
    signMessage(message: string, options?: any): Promise<Uint8Array>;
    signTypedData(data: Encoded.ContractBytearray, aci: AciValue, { name, version, networkId, contractAddress, ...options }?: Parameters<AccountBase['signTypedData']>[2]): Promise<Encoded.Signature>;
    signDelegation(delegation: Encoded.Bytearray, { networkId }?: {
        networkId?: string;
    }): Promise<Encoded.Signature>;
}
