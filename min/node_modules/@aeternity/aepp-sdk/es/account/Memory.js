import { Buffer as _Buffer } from "buffer";
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
import nacl from 'tweetnacl';
import AccountBase from './Base.js';
import { hash, hashMessage, messagePrefixLength } from '../utils/crypto.js';
import { ArgumentError } from '../utils/errors.js';
import { decode, encode, Encoding } from '../utils/encoder.js';
import { concatBuffers } from '../utils/other.js';
import { hashTypedData } from '../utils/typed-data.js';
import { buildTx } from '../tx/builder/index.js';
import { Tag } from '../tx/builder/constants.js';
export function getBufferToSign(transaction, networkId, innerTx) {
  const prefixes = [networkId];
  if (innerTx) prefixes.push('inner_tx');
  const rlpBinaryTx = decode(transaction);
  return concatBuffers([_Buffer.from(prefixes.join('-')), hash(rlpBinaryTx)]);
}

/**
 * In-memory account class
 * @category account
 */
var _secretKeyDecoded = /*#__PURE__*/new WeakMap();
export default class AccountMemory extends AccountBase {
  /**
   * @param secretKey - Secret key
   */
  constructor(secretKey) {
    super();
    _classPrivateFieldInitSpec(this, _secretKeyDecoded, void 0);
    this.secretKey = secretKey;
    const keyPair = nacl.sign.keyPair.fromSeed(decode(secretKey));
    _classPrivateFieldSet(_secretKeyDecoded, this, keyPair.secretKey);
    this.address = encode(keyPair.publicKey, Encoding.AccountAddress);
  }

  /**
   * Generates a new AccountMemory using a random secret key
   */
  static generate() {
    const secretKey = encode(nacl.randomBytes(32), Encoding.AccountSecretKey);
    return new AccountMemory(secretKey);
  }

  /**
   * @deprecated Use `unsafeSign` method instead
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async sign(data, options) {
    return this.unsafeSign(data, options);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async unsafeSign(data, options) {
    return nacl.sign.detached(_Buffer.from(data), _classPrivateFieldGet(_secretKeyDecoded, this));
  }
  async signTransaction(transaction, {
    innerTx,
    networkId,
    ...options
  } = {}) {
    if (networkId == null) {
      throw new ArgumentError('networkId', 'provided', networkId);
    }
    const rlpBinaryTx = decode(transaction);
    const txWithNetworkId = getBufferToSign(transaction, networkId, innerTx === true);
    const signatures = [await this.unsafeSign(txWithNetworkId, options)];
    return buildTx({
      tag: Tag.SignedTx,
      encodedTx: rlpBinaryTx,
      signatures
    });
  }
  async signMessage(message, options) {
    return this.unsafeSign(hashMessage(message), options);
  }
  async signTypedData(data, aci, {
    name,
    version,
    networkId,
    contractAddress,
    ...options
  } = {}) {
    const dHash = hashTypedData(data, aci, {
      name,
      version,
      networkId,
      contractAddress
    });
    const signature = await this.unsafeSign(dHash, options);
    return encode(signature, Encoding.Signature);
  }
  async signDelegation(delegation, {
    networkId
  } = {}) {
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    const payload = concatBuffers([messagePrefixLength, new Uint8Array([1]), _Buffer.from(networkId), decode(delegation)]);
    const signature = await this.unsafeSign(payload);
    return encode(signature, Encoding.Signature);
  }
}
//# sourceMappingURL=Memory.js.map