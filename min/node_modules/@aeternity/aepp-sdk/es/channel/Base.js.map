{"version":3,"file":"Base.js","names":["EventEmitter","snakeToPascal","unpackTx","Tag","handlers","initialize","enqueueAction","notify","call","disconnect","channelDisconnect","ChannelError","IllegalArgumentError","unpackEntry","snakeToPascalObjKeys","obj","Object","entries","reduce","result","key","val","channelCounter","_debugId","WeakMap","Channel","constructor","_defineProperty","Map","_classPrivateFieldInitSpec","_classPrivateFieldSet","_debug","args","_options","debug","console","_classPrivateFieldGet","options","_initialize","channel","_options$existingFsmI","reconnect","existingFsmId","existingChannelId","reconnectHandler","reestablish","awaitingConnection","channelOpen","on","eventName","callback","_eventEmitter","off","removeListener","status","_status","state","res","calls","halfSignedTx","SignedTx","signedTx","trees","round","_state","params","encodedTx","tag","ChannelCreateTx","ChannelOffChainTx","ChannelWithdrawTx","ChannelDepositTx","id","_channelId","fsmId","_fsmId","action","handler","leave","awaitingLeave","shutdown","sign","awaitingShutdownTx"],"sources":["../../src/channel/Base.ts"],"sourcesContent":["import EventEmitter from 'events';\nimport { w3cwebsocket as W3CWebSocket } from 'websocket';\nimport { snakeToPascal } from '../utils/string.js';\nimport { unpackTx } from '../tx/builder/index.js';\nimport { Tag } from '../tx/builder/constants.js';\nimport * as handlers from './handlers.js';\nimport {\n  initialize,\n  enqueueAction,\n  notify,\n  call,\n  disconnect as channelDisconnect,\n  SignTx,\n  ChannelOptions,\n  ChannelState,\n  ChannelHandler,\n  ChannelAction,\n  ChannelStatus,\n  ChannelFsm,\n  ChannelMessage,\n  ChannelEvents,\n} from './internal.js';\nimport { ChannelError, IllegalArgumentError } from '../utils/errors.js';\nimport { Encoded } from '../utils/encoder.js';\nimport { TxUnpacked } from '../tx/builder/schema.generated.js';\nimport { EntryTag } from '../tx/builder/entry/constants.js';\nimport { unpackEntry } from '../tx/builder/entry/index.js';\nimport { EntUnpacked } from '../tx/builder/entry/schema.generated.js';\n\nfunction snakeToPascalObjKeys<Type>(obj: object): Type {\n  return Object.entries(obj).reduce(\n    (result, [key, val]) => ({\n      ...result,\n      [snakeToPascal(key)]: val,\n    }),\n    {},\n  ) as Type;\n}\n\nlet channelCounter = 0;\n\n/**\n * Channel\n * @example\n * ```js\n * await Channel.initialize({\n *   url: 'ws://localhost:3001',\n *   role: 'initiator'\n *   initiatorId: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n *   responderId: 'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',\n *   initiatorAmount: 1e18,\n *   responderAmount: 1e18,\n *   pushAmount: 0,\n *   channelReserve: 0,\n *   ttl: 1000,\n *   host: 'localhost',\n *   port: 3002,\n *   lockPeriod: 10,\n *   async sign (tag, tx) => await account.signTransaction(tx)\n * })\n * ```\n */\nexport default class Channel {\n  _eventEmitter = new EventEmitter();\n\n  _pingTimeoutId!: NodeJS.Timeout;\n\n  _nextRpcMessageId = 0;\n\n  _rpcCallbacks = new Map<number, (message: object) => void>();\n\n  _fsmId?: Encoded.Bytearray;\n\n  _messageQueue: ChannelMessage[] = [];\n\n  _isMessageQueueLocked = false;\n\n  _actionQueue: ChannelAction[] = [];\n\n  _isActionQueueLocked = false;\n\n  _status: ChannelStatus = 'disconnected';\n\n  _fsm!: ChannelFsm;\n\n  _websocket!: W3CWebSocket;\n\n  _state: Encoded.Transaction | '' = '';\n\n  _options!: ChannelOptions;\n\n  readonly #debugId: number;\n\n  _channelId?: Encoded.Channel;\n\n  protected constructor() {\n    channelCounter += 1;\n    this.#debugId = channelCounter;\n  }\n\n  _debug(...args: any[]): void {\n    if (this._options.debug !== true) return;\n    console.debug(`Channel #${this.#debugId}`, ...args);\n  }\n\n  /**\n   * @param options - Channel params\n   */\n  static async initialize(options: ChannelOptions): Promise<Channel> {\n    return Channel._initialize(new Channel(), options);\n  }\n\n  static async _initialize<T extends Channel>(channel: T, options: ChannelOptions): Promise<T> {\n    const reconnect = (options.existingFsmId ?? options.existingChannelId) != null;\n    if (reconnect && (options.existingFsmId == null || options.existingChannelId == null)) {\n      throw new IllegalArgumentError(\n        '`existingChannelId`, `existingFsmId` should be both provided or missed',\n      );\n    }\n    const reconnectHandler =\n      handlers[options.reestablish === true ? 'awaitingReestablish' : 'awaitingReconnection'];\n    await initialize(\n      channel,\n      reconnect ? reconnectHandler : handlers.awaitingConnection,\n      handlers.channelOpen,\n      options,\n    );\n    return channel;\n  }\n\n  /**\n   * Register event listener function\n   *\n   * Possible events:\n   *\n   *   - \"error\"\n   *   - \"stateChanged\"\n   *   - \"statusChanged\"\n   *   - \"message\"\n   *   - \"peerDisconnected\"\n   *   - \"onChainTx\"\n   *   - \"ownWithdrawLocked\"\n   *   - \"withdrawLocked\"\n   *   - \"ownDepositLocked\"\n   *   - \"depositLocked\"\n   *   - \"channelReestablished\"\n   *   - \"newContract\"\n   *\n   *\n   * @param eventName - Event name\n   * @param callback - Callback function\n   */\n  on<E extends keyof ChannelEvents>(eventName: E, callback: ChannelEvents[E]): void {\n    this._eventEmitter.on(eventName, callback);\n  }\n\n  /**\n   * Remove event listener function\n   * @param eventName - Event name\n   * @param callback - Callback function\n   */\n  off<E extends keyof ChannelEvents>(eventName: E, callback: ChannelEvents[E]): void {\n    this._eventEmitter.removeListener(eventName, callback);\n  }\n\n  /**\n   * Close the connection\n   */\n  disconnect(): void {\n    return channelDisconnect(this);\n  }\n\n  /**\n   * Get current status\n   */\n  status(): ChannelStatus {\n    return this._status;\n  }\n\n  /**\n   * Get current state\n   */\n  async state(): Promise<{\n    calls: EntUnpacked & { tag: EntryTag.CallsMtree };\n    halfSignedTx?: TxUnpacked & { tag: Tag.SignedTx };\n    signedTx?: TxUnpacked & { tag: Tag.SignedTx };\n    trees: EntUnpacked & { tag: EntryTag.StateTrees };\n  }> {\n    const res = snakeToPascalObjKeys<{\n      calls: Encoded.CallStateTree;\n      halfSignedTx: Encoded.Transaction | '';\n      signedTx: Encoded.Transaction | '';\n      trees: Encoded.StateTrees;\n    }>(await call(this, 'channels.get.offchain_state', {}));\n    return {\n      calls: unpackEntry(res.calls),\n      ...(res.halfSignedTx !== '' && { halfSignedTx: unpackTx(res.halfSignedTx, Tag.SignedTx) }),\n      ...(res.signedTx !== '' && { signedTx: unpackTx(res.signedTx, Tag.SignedTx) }),\n      trees: unpackEntry(res.trees),\n    };\n  }\n\n  /**\n   * Get current round\n   *\n   * If round cannot be determined (for example when channel has not been opened)\n   * it will return `null`.\n   */\n  round(): number | null {\n    if (this._state === '') {\n      return null;\n    }\n    const params = unpackTx(this._state, Tag.SignedTx).encodedTx;\n    switch (params.tag) {\n      case Tag.ChannelCreateTx:\n        return 1;\n      case Tag.ChannelOffChainTx:\n      case Tag.ChannelWithdrawTx:\n      case Tag.ChannelDepositTx:\n        return params.round;\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Get channel id\n   *\n   */\n  id(): Encoded.Channel {\n    if (this._channelId == null) throw new ChannelError('Channel is not initialized');\n    return this._channelId;\n  }\n\n  /**\n   * Get channel's fsm id\n   *\n   */\n  fsmId(): Encoded.Bytearray {\n    if (this._fsmId == null) throw new ChannelError('Channel is not initialized');\n    return this._fsmId;\n  }\n\n  protected async enqueueAction(\n    action: () => { handler: ChannelHandler; state?: Partial<ChannelState> },\n  ): Promise<any> {\n    return enqueueAction(this, (channel, state) => state?.handler === handlers.channelOpen, action);\n  }\n\n  /**\n   * Leave channel\n   *\n   * It is possible to leave a channel and then later reestablish the channel\n   * off-chain state and continue operation. When a leave method is called,\n   * the channel fsm passes it on to the peer fsm, reports the current mutually\n   * signed state and then terminates.\n   *\n   * The channel can be reestablished by instantiating another Channel instance\n   * with two extra params: existingChannelId and existingFsmId.\n   *\n   * @example\n   * ```js\n   * channel.leave().then(({ channelId, signedTx }) => {\n   *   console.log(channelId)\n   *   console.log(signedTx)\n   * })\n   * ```\n   */\n  async leave(): Promise<{ channelId: Encoded.Channel; signedTx: Encoded.Transaction }> {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.leave');\n      return { handler: handlers.awaitingLeave };\n    });\n  }\n\n  /**\n   * Trigger mutual close\n   *\n   * At any moment after the channel is opened, a closing procedure can be triggered.\n   * This can be done by either of the parties. The process is similar to the off-chain updates.\n   *\n   * @param sign - Function which verifies and signs mutual close transaction\n   * @example\n   * ```js\n   * channel.shutdown(\n   *   async (tx) => await account.signTransaction(tx)\n   * ).then(tx => console.log('on_chain_tx', tx))\n   * ```\n   */\n  async shutdown(sign: SignTx): Promise<Encoded.Transaction> {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.shutdown');\n      return {\n        handler: handlers.awaitingShutdownTx,\n        state: { sign },\n      };\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]}