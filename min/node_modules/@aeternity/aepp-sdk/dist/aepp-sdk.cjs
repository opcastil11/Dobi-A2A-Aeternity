(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("bignumber.js"), require("@azure/core-rest-pipeline"), require("tweetnacl"), require("bs58"), require("buffer"), require("rlp"), require("@azure/core-client"), require("@aeternity/aepp-calldata"), require("canonicalize"), require("eventemitter3"), require("json-bigint"), require("@scure/bip39"), require("tweetnacl-auth"), require("websocket"), require("events"), require("isomorphic-ws"));
	else if(typeof define === 'function' && define.amd)
		define(["bignumber.js", "@azure/core-rest-pipeline", "tweetnacl", "bs58", "buffer", "rlp", "@azure/core-client", "@aeternity/aepp-calldata", "canonicalize", "eventemitter3", "json-bigint", "@scure/bip39", "tweetnacl-auth", "websocket", "events", "isomorphic-ws"], factory);
	else if(typeof exports === 'object')
		exports["Aeternity"] = factory(require("bignumber.js"), require("@azure/core-rest-pipeline"), require("tweetnacl"), require("bs58"), require("buffer"), require("rlp"), require("@azure/core-client"), require("@aeternity/aepp-calldata"), require("canonicalize"), require("eventemitter3"), require("json-bigint"), require("@scure/bip39"), require("tweetnacl-auth"), require("websocket"), require("events"), require("isomorphic-ws"));
	else
		root["Aeternity"] = factory(root["bignumber.js"], root["@azure/core-rest-pipeline"], root["tweetnacl"], root["bs58"], root["buffer"], root["rlp"], root["@azure/core-client"], root["@aeternity/aepp-calldata"], root["canonicalize"], root["eventemitter3"], root["json-bigint"], root["@scure/bip39"], root["tweetnacl-auth"], root["websocket"], root["events"], root["isomorphic-ws"]);
})(global, (__WEBPACK_EXTERNAL_MODULE__6168__, __WEBPACK_EXTERNAL_MODULE__833__, __WEBPACK_EXTERNAL_MODULE__1655__, __WEBPACK_EXTERNAL_MODULE__4578__, __WEBPACK_EXTERNAL_MODULE__18__, __WEBPACK_EXTERNAL_MODULE__6514__, __WEBPACK_EXTERNAL_MODULE__1081__, __WEBPACK_EXTERNAL_MODULE__2853__, __WEBPACK_EXTERNAL_MODULE__6016__, __WEBPACK_EXTERNAL_MODULE__1891__, __WEBPACK_EXTERNAL_MODULE__4146__, __WEBPACK_EXTERNAL_MODULE__8380__, __WEBPACK_EXTERNAL_MODULE__5196__, __WEBPACK_EXTERNAL_MODULE__8963__, __WEBPACK_EXTERNAL_MODULE__761__, __WEBPACK_EXTERNAL_MODULE__7250__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 18:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__18__;

/***/ }),

/***/ 36:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(1091);
var isWellKnownSymbol = __webpack_require__(9197);

// `Symbol.isWellKnown` method
// obsolete version of https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol
// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected
$({ target: 'Symbol', stat: true, name: 'isWellKnownSymbol', forced: true }, {
  isWellKnown: isWellKnownSymbol
});


/***/ }),

/***/ 43:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPossiblePrototype = __webpack_require__(4018);

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (isPossiblePrototype(argument)) return argument;
  throw new $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ 70:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(1661);

module.exports = parent;


/***/ }),

/***/ 160:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(3948);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 183:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(1091);
var call = __webpack_require__(3930);
var IS_PURE = __webpack_require__(7376);
var FunctionName = __webpack_require__(6833);
var isCallable = __webpack_require__(2250);
var createIteratorConstructor = __webpack_require__(7181);
var getPrototypeOf = __webpack_require__(5972);
var setPrototypeOf = __webpack_require__(9192);
var setToStringTag = __webpack_require__(4840);
var createNonEnumerableProperty = __webpack_require__(1626);
var defineBuiltIn = __webpack_require__(8055);
var wellKnownSymbol = __webpack_require__(6264);
var Iterators = __webpack_require__(3742);
var IteratorsCore = __webpack_require__(5116);

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    }

    return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ 359:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: remove from `core-js@4`
var defineWellKnownSymbol = __webpack_require__(366);

defineWellKnownSymbol('replaceAll');


/***/ }),

/***/ 366:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var path = __webpack_require__(2046);
var hasOwn = __webpack_require__(9724);
var wrappedWellKnownSymbolModule = __webpack_require__(560);
var defineProperty = (__webpack_require__(4284).f);

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ 376:
/***/ ((module) => {

"use strict";

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 392:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(2861).Buffer)

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ 470:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPrimitive = __webpack_require__(6028);
var isSymbol = __webpack_require__(5594);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 533:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Object$defineProperty = __webpack_require__(591);
var toPropertyKey = __webpack_require__(4704);
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? _Object$defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 551:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(5951);
var isCallable = __webpack_require__(2250);

var WeakMap = globalThis.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 560:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(6264);

exports.f = wellKnownSymbol;


/***/ }),

/***/ 575:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toLength = __webpack_require__(3121);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 581:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(3930);
var isCallable = __webpack_require__(2250);
var isObject = __webpack_require__(6285);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 591:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(4997);


/***/ }),

/***/ 663:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(3930);
var hasOwn = __webpack_require__(9724);
var isPrototypeOf = __webpack_require__(8280);
var regExpFlags = __webpack_require__(5606);

var RegExpPrototype = RegExp.prototype;

module.exports = function (R) {
  var flags = R.flags;
  return flags === undefined && !('flags' in RegExpPrototype) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype, R)
    ? call(regExpFlags, R) : flags;
};


/***/ }),

/***/ 726:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bind = __webpack_require__(8311);
var uncurryThis = __webpack_require__(1907);
var IndexedObject = __webpack_require__(6946);
var toObject = __webpack_require__(9298);
var lengthOfArrayLike = __webpack_require__(575);
var arraySpeciesCreate = __webpack_require__(6968);

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE === 1;
  var IS_FILTER = TYPE === 2;
  var IS_SOME = TYPE === 3;
  var IS_EVERY = TYPE === 4;
  var IS_FIND_INDEX = TYPE === 6;
  var IS_FILTER_REJECT = TYPE === 7;
  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike(self);
    var boundFunction = bind(callbackfn, that);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ 751:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(1091);
var hasOwn = __webpack_require__(9724);
var isSymbol = __webpack_require__(5594);
var tryToString = __webpack_require__(4640);
var shared = __webpack_require__(5816);
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(4411);

var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.keyFor` method
// https://tc39.es/ecma262/#sec-symbol.keyfor
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw new TypeError(tryToString(sym) + ' is not a symbol');
    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  }
});


/***/ }),

/***/ 761:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__761__;

/***/ }),

/***/ 768:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(6264);
var defineProperty = (__webpack_require__(4284).f);

var METADATA = wellKnownSymbol('metadata');
var FunctionPrototype = Function.prototype;

// Function.prototype[@@metadata]
// https://github.com/tc39/proposal-decorator-metadata
if (FunctionPrototype[METADATA] === undefined) {
  defineProperty(FunctionPrototype, METADATA, {
    value: null
  });
}


/***/ }),

/***/ 798:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(5951);
var userAgent = __webpack_require__(6794);

var process = globalThis.process;
var Deno = globalThis.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 829:
/***/ ((module) => {

const ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array'

// For convenience, let people hash a string, not just a Uint8Array
function normalizeInput (input) {
  let ret
  if (input instanceof Uint8Array) {
    ret = input
  } else if (typeof input === 'string') {
    const encoder = new TextEncoder()
    ret = encoder.encode(input)
  } else {
    throw new Error(ERROR_MSG_INPUT)
  }
  return ret
}

// Converts a Uint8Array to a hexadecimal string
// For example, toHex([255, 0, 255]) returns "ff00ff"
function toHex (bytes) {
  return Array.prototype.map
    .call(bytes, function (n) {
      return (n < 16 ? '0' : '') + n.toString(16)
    })
    .join('')
}

// Converts any value in [0...2^32-1] to an 8-character hex string
function uint32ToHex (val) {
  return (0x100000000 + val).toString(16).substring(1)
}

// For debugging: prints out hash state in the same format as the RFC
// sample computation exactly, so that you can diff
function debugPrint (label, arr, size) {
  let msg = '\n' + label + ' = '
  for (let i = 0; i < arr.length; i += 2) {
    if (size === 32) {
      msg += uint32ToHex(arr[i]).toUpperCase()
      msg += ' '
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
    } else if (size === 64) {
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
      msg += uint32ToHex(arr[i]).toUpperCase()
    } else throw new Error('Invalid size ' + size)
    if (i % 6 === 4) {
      msg += '\n' + new Array(label.length + 4).join(' ')
    } else if (i < arr.length - 2) {
      msg += ' '
    }
  }
  console.log(msg)
}

// For performance testing: generates N bytes of input, hashes M times
// Measures and prints MB/second hash performance each time
function testSpeed (hashFn, N, M) {
  let startMs = new Date().getTime()

  const input = new Uint8Array(N)
  for (let i = 0; i < N; i++) {
    input[i] = i % 256
  }
  const genMs = new Date().getTime()
  console.log('Generated random input in ' + (genMs - startMs) + 'ms')
  startMs = genMs

  for (let i = 0; i < M; i++) {
    const hashHex = hashFn(input)
    const hashMs = new Date().getTime()
    const ms = hashMs - startMs
    startMs = hashMs
    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...')
    console.log(
      Math.round((N / (1 << 20) / (ms / 1000)) * 100) / 100 + ' MB PER SECOND'
    )
  }
}

module.exports = {
  normalizeInput: normalizeInput,
  toHex: toHex,
  debugPrint: debugPrint,
  testSpeed: testSpeed
}


/***/ }),

/***/ 833:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__833__;

/***/ }),

/***/ 974:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPrototypeOf = __webpack_require__(8280);
var flags = __webpack_require__(8804);

var RegExpPrototype = RegExp.prototype;

module.exports = function (it) {
  return (it === RegExpPrototype || isPrototypeOf(RegExpPrototype, it)) ? flags(it) : it.flags;
};


/***/ }),

/***/ 1081:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__1081__;

/***/ }),

/***/ 1091:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(5951);
var apply = __webpack_require__(6024);
var uncurryThis = __webpack_require__(2361);
var isCallable = __webpack_require__(2250);
var getOwnPropertyDescriptor = (__webpack_require__(3846).f);
var isForced = __webpack_require__(7463);
var path = __webpack_require__(2046);
var bind = __webpack_require__(8311);
var createNonEnumerableProperty = __webpack_require__(1626);
var hasOwn = __webpack_require__(9724);
// add debugging info
__webpack_require__(6128);

var wrapConstructor = function (NativeConstructor) {
  var Wrapper = function (a, b, c) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0: return new NativeConstructor();
        case 1: return new NativeConstructor(a);
        case 2: return new NativeConstructor(a, b);
      } return new NativeConstructor(a, b, c);
    } return apply(NativeConstructor, this, arguments);
  };
  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;

  var nativeSource = GLOBAL ? globalThis : STATIC ? globalThis[TARGET] : globalThis[TARGET] && globalThis[TARGET].prototype;

  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;

  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

  for (key in source) {
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contains in native
    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);

    targetProperty = target[key];

    if (USE_NATIVE) if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(nativeSource, key);
      nativeProperty = descriptor && descriptor.value;
    } else nativeProperty = nativeSource[key];

    // export native or implementation
    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];

    if (!FORCED && !PROTO && typeof targetProperty == typeof sourceProperty) continue;

    // bind methods to global for calling from export context
    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, globalThis);
    // wrap global constructors for prevent changes in this version
    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
    // make static versions for prototype methods
    else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
    // default case
    else resultProperty = sourceProperty;

    // add a flag to not completely full polyfills
    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(resultProperty, 'sham', true);
    }

    createNonEnumerableProperty(target, key, resultProperty);

    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
      }
      // export virtual prototype methods
      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
      // export real prototype methods
      if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
        createNonEnumerableProperty(targetPrototype, key, sourceProperty);
      }
    }
  }
};


/***/ }),

/***/ 1175:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(9846);

module.exports = NATIVE_SYMBOL &&
  !Symbol.sham &&
  typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 1176:
/***/ ((module) => {

"use strict";

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 1234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Symbol = __webpack_require__(3071);
var _Symbol$iterator = __webpack_require__(4473);
function _typeof(o) {
  "@babel/helpers - typeof";

  return module.exports = _typeof = "function" == typeof _Symbol && "symbol" == typeof _Symbol$iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof _Symbol && o.constructor === _Symbol && o !== _Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 1372:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.metadata` well-known symbol
// https://github.com/tc39/proposal-decorators
defineWellKnownSymbol('metadata');


/***/ }),

/***/ 1470:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(1907);
var toIntegerOrInfinity = __webpack_require__(5482);
var toString = __webpack_require__(160);
var requireObjectCoercible = __webpack_require__(4239);

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ 1505:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(8828);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 1626:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(9447);
var definePropertyModule = __webpack_require__(4284);
var createPropertyDescriptor = __webpack_require__(5817);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 1655:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__1655__;

/***/ }),

/***/ 1660:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.species` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.species
defineWellKnownSymbol('species');


/***/ }),

/***/ 1661:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(8537);
__webpack_require__(3669);
var WrappedWellKnownSymbolModule = __webpack_require__(560);

module.exports = WrappedWellKnownSymbolModule.f('toPrimitive');


/***/ }),

/***/ 1697:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.customMatcher` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('customMatcher');


/***/ }),

/***/ 1730:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(9363);
__webpack_require__(3643);
__webpack_require__(7057);
__webpack_require__(4954);
var WrappedWellKnownSymbolModule = __webpack_require__(560);

module.exports = WrappedWellKnownSymbolModule.f('iterator');


/***/ }),

/***/ 1785:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(1091);
var isWellKnownSymbol = __webpack_require__(9197);

// `Symbol.isWellKnownSymbol` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol
// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected
$({ target: 'Symbol', stat: true, forced: true }, {
  isWellKnownSymbol: isWellKnownSymbol
});


/***/ }),

/***/ 1793:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(5807);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ 1871:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(1907);
var aCallable = __webpack_require__(2159);

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ 1891:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__1891__;

/***/ }),

/***/ 1907:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(1505);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 1926:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(6750);
var path = __webpack_require__(2046);

var Object = path.Object;

var defineProperty = module.exports = function defineProperty(it, key, desc) {
  return Object.defineProperty(it, key, desc);
};

if (Object.defineProperty.sham) defineProperty.sham = true;


/***/ }),

/***/ 2017:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(9023);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(6698);
}


/***/ }),

/***/ 2046:
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ 2156:
/***/ ((module) => {

"use strict";

module.exports = function () { /* empty */ };


/***/ }),

/***/ 2159:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(2250);
var tryToString = __webpack_require__(4640);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 2220:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(9447);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(8661);
var definePropertyModule = __webpack_require__(4284);
var anObject = __webpack_require__(6624);
var toIndexedObject = __webpack_require__(7374);
var objectKeys = __webpack_require__(2875);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ 2230:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.replace` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.replace
defineWellKnownSymbol('replace');


/***/ }),

/***/ 2231:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(9692);

module.exports = parent;


/***/ }),

/***/ 2250:
/***/ ((module) => {

"use strict";

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 2321:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(7264);
__webpack_require__(3939);
__webpack_require__(1785);
__webpack_require__(1697);
__webpack_require__(4664);
// TODO: Remove from `core-js@4`
__webpack_require__(3422);
__webpack_require__(36);
__webpack_require__(8703);
__webpack_require__(6878);
__webpack_require__(9671);
__webpack_require__(359);

module.exports = parent;


/***/ }),

/***/ 2361:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classofRaw = __webpack_require__(5807);
var uncurryThis = __webpack_require__(1907);

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ 2416:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(5582);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 2522:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var shared = __webpack_require__(5816);
var uid = __webpack_require__(6499);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 2532:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(5951);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    globalThis[key] = value;
  } return value;
};


/***/ }),

/***/ 2560:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(9363);
var DOMIterables = __webpack_require__(9287);
var globalThis = __webpack_require__(5951);
var setToStringTag = __webpack_require__(4840);
var Iterators = __webpack_require__(3742);

for (var COLLECTION_NAME in DOMIterables) {
  setToStringTag(globalThis[COLLECTION_NAME], COLLECTION_NAME);
  Iterators[COLLECTION_NAME] = Iterators.Array;
}


/***/ }),

/***/ 2574:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 2595:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(5582);
var uncurryThis = __webpack_require__(1907);

var Symbol = getBuiltIn('Symbol');
var keyFor = Symbol.keyFor;
var thisSymbolValue = uncurryThis(Symbol.prototype.valueOf);

// `Symbol.isRegisteredSymbol` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol
module.exports = Symbol.isRegisteredSymbol || function isRegisteredSymbol(value) {
  try {
    return keyFor(thisSymbolValue(value)) !== undefined;
  } catch (error) {
    return false;
  }
};


/***/ }),

/***/ 2596:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.hasInstance` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.hasinstance
defineWellKnownSymbol('hasInstance');


/***/ }),

/***/ 2623:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(6264);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 2647:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(1907);
var isCallable = __webpack_require__(2250);
var store = __webpack_require__(6128);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 2730:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(4055);

/***/ }),

/***/ 2853:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__2853__;

/***/ }),

/***/ 2861:
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(18)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 2875:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(3045);
var enumBugKeys = __webpack_require__(376);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 3045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(1907);
var hasOwn = __webpack_require__(9724);
var toIndexedObject = __webpack_require__(7374);
var indexOf = (__webpack_require__(4436).indexOf);
var hiddenKeys = __webpack_require__(8530);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 3071:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(2321);


/***/ }),

/***/ 3121:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(5482);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 3313:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(1091);
var getBuiltIn = __webpack_require__(5582);
var hasOwn = __webpack_require__(9724);
var toString = __webpack_require__(160);
var shared = __webpack_require__(5816);
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(4411);

var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.for` method
// https://tc39.es/ecma262/#sec-symbol.for
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  'for': function (key) {
    var string = toString(key);
    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = getBuiltIn('Symbol')(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  }
});


/***/ }),

/***/ 3325:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.unscopables` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.unscopables
defineWellKnownSymbol('unscopables');


/***/ }),

/***/ 3377:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.matchAll` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.matchall
defineWellKnownSymbol('matchAll');


/***/ }),

/***/ 3422:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(1091);
var isRegisteredSymbol = __webpack_require__(2595);

// `Symbol.isRegistered` method
// obsolete version of https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol
$({ target: 'Symbol', stat: true, name: 'isRegisteredSymbol' }, {
  isRegistered: isRegisteredSymbol
});


/***/ }),

/***/ 3427:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(1907);

module.exports = uncurryThis([].slice);


/***/ }),

/***/ 3467:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(3930);
var getBuiltIn = __webpack_require__(5582);
var wellKnownSymbol = __webpack_require__(6264);
var defineBuiltIn = __webpack_require__(8055);

module.exports = function () {
  var Symbol = getBuiltIn('Symbol');
  var SymbolPrototype = Symbol && Symbol.prototype;
  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
    // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
    // eslint-disable-next-line no-unused-vars -- required for .length
    defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function (hint) {
      return call(valueOf, this);
    }, { arity: 1 });
  }
};


/***/ }),

/***/ 3643:
/***/ (() => {

// empty


/***/ }),

/***/ 3648:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(9447);
var fails = __webpack_require__(8828);
var createElement = __webpack_require__(9552);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ 3669:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);
var defineSymbolToPrimitive = __webpack_require__(3467);

// `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();


/***/ }),

/***/ 3674:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(1091);
var globalThis = __webpack_require__(5951);
var call = __webpack_require__(3930);
var uncurryThis = __webpack_require__(1907);
var IS_PURE = __webpack_require__(7376);
var DESCRIPTORS = __webpack_require__(9447);
var NATIVE_SYMBOL = __webpack_require__(9846);
var fails = __webpack_require__(8828);
var hasOwn = __webpack_require__(9724);
var isPrototypeOf = __webpack_require__(8280);
var anObject = __webpack_require__(6624);
var toIndexedObject = __webpack_require__(7374);
var toPropertyKey = __webpack_require__(470);
var $toString = __webpack_require__(160);
var createPropertyDescriptor = __webpack_require__(5817);
var nativeObjectCreate = __webpack_require__(8075);
var objectKeys = __webpack_require__(2875);
var getOwnPropertyNamesModule = __webpack_require__(4443);
var getOwnPropertyNamesExternal = __webpack_require__(5407);
var getOwnPropertySymbolsModule = __webpack_require__(7170);
var getOwnPropertyDescriptorModule = __webpack_require__(3846);
var definePropertyModule = __webpack_require__(4284);
var definePropertiesModule = __webpack_require__(2220);
var propertyIsEnumerableModule = __webpack_require__(2574);
var defineBuiltIn = __webpack_require__(8055);
var defineBuiltInAccessor = __webpack_require__(9251);
var shared = __webpack_require__(5816);
var sharedKey = __webpack_require__(2522);
var hiddenKeys = __webpack_require__(8530);
var uid = __webpack_require__(6499);
var wellKnownSymbol = __webpack_require__(6264);
var wrappedWellKnownSymbolModule = __webpack_require__(560);
var defineWellKnownSymbol = __webpack_require__(366);
var defineSymbolToPrimitive = __webpack_require__(3467);
var setToStringTag = __webpack_require__(4840);
var InternalStateModule = __webpack_require__(4932);
var $forEach = (__webpack_require__(726).forEach);

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);

var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = globalThis.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var RangeError = globalThis.RangeError;
var TypeError = globalThis.TypeError;
var QObject = globalThis.QObject;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push = uncurryThis([].push);

var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');

// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var fallbackDefineProperty = function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
};

var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a !== 7;
}) ? fallbackDefineProperty : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPropertyKey(P);
  anObject(Attributes);
  if (hasOwn(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
    ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function (O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
      push(result, AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf(SymbolPrototype, this)) throw new TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      var $this = this === undefined ? globalThis : this;
      if ($this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
      if (hasOwn($this, HIDDEN) && hasOwn($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
      var descriptor = createPropertyDescriptor(1, value);
      try {
        setSymbolDescriptor($this, tag, descriptor);
      } catch (error) {
        if (!(error instanceof RangeError)) throw error;
        fallbackDefineProperty($this, tag, descriptor);
      }
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];

  defineBuiltIn(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });

  defineBuiltIn($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    defineBuiltInAccessor(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ 3742:
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ 3842:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(8545);
__webpack_require__(3643);
__webpack_require__(4452);
__webpack_require__(3997);
__webpack_require__(5084);
__webpack_require__(2596);
__webpack_require__(5721);
__webpack_require__(4954);
__webpack_require__(4123);
__webpack_require__(3377);
__webpack_require__(2230);
__webpack_require__(5344);
__webpack_require__(1660);
__webpack_require__(4610);
__webpack_require__(3669);
__webpack_require__(4810);
__webpack_require__(3325);
__webpack_require__(7024);
__webpack_require__(8172);
__webpack_require__(5205);
var path = __webpack_require__(2046);

module.exports = path.Symbol;


/***/ }),

/***/ 3846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(9447);
var call = __webpack_require__(3930);
var propertyIsEnumerableModule = __webpack_require__(2574);
var createPropertyDescriptor = __webpack_require__(5817);
var toIndexedObject = __webpack_require__(7374);
var toPropertyKey = __webpack_require__(470);
var hasOwn = __webpack_require__(9724);
var IE8_DOM_DEFINE = __webpack_require__(3648);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 3930:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(1505);

var call = Function.prototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 3939:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(1091);
var isRegisteredSymbol = __webpack_require__(2595);

// `Symbol.isRegisteredSymbol` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol
$({ target: 'Symbol', stat: true }, {
  isRegisteredSymbol: isRegisteredSymbol
});


/***/ }),

/***/ 3948:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(2623);
var isCallable = __webpack_require__(2250);
var classofRaw = __webpack_require__(5807);
var wellKnownSymbol = __webpack_require__(6264);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 3997:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');


/***/ }),

/***/ 4010:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isArray = __webpack_require__(1793);
var isConstructor = __webpack_require__(5468);
var isObject = __webpack_require__(6285);
var wellKnownSymbol = __webpack_require__(6264);

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};


/***/ }),

/***/ 4018:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(6285);

module.exports = function (argument) {
  return isObject(argument) || argument === null;
};


/***/ }),

/***/ 4055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(974);

module.exports = parent;


/***/ }),

/***/ 4107:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(2017)
var Hash = __webpack_require__(392)
var Buffer = (__webpack_require__(2861).Buffer)

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ 4123:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.match` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.match
defineWellKnownSymbol('match');


/***/ }),

/***/ 4139:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(3842);
__webpack_require__(2560);

module.exports = parent;


/***/ }),

/***/ 4146:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__4146__;

/***/ }),

/***/ 4156:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Blake2B in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch

const util = __webpack_require__(829)

// 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array
function ADD64AA (v, a, b) {
  const o0 = v[a] + v[b]
  let o1 = v[a + 1] + v[b + 1]
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits
function ADD64AC (v, a, b0, b1) {
  let o0 = v[a] + b0
  if (b0 < 0) {
    o0 += 0x100000000
  }
  let o1 = v[a + 1] + b1
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// Little-endian byte access
function B2B_GET32 (arr, i) {
  return arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24)
}

// G Mixing function
// The ROTRs are inlined for speed
function B2B_G (a, b, c, d, ix, iy) {
  const x0 = m[ix]
  const x1 = m[ix + 1]
  const y0 = m[iy]
  const y1 = m[iy + 1]

  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
  let xor0 = v[d] ^ v[a]
  let xor1 = v[d + 1] ^ v[a + 1]
  v[d] = xor1
  v[d + 1] = xor0

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor0 >>> 24) ^ (xor1 << 8)
  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)

  ADD64AA(v, a, b)
  ADD64AC(v, a, y0, y1)

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
  xor0 = v[d] ^ v[a]
  xor1 = v[d + 1] ^ v[a + 1]
  v[d] = (xor0 >>> 16) ^ (xor1 << 16)
  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor1 >>> 31) ^ (xor0 << 1)
  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)
}

// Initialization Vector
const BLAKE2B_IV32 = new Uint32Array([
  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372,
  0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c,
  0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19
])

const SIGMA8 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13,
  6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1,
  9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4,
  10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5,
  15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7,
  14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2,
  13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0,
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6,
  1, 12, 0, 2, 11, 7, 5, 3
]

// These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s
const SIGMA82 = new Uint8Array(
  SIGMA8.map(function (x) {
    return x * 2
  })
)

// Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s
const v = new Uint32Array(32)
const m = new Uint32Array(32)
function blake2bCompress (ctx, last) {
  let i = 0

  // init work variables
  for (i = 0; i < 16; i++) {
    v[i] = ctx.h[i]
    v[i + 16] = BLAKE2B_IV32[i]
  }

  // low 64 bits of offset
  v[24] = v[24] ^ ctx.t
  v[25] = v[25] ^ (ctx.t / 0x100000000)
  // high 64 bits not supported, offset may not be higher than 2**53-1

  // last block flag set ?
  if (last) {
    v[28] = ~v[28]
    v[29] = ~v[29]
  }

  // get little-endian words
  for (i = 0; i < 32; i++) {
    m[i] = B2B_GET32(ctx.b, 4 * i)
  }

  // twelve rounds of mixing
  // uncomment the DebugPrint calls to log the computation
  // and match the RFC sample documentation
  // util.debugPrint('          m[16]', m, 64)
  for (i = 0; i < 12; i++) {
    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])
    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])
    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])
    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])
    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])
    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])
    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])
    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])
  }
  // util.debugPrint('   (i=12) v[16]', v, 64)

  for (i = 0; i < 16; i++) {
    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]
  }
  // util.debugPrint('h[8]', ctx.h, 64)
}

// reusable parameterBlock
const parameterBlock = new Uint8Array([
  0,
  0,
  0,
  0, //  0: outlen, keylen, fanout, depth
  0,
  0,
  0,
  0, //  4: leaf length, sequential mode
  0,
  0,
  0,
  0, //  8: node offset
  0,
  0,
  0,
  0, // 12: node offset
  0,
  0,
  0,
  0, // 16: node depth, inner length, rfu
  0,
  0,
  0,
  0, // 20: rfu
  0,
  0,
  0,
  0, // 24: rfu
  0,
  0,
  0,
  0, // 28: rfu
  0,
  0,
  0,
  0, // 32: salt
  0,
  0,
  0,
  0, // 36: salt
  0,
  0,
  0,
  0, // 40: salt
  0,
  0,
  0,
  0, // 44: salt
  0,
  0,
  0,
  0, // 48: personal
  0,
  0,
  0,
  0, // 52: personal
  0,
  0,
  0,
  0, // 56: personal
  0,
  0,
  0,
  0 // 60: personal
])

// Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key
// Takes an optinal Uint8Array salt
// Takes an optinal Uint8Array personal
function blake2bInit (outlen, key, salt, personal) {
  if (outlen === 0 || outlen > 64) {
    throw new Error('Illegal output length, expected 0 < length <= 64')
  }
  if (key && key.length > 64) {
    throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')
  }
  if (salt && salt.length !== 16) {
    throw new Error('Illegal salt, expected Uint8Array with length is 16')
  }
  if (personal && personal.length !== 16) {
    throw new Error('Illegal personal, expected Uint8Array with length is 16')
  }

  // state, 'param block'
  const ctx = {
    b: new Uint8Array(128),
    h: new Uint32Array(16),
    t: 0, // input count
    c: 0, // pointer within buffer
    outlen: outlen // output length in bytes
  }

  // initialize parameterBlock before usage
  parameterBlock.fill(0)
  parameterBlock[0] = outlen
  if (key) parameterBlock[1] = key.length
  parameterBlock[2] = 1 // fanout
  parameterBlock[3] = 1 // depth
  if (salt) parameterBlock.set(salt, 32)
  if (personal) parameterBlock.set(personal, 48)

  // initialize hash state
  for (let i = 0; i < 16; i++) {
    ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4)
  }

  // key the hash, if applicable
  if (key) {
    blake2bUpdate(ctx, key)
    // at the end
    ctx.c = 128
  }

  return ctx
}

// Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2bUpdate (ctx, input) {
  for (let i = 0; i < input.length; i++) {
    if (ctx.c === 128) {
      // buffer full ?
      ctx.t += ctx.c // add counters
      blake2bCompress(ctx, false) // compress (not last)
      ctx.c = 0 // counter to zero
    }
    ctx.b[ctx.c++] = input[i]
  }
}

// Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest
function blake2bFinal (ctx) {
  ctx.t += ctx.c // mark last block offset

  while (ctx.c < 128) {
    // fill up with zeros
    ctx.b[ctx.c++] = 0
  }
  blake2bCompress(ctx, true) // final block flag = 1

  // little endian convert and store
  const out = new Uint8Array(ctx.outlen)
  for (let i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))
  }
  return out
}

// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
// - salt - optional salt bytes, string, Buffer or Uint8Array
// - personal - optional personal bytes, string, Buffer or Uint8Array
function blake2b (input, key, outlen, salt, personal) {
  // preprocess inputs
  outlen = outlen || 64
  input = util.normalizeInput(input)
  if (salt) {
    salt = util.normalizeInput(salt)
  }
  if (personal) {
    personal = util.normalizeInput(personal)
  }

  // do the math
  const ctx = blake2bInit(outlen, key, salt, personal)
  blake2bUpdate(ctx, input)
  return blake2bFinal(ctx)
}

// Computes the BLAKE2B hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
// - salt - optional salt bytes, string, Buffer or Uint8Array
// - personal - optional personal bytes, string, Buffer or Uint8Array
function blake2bHex (input, key, outlen, salt, personal) {
  const output = blake2b(input, key, outlen, salt, personal)
  return util.toHex(output)
}

module.exports = {
  blake2b: blake2b,
  blake2bHex: blake2bHex,
  blake2bInit: blake2bInit,
  blake2bUpdate: blake2bUpdate,
  blake2bFinal: blake2bFinal
}


/***/ }),

/***/ 4239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isNullOrUndefined = __webpack_require__(7136);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 4284:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(9447);
var IE8_DOM_DEFINE = __webpack_require__(3648);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(8661);
var anObject = __webpack_require__(6624);
var toPropertyKey = __webpack_require__(470);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 4411:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_SYMBOL = __webpack_require__(9846);

/* eslint-disable es/no-symbol -- safe */
module.exports = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;


/***/ }),

/***/ 4436:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(7374);
var toAbsoluteIndex = __webpack_require__(4849);
var lengthOfArrayLike = __webpack_require__(575);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 4443:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(3045);
var enumBugKeys = __webpack_require__(376);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 4452:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(3674);
__webpack_require__(3313);
__webpack_require__(751);
__webpack_require__(9721);
__webpack_require__(5264);


/***/ }),

/***/ 4473:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(2231);


/***/ }),

/***/ 4578:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__4578__;

/***/ }),

/***/ 4610:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.split` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.split
defineWellKnownSymbol('split');


/***/ }),

/***/ 4640:
/***/ ((module) => {

"use strict";

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 4664:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.observable` well-known symbol
// https://github.com/tc39/proposal-observable
defineWellKnownSymbol('observable');


/***/ }),

/***/ 4704:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(1234)["default"]);
var toPrimitive = __webpack_require__(6973);
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 4810:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(5582);
var defineWellKnownSymbol = __webpack_require__(366);
var setToStringTag = __webpack_require__(4840);

// `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag(getBuiltIn('Symbol'), 'Symbol');


/***/ }),

/***/ 4840:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(2623);
var defineProperty = (__webpack_require__(4284).f);
var createNonEnumerableProperty = __webpack_require__(1626);
var hasOwn = __webpack_require__(9724);
var toString = __webpack_require__(4878);
var wellKnownSymbol = __webpack_require__(6264);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC, SET_METHOD) {
  var target = STATIC ? it : it && it.prototype;
  if (target) {
    if (!hasOwn(target, TO_STRING_TAG)) {
      defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
    }
    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
      createNonEnumerableProperty(target, 'toString', toString);
    }
  }
};


/***/ }),

/***/ 4849:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(5482);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 4878:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(2623);
var classof = __webpack_require__(3948);

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ 4932:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_WEAK_MAP = __webpack_require__(551);
var globalThis = __webpack_require__(5951);
var isObject = __webpack_require__(6285);
var createNonEnumerableProperty = __webpack_require__(1626);
var hasOwn = __webpack_require__(9724);
var shared = __webpack_require__(6128);
var sharedKey = __webpack_require__(2522);
var hiddenKeys = __webpack_require__(8530);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = globalThis.TypeError;
var WeakMap = globalThis.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 4954:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ 4997:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(6040);

module.exports = parent;


/***/ }),

/***/ 5084:
/***/ (() => {

// empty


/***/ }),

/***/ 5116:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(8828);
var isCallable = __webpack_require__(2250);
var isObject = __webpack_require__(6285);
var create = __webpack_require__(8075);
var getPrototypeOf = __webpack_require__(5972);
var defineBuiltIn = __webpack_require__(8055);
var wellKnownSymbol = __webpack_require__(6264);
var IS_PURE = __webpack_require__(7376);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ 5196:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__5196__;

/***/ }),

/***/ 5205:
/***/ (() => {

// empty


/***/ }),

/***/ 5264:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(1091);
var NATIVE_SYMBOL = __webpack_require__(9846);
var fails = __webpack_require__(8828);
var getOwnPropertySymbolsModule = __webpack_require__(7170);
var toObject = __webpack_require__(9298);

// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FORCED = !NATIVE_SYMBOL || fails(function () { getOwnPropertySymbolsModule.f(1); });

// `Object.getOwnPropertySymbols` method
// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
$({ target: 'Object', stat: true, forced: FORCED }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
  }
});


/***/ }),

/***/ 5344:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.search` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.search
defineWellKnownSymbol('search');


/***/ }),

/***/ 5407:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof = __webpack_require__(5807);
var toIndexedObject = __webpack_require__(7374);
var $getOwnPropertyNames = (__webpack_require__(4443).f);
var arraySlice = __webpack_require__(3427);

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) === 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ 5468:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(1907);
var fails = __webpack_require__(8828);
var isCallable = __webpack_require__(2250);
var classof = __webpack_require__(3948);
var getBuiltIn = __webpack_require__(5582);
var inspectSource = __webpack_require__(2647);

var noop = function () { /* empty */ };
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.test(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, [], argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ 5482:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var trunc = __webpack_require__(1176);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 5543:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(9447);
var definePropertyModule = __webpack_require__(4284);
var createPropertyDescriptor = __webpack_require__(5817);

module.exports = function (object, key, value) {
  if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
  else object[key] = value;
};


/***/ }),

/***/ 5582:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var path = __webpack_require__(2046);
var globalThis = __webpack_require__(5951);
var isCallable = __webpack_require__(2250);

var aFunction = function (variable) {
  return isCallable(variable) ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(globalThis[namespace])
    : path[namespace] && path[namespace][method] || globalThis[namespace] && globalThis[namespace][method];
};


/***/ }),

/***/ 5594:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(5582);
var isCallable = __webpack_require__(2250);
var isPrototypeOf = __webpack_require__(8280);
var USE_SYMBOL_AS_UID = __webpack_require__(1175);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 5606:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(6624);

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.hasIndices) result += 'd';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.unicodeSets) result += 'v';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ 5663:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(70);

module.exports = parent;


/***/ }),

/***/ 5721:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable
defineWellKnownSymbol('isConcatSpreadable');


/***/ }),

/***/ 5807:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(1907);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 5816:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var store = __webpack_require__(6128);

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ }),

/***/ 5817:
/***/ ((module) => {

"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 5951:
/***/ (function(module) {

"use strict";

var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 5972:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var hasOwn = __webpack_require__(9724);
var isCallable = __webpack_require__(2250);
var toObject = __webpack_require__(9298);
var sharedKey = __webpack_require__(2522);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(7382);

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 6016:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__6016__;

/***/ }),

/***/ 6024:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(1505);

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-function-prototype-bind, es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ 6028:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(3930);
var isObject = __webpack_require__(6285);
var isSymbol = __webpack_require__(5594);
var getMethod = __webpack_require__(9367);
var ordinaryToPrimitive = __webpack_require__(581);
var wellKnownSymbol = __webpack_require__(6264);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 6040:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(8251);

module.exports = parent;


/***/ }),

/***/ 6128:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IS_PURE = __webpack_require__(7376);
var globalThis = __webpack_require__(5951);
var defineGlobalProperty = __webpack_require__(2532);

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.41.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2014-2025 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.41.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 6168:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__6168__;

/***/ }),

/***/ 6264:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(5951);
var shared = __webpack_require__(5816);
var hasOwn = __webpack_require__(9724);
var uid = __webpack_require__(6499);
var NATIVE_SYMBOL = __webpack_require__(9846);
var USE_SYMBOL_AS_UID = __webpack_require__(1175);

var Symbol = globalThis.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 6285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(2250);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 6499:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(1907);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 6514:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__6514__;

/***/ }),

/***/ 6624:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(6285);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 6656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(1907);
var isArray = __webpack_require__(1793);
var isCallable = __webpack_require__(2250);
var classof = __webpack_require__(5807);
var toString = __webpack_require__(160);

var push = uncurryThis([].push);

module.exports = function (replacer) {
  if (isCallable(replacer)) return replacer;
  if (!isArray(replacer)) return;
  var rawLength = replacer.length;
  var keys = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer[i];
    if (typeof element == 'string') push(keys, element);
    else if (typeof element == 'number' || classof(element) === 'Number' || classof(element) === 'String') push(keys, toString(element));
  }
  var keysLength = keys.length;
  var root = true;
  return function (key, value) {
    if (root) {
      root = false;
      return value;
    }
    if (isArray(this)) return value;
    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
  };
};


/***/ }),

/***/ 6698:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 6750:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(1091);
var DESCRIPTORS = __webpack_require__(9447);
var defineProperty = (__webpack_require__(4284).f);

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es/no-object-defineproperty -- safe
$({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
  defineProperty: defineProperty
});


/***/ }),

/***/ 6794:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(5951);

var navigator = globalThis.navigator;
var userAgent = navigator && navigator.userAgent;

module.exports = userAgent ? String(userAgent) : '';


/***/ }),

/***/ 6833:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(9447);
var hasOwn = __webpack_require__(9724);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 6878:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.metadataKey` well-known symbol
// https://github.com/tc39/proposal-decorator-metadata
defineWellKnownSymbol('metadataKey');


/***/ }),

/***/ 6946:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(1907);
var fails = __webpack_require__(8828);
var classof = __webpack_require__(5807);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 6968:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var arraySpeciesConstructor = __webpack_require__(4010);

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ 6973:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Symbol$toPrimitive = __webpack_require__(8130);
var _typeof = (__webpack_require__(1234)["default"]);
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[_Symbol$toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 7016:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 7024:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(5951);
var setToStringTag = __webpack_require__(4840);

// JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag
setToStringTag(globalThis.JSON, 'JSON', true);


/***/ }),

/***/ 7045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(1730);
__webpack_require__(2560);

module.exports = parent;


/***/ }),

/***/ 7057:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var charAt = (__webpack_require__(1470).charAt);
var toString = __webpack_require__(160);
var InternalStateModule = __webpack_require__(4932);
var defineIterator = __webpack_require__(183);
var createIterResultObject = __webpack_require__(9550);

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject(undefined, true);
  point = charAt(string, index);
  state.index += point.length;
  return createIterResultObject(point, false);
});


/***/ }),

/***/ 7136:
/***/ ((module) => {

"use strict";

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 7152:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.dispose` well-known symbol
// https://github.com/tc39/proposal-explicit-resource-management
defineWellKnownSymbol('dispose');


/***/ }),

/***/ 7170:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 7171:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(8828);
var wellKnownSymbol = __webpack_require__(6264);
var V8_VERSION = __webpack_require__(798);

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ 7181:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IteratorPrototype = (__webpack_require__(5116).IteratorPrototype);
var create = __webpack_require__(8075);
var createPropertyDescriptor = __webpack_require__(5817);
var setToStringTag = __webpack_require__(4840);
var Iterators = __webpack_require__(3742);

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ 7250:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__7250__;

/***/ }),

/***/ 7264:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(4139);

__webpack_require__(768);
__webpack_require__(8549);
__webpack_require__(7152);
__webpack_require__(1372);

module.exports = parent;


/***/ }),

/***/ 7374:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(6946);
var requireObjectCoercible = __webpack_require__(4239);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 7376:
/***/ ((module) => {

"use strict";

module.exports = true;


/***/ }),

/***/ 7382:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(8828);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 7463:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(8828);
var isCallable = __webpack_require__(2250);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 8024:
/***/ ((module) => {

"use strict";

var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ 8055:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createNonEnumerableProperty = __webpack_require__(1626);

module.exports = function (target, key, value, options) {
  if (options && options.enumerable) target[key] = value;
  else createNonEnumerableProperty(target, key, value);
  return target;
};


/***/ }),

/***/ 8075:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(6624);
var definePropertiesModule = __webpack_require__(2220);
var enumBugKeys = __webpack_require__(376);
var hiddenKeys = __webpack_require__(8530);
var html = __webpack_require__(2416);
var documentCreateElement = __webpack_require__(9552);
var sharedKey = __webpack_require__(2522);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  // eslint-disable-next-line no-useless-assignment -- avoid memory leak
  activeXDocument = null;
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ 8130:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(9280);


/***/ }),

/***/ 8172:
/***/ (() => {

// empty


/***/ }),

/***/ 8251:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(1926);

module.exports = parent;


/***/ }),

/***/ 8280:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(1907);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 8311:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(2361);
var aCallable = __webpack_require__(2159);
var NATIVE_BIND = __webpack_require__(1505);

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 8380:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__8380__;

/***/ }),

/***/ 8530:
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ 8537:
/***/ (() => {

// empty


/***/ }),

/***/ 8545:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(1091);
var fails = __webpack_require__(8828);
var isArray = __webpack_require__(1793);
var isObject = __webpack_require__(6285);
var toObject = __webpack_require__(9298);
var lengthOfArrayLike = __webpack_require__(575);
var doesNotExceedSafeInteger = __webpack_require__(8024);
var createProperty = __webpack_require__(5543);
var arraySpeciesCreate = __webpack_require__(6968);
var arrayMethodHasSpeciesSupport = __webpack_require__(7171);
var wellKnownSymbol = __webpack_require__(6264);
var V8_VERSION = __webpack_require__(798);

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ 8549:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.asyncDispose` well-known symbol
// https://github.com/tc39/proposal-async-explicit-resource-management
defineWellKnownSymbol('asyncDispose');


/***/ }),

/***/ 8661:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(9447);
var fails = __webpack_require__(8828);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ 8703:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.matcher` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('matcher');


/***/ }),

/***/ 8804:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(9164);
var getRegExpFlags = __webpack_require__(663);

module.exports = getRegExpFlags;


/***/ }),

/***/ 8828:
/***/ ((module) => {

"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 8963:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__8963__;

/***/ }),

/***/ 9023:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 9164:
/***/ (() => {

// empty


/***/ }),

/***/ 9192:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(1871);
var isObject = __webpack_require__(6285);
var requireObjectCoercible = __webpack_require__(4239);
var aPossiblePrototype = __webpack_require__(43);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    requireObjectCoercible(O);
    aPossiblePrototype(proto);
    if (!isObject(O)) return O;
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 9197:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var shared = __webpack_require__(5816);
var getBuiltIn = __webpack_require__(5582);
var uncurryThis = __webpack_require__(1907);
var isSymbol = __webpack_require__(5594);
var wellKnownSymbol = __webpack_require__(6264);

var Symbol = getBuiltIn('Symbol');
var $isWellKnownSymbol = Symbol.isWellKnownSymbol;
var getOwnPropertyNames = getBuiltIn('Object', 'getOwnPropertyNames');
var thisSymbolValue = uncurryThis(Symbol.prototype.valueOf);
var WellKnownSymbolsStore = shared('wks');

for (var i = 0, symbolKeys = getOwnPropertyNames(Symbol), symbolKeysLength = symbolKeys.length; i < symbolKeysLength; i++) {
  // some old engines throws on access to some keys like `arguments` or `caller`
  try {
    var symbolKey = symbolKeys[i];
    if (isSymbol(Symbol[symbolKey])) wellKnownSymbol(symbolKey);
  } catch (error) { /* empty */ }
}

// `Symbol.isWellKnownSymbol` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol
// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected
module.exports = function isWellKnownSymbol(value) {
  if ($isWellKnownSymbol && $isWellKnownSymbol(value)) return true;
  try {
    var symbol = thisSymbolValue(value);
    for (var j = 0, keys = getOwnPropertyNames(WellKnownSymbolsStore), keysLength = keys.length; j < keysLength; j++) {
      // eslint-disable-next-line eqeqeq -- polyfilled symbols case
      if (WellKnownSymbolsStore[keys[j]] == symbol) return true;
    }
  } catch (error) { /* empty */ }
  return false;
};


/***/ }),

/***/ 9251:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineProperty = __webpack_require__(4284);

module.exports = function (target, name, descriptor) {
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ 9280:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(5663);

module.exports = parent;


/***/ }),

/***/ 9287:
/***/ ((module) => {

"use strict";

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ 9298:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var requireObjectCoercible = __webpack_require__(4239);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 9363:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(7374);
var addToUnscopables = __webpack_require__(2156);
var Iterators = __webpack_require__(3742);
var InternalStateModule = __webpack_require__(4932);
var defineProperty = (__webpack_require__(4284).f);
var defineIterator = __webpack_require__(183);
var createIterResultObject = __webpack_require__(9550);
var IS_PURE = __webpack_require__(7376);
var DESCRIPTORS = __webpack_require__(9447);

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = null;
    return createIterResultObject(undefined, true);
  }
  switch (state.kind) {
    case 'keys': return createIterResultObject(index, false);
    case 'values': return createIterResultObject(target[index], false);
  } return createIterResultObject([index, target[index]], false);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
  defineProperty(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }


/***/ }),

/***/ 9367:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(2159);
var isNullOrUndefined = __webpack_require__(7136);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 9447:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(8828);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ 9550:
/***/ ((module) => {

"use strict";

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),

/***/ 9552:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(5951);
var isObject = __webpack_require__(6285);

var document = globalThis.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 9671:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: remove from `core-js@4`
var defineWellKnownSymbol = __webpack_require__(366);

// `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('patternMatch');


/***/ }),

/***/ 9692:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(7045);

module.exports = parent;


/***/ }),

/***/ 9721:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(1091);
var getBuiltIn = __webpack_require__(5582);
var apply = __webpack_require__(6024);
var call = __webpack_require__(3930);
var uncurryThis = __webpack_require__(1907);
var fails = __webpack_require__(8828);
var isCallable = __webpack_require__(2250);
var isSymbol = __webpack_require__(5594);
var arraySlice = __webpack_require__(3427);
var getReplacerFunction = __webpack_require__(6656);
var NATIVE_SYMBOL = __webpack_require__(9846);

var $String = String;
var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.0.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
  var symbol = getBuiltIn('Symbol')('stringify detection');
  // MS Edge converts symbol values to JSON as {}
  return $stringify([symbol]) !== '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({ a: symbol }) !== '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) !== '{}';
});

// https://github.com/tc39/proposal-well-formed-stringify
var ILL_FORMED_UNICODE = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

var stringifyWithSymbolsFix = function (it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = getReplacerFunction(replacer);
  if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return; // IE8 returns string on undefined
  args[1] = function (key, value) {
    // some old implementations (like WebKit) could pass numbers as keys
    if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
    if (!isSymbol(value)) return value;
  };
  return apply($stringify, null, args);
};

var fixIllFormed = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
    }
  });
}


/***/ }),

/***/ 9724:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(1907);
var toObject = __webpack_require__(9298);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 9846:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(798);
var fails = __webpack_require__(8828);
var globalThis = __webpack_require__(5951);

var $String = globalThis.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AE_AMOUNT_FORMATS: () => (/* reexport */ AE_AMOUNT_FORMATS),
  AbiVersion: () => (/* reexport */ AbiVersion),
  AccountBase: () => (/* reexport */ AccountBase),
  AccountError: () => (/* reexport */ AccountError),
  AccountGeneralized: () => (/* reexport */ AccountGeneralized),
  AccountLedger: () => (/* reexport */ AccountLedger),
  AccountLedgerFactory: () => (/* reexport */ AccountLedgerFactory),
  AccountMemory: () => (/* reexport */ AccountMemory),
  AccountMetamask: () => (/* reexport */ AccountMetamask),
  AccountMetamaskFactory: () => (/* reexport */ AccountMetamaskFactory),
  AccountMnemonicFactory: () => (/* reexport */ AccountMnemonicFactory),
  AeSdk: () => (/* reexport */ AeSdk),
  AeSdkAepp: () => (/* reexport */ AeSdkAepp),
  AeSdkBase: () => (/* reexport */ AeSdkBase),
  AeSdkMethods: () => (/* reexport */ src_AeSdkMethods),
  AeSdkWallet: () => (/* reexport */ AeSdkWallet),
  AensError: () => (/* reexport */ AensError),
  AensPointerContextError: () => (/* reexport */ AensPointerContextError),
  AeppError: () => (/* reexport */ AeppError),
  AlreadyConnectedError: () => (/* reexport */ AlreadyConnectedError),
  AmbiguousEventDefinitionError: () => (/* reexport */ AmbiguousEventDefinitionError),
  ArgumentCountMismatchError: () => (/* reexport */ ArgumentCountMismatchError),
  ArgumentError: () => (/* reexport */ ArgumentError),
  BaseError: () => (/* reexport */ BaseError),
  BrowserRuntimeConnection: () => (/* reexport */ BrowserRuntimeConnection),
  BrowserWindowMessageConnection: () => (/* reexport */ BrowserWindowMessageConnection),
  BytecodeMismatchError: () => (/* reexport */ BytecodeMismatchError),
  CallReturnType: () => (/* reexport */ CallReturnType),
  Channel: () => (/* reexport */ ChannelContract),
  ChannelCallError: () => (/* reexport */ ChannelCallError),
  ChannelConnectionError: () => (/* reexport */ ChannelConnectionError),
  ChannelError: () => (/* reexport */ ChannelError),
  ChannelIncomingMessageError: () => (/* reexport */ ChannelIncomingMessageError),
  ChannelPingTimedOutError: () => (/* reexport */ ChannelPingTimedOutError),
  CompilerBase: () => (/* reexport */ CompilerBase),
  CompilerCli: () => (/* reexport */ CompilerCli),
  CompilerError: () => (/* reexport */ CompilerError),
  CompilerHttp: () => (/* reexport */ CompilerHttp),
  CompilerHttpNode: () => (/* reexport */ CompilerHttpNode),
  ConsensusProtocolVersion: () => (/* reexport */ ConsensusProtocolVersion),
  Contract: () => (/* reexport */ contract_Contract),
  ContractError: () => (/* reexport */ ContractError),
  CryptographyError: () => (/* reexport */ CryptographyError),
  DRY_RUN_ACCOUNT: () => (/* reexport */ DRY_RUN_ACCOUNT),
  DecodeError: () => (/* reexport */ DecodeError),
  DelegationTag: () => (/* reexport */ DelegationTag),
  DryRunError: () => (/* reexport */ DryRunError),
  DuplicateContractError: () => (/* reexport */ DuplicateContractError),
  DuplicateNodeError: () => (/* reexport */ DuplicateNodeError),
  Encoded: () => (/* reexport */ encoder_types_namespaceObject),
  Encoding: () => (/* reexport */ Encoding),
  EntryTag: () => (/* reexport */ EntryTag),
  IllegalArgumentError: () => (/* reexport */ IllegalArgumentError),
  IllegalBidFeeError: () => (/* reexport */ IllegalBidFeeError),
  InactiveContractError: () => (/* reexport */ InactiveContractError),
  InsufficientBalanceError: () => (/* reexport */ InsufficientBalanceError),
  InsufficientNameFeeError: () => (/* reexport */ InsufficientNameFeeError),
  InternalError: () => (/* reexport */ InternalError),
  InvalidAensNameError: () => (/* reexport */ InvalidAensNameError),
  InvalidAuthDataError: () => (/* reexport */ InvalidAuthDataError),
  InvalidChecksumError: () => (/* reexport */ InvalidChecksumError),
  InvalidMethodInvocationError: () => (/* reexport */ InvalidMethodInvocationError),
  InvalidRpcMessageError: () => (/* reexport */ InvalidRpcMessageError),
  InvalidSignatureError: () => (/* reexport */ InvalidSignatureError),
  InvalidTxError: () => (/* reexport */ InvalidTxError),
  LogicError: () => (/* reexport */ LogicError),
  MAX_AUTH_FUN_GAS: () => (/* reexport */ MAX_AUTH_FUN_GAS),
  MESSAGE_DIRECTION: () => (/* reexport */ MESSAGE_DIRECTION),
  METHODS: () => (/* reexport */ METHODS),
  MIN_GAS_PRICE: () => (/* reexport */ MIN_GAS_PRICE),
  MemoryAccount: () => (/* reexport */ AccountMemory),
  MerkleTreeHashMismatchError: () => (/* reexport */ MerkleTreeHashMismatchError),
  Middleware: () => (/* reexport */ Middleware),
  MiddlewarePageMissed: () => (/* reexport */ MiddlewarePageMissed),
  MiddlewareSubscriber: () => (/* reexport */ MiddlewareSubscriber),
  MiddlewareSubscriberDisconnected: () => (/* reexport */ MiddlewareSubscriberDisconnected),
  MiddlewareSubscriberError: () => (/* reexport */ MiddlewareSubscriberError),
  MissingCallbackError: () => (/* reexport */ MissingCallbackError),
  MissingContractAddressError: () => (/* reexport */ MissingContractAddressError),
  MissingContractDefError: () => (/* reexport */ MissingContractDefError),
  MissingEventDefinitionError: () => (/* reexport */ MissingEventDefinitionError),
  MissingFunctionNameError: () => (/* reexport */ MissingFunctionNameError),
  MissingNodeInTreeError: () => (/* reexport */ MissingNodeInTreeError),
  MissingParamError: () => (/* reexport */ MissingParamError),
  NAME_BID_RANGES: () => (/* reexport */ NAME_BID_RANGES),
  NAME_BID_TIMEOUT_BLOCKS: () => (/* reexport */ NAME_BID_TIMEOUT_BLOCKS),
  NAME_FEE_BID_INCREMENT: () => (/* reexport */ NAME_FEE_BID_INCREMENT),
  NAME_FEE_MULTIPLIER: () => (/* reexport */ NAME_FEE_MULTIPLIER),
  NAME_MAX_LENGTH_FEE: () => (/* reexport */ NAME_MAX_LENGTH_FEE),
  Name: () => (/* reexport */ Name),
  NoSerializerFoundError: () => (/* reexport */ NoSerializerFoundError),
  NoSuchContractFunctionError: () => (/* reexport */ NoSuchContractFunctionError),
  NoWalletConnectedError: () => (/* reexport */ NoWalletConnectedError),
  Node: () => (/* reexport */ Node),
  NodeError: () => (/* reexport */ NodeError),
  NodeInvocationError: () => (/* reexport */ NodeInvocationError),
  NodeNotFoundError: () => (/* reexport */ NodeNotFoundError),
  NotImplementedError: () => (/* reexport */ NotImplementedError),
  NotPayableFunctionError: () => (/* reexport */ NotPayableFunctionError),
  ORACLE_TTL_TYPES: () => (/* reexport */ ORACLE_TTL_TYPES),
  Oracle: () => (/* reexport */ Oracle),
  OracleClient: () => (/* reexport */ OracleClient),
  PayloadLengthError: () => (/* reexport */ PayloadLengthError),
  PrefixNotFoundError: () => (/* reexport */ PrefixNotFoundError),
  RPC_STATUS: () => (/* reexport */ RPC_STATUS),
  RequestTimedOutError: () => (/* reexport */ RequestTimedOutError),
  RpcConnectionDenyError: () => (/* reexport */ RpcConnectionDenyError),
  RpcConnectionError: () => (/* reexport */ RpcConnectionError),
  RpcError: () => (/* reexport */ RpcError),
  RpcInternalError: () => (/* reexport */ RpcInternalError),
  RpcInvalidTransactionError: () => (/* reexport */ RpcInvalidTransactionError),
  RpcMethodNotFoundError: () => (/* reexport */ RpcMethodNotFoundError),
  RpcNoNetworkById: () => (/* reexport */ RpcNoNetworkById),
  RpcNotAuthorizeError: () => (/* reexport */ RpcNotAuthorizeError),
  RpcPermissionDenyError: () => (/* reexport */ RpcPermissionDenyError),
  RpcRejectedByUserError: () => (/* reexport */ RpcRejectedByUserError),
  RpcUnsupportedProtocolError: () => (/* reexport */ RpcUnsupportedProtocolError),
  SUBSCRIPTION_TYPES: () => (/* reexport */ SUBSCRIPTION_TYPES),
  SchemaNotFoundError: () => (/* reexport */ SchemaNotFoundError),
  Tag: () => (/* reexport */ Tag),
  TagNotFoundError: () => (/* reexport */ TagNotFoundError),
  TransactionError: () => (/* reexport */ TransactionError),
  TxNotInChainError: () => (/* reexport */ TxNotInChainError),
  TxTimedOutError: () => (/* reexport */ TxTimedOutError),
  TypeError: () => (/* reexport */ errors_TypeError),
  UnAuthorizedAccountError: () => (/* reexport */ UnAuthorizedAccountError),
  UnavailableAccountError: () => (/* reexport */ UnavailableAccountError),
  UnexpectedChannelMessageError: () => (/* reexport */ UnexpectedChannelMessageError),
  UnexpectedTsError: () => (/* reexport */ UnexpectedTsError),
  UnknownChannelStateError: () => (/* reexport */ UnknownChannelStateError),
  UnknownNodeLengthError: () => (/* reexport */ UnknownNodeLengthError),
  UnknownPathNibbleError: () => (/* reexport */ UnknownPathNibbleError),
  UnknownRpcClientError: () => (/* reexport */ UnknownRpcClientError),
  UnsubscribedAccountError: () => (/* reexport */ UnsubscribedAccountError),
  UnsupportedPlatformError: () => (/* reexport */ UnsupportedPlatformError),
  UnsupportedProtocolError: () => (/* reexport */ UnsupportedProtocolError),
  UnsupportedVersionError: () => (/* reexport */ UnsupportedVersionError),
  VmVersion: () => (/* reexport */ VmVersion),
  WALLET_TYPE: () => (/* reexport */ WALLET_TYPE),
  WalletConnectorFrame: () => (/* reexport */ WalletConnectorFrame),
  WalletConnectorFrameWithNode: () => (/* reexport */ WalletConnectorFrameWithNode),
  WalletError: () => (/* reexport */ WalletError),
  _getPollInterval: () => (/* reexport */ _getPollInterval),
  awaitHeight: () => (/* reexport */ awaitHeight),
  buildAuthTxHash: () => (/* reexport */ buildAuthTxHash),
  buildAuthTxHashByGaMetaTx: () => (/* reexport */ buildAuthTxHashByGaMetaTx),
  buildContractId: () => (/* reexport */ buildContractId),
  buildContractIdByContractTx: () => (/* reexport */ buildContractIdByContractTx),
  buildTx: () => (/* reexport */ buildTx),
  buildTxAsync: () => (/* reexport */ buildTxAsync),
  buildTxHash: () => (/* reexport */ buildTxHash),
  commitmentHash: () => (/* reexport */ commitmentHash),
  computeAuctionEndBlock: () => (/* reexport */ computeAuctionEndBlock),
  computeBidFee: () => (/* reexport */ computeBidFee),
  connectionProxy: () => (/* reexport */ connection_proxy),
  createGeneralizedAccount: () => (/* reexport */ createGeneralizedAccount),
  decode: () => (/* reexport */ decode),
  encode: () => (/* reexport */ encode),
  encodeContractAddress: () => (/* reexport */ buildContractId),
  encodeUnsigned: () => (/* reexport */ encodeUnsigned),
  ensureEncoded: () => (/* reexport */ ensureEncoded),
  ensureJwt: () => (/* reexport */ ensureJwt),
  ensureName: () => (/* reexport */ ensureName),
  formatAmount: () => (/* reexport */ formatAmount),
  genSalt: () => (/* reexport */ genSalt),
  getAccount: () => (/* reexport */ getAccount),
  getBalance: () => (/* reexport */ getBalance),
  getContract: () => (/* reexport */ getContract),
  getContractByteCode: () => (/* reexport */ getContractByteCode),
  getCurrentGeneration: () => (/* reexport */ getCurrentGeneration),
  getDefaultPointerKey: () => (/* reexport */ getDefaultPointerKey),
  getExecutionCost: () => (/* reexport */ getExecutionCost),
  getExecutionCostBySignedTx: () => (/* reexport */ getExecutionCostBySignedTx),
  getExecutionCostUsingNode: () => (/* reexport */ getExecutionCostUsingNode),
  getFileSystem: () => (/* reexport */ getFileSystem),
  getGeneration: () => (/* reexport */ getGeneration),
  getHeight: () => (/* reexport */ getHeight),
  getKeyBlock: () => (/* reexport */ getKeyBlock),
  getMicroBlockHeader: () => (/* reexport */ getMicroBlockHeader),
  getMicroBlockTransactions: () => (/* reexport */ getMicroBlockTransactions),
  getMinimumNameFee: () => (/* reexport */ getMinimumNameFee),
  getName: () => (/* reexport */ getName),
  getTransactionSignerAddress: () => (/* reexport */ getTransactionSignerAddress),
  hash: () => (/* reexport */ hash),
  hashDomain: () => (/* reexport */ hashDomain),
  hashJson: () => (/* reexport */ hashJson),
  hashMessage: () => (/* reexport */ hashMessage),
  hashTypedData: () => (/* reexport */ hashTypedData),
  isAddressValid: () => (/* reexport */ isAddressValid),
  isAuctionName: () => (/* reexport */ isAuctionName),
  isEncoded: () => (/* reexport */ isEncoded),
  isJwt: () => (/* reexport */ isJwt),
  isName: () => (/* reexport */ isName),
  isNameValid: () => (/* reexport */ isName),
  messageToHash: () => (/* reexport */ hashMessage),
  oracleQueryId: () => (/* reexport */ oracleQueryId),
  packDelegation: () => (/* reexport */ packDelegation),
  packEntry: () => (/* reexport */ packEntry),
  payForTransaction: () => (/* reexport */ payForTransaction),
  poll: () => (/* reexport */ poll),
  prefixedAmount: () => (/* reexport */ prefixedAmount),
  produceNameId: () => (/* reexport */ produceNameId),
  readInt: () => (/* reexport */ readInt),
  resolveName: () => (/* reexport */ resolveName),
  sendTransaction: () => (/* reexport */ sendTransaction),
  signJwt: () => (/* reexport */ signJwt),
  spend: () => (/* reexport */ spend),
  toAe: () => (/* reexport */ toAe),
  toAettos: () => (/* reexport */ toAettos),
  toBytes: () => (/* reexport */ toBytes),
  transferFunds: () => (/* reexport */ transferFunds),
  txDryRun: () => (/* reexport */ txDryRun),
  unpackDelegation: () => (/* reexport */ unpackDelegation),
  unpackEntry: () => (/* reexport */ unpackEntry),
  unpackJwt: () => (/* reexport */ unpackJwt),
  unpackTx: () => (/* reexport */ unpackTx),
  verify: () => (/* reexport */ verifySignature),
  verifyJwt: () => (/* reexport */ verifyJwt),
  verifyMessage: () => (/* reexport */ verifyMessageSignature),
  verifyMessageSignature: () => (/* reexport */ verifyMessageSignature),
  verifySignature: () => (/* reexport */ verifySignature),
  verifyTransaction: () => (/* reexport */ verifyTransaction),
  waitForTxConfirm: () => (/* reexport */ waitForTxConfirm),
  walletDetector: () => (/* reexport */ wallet_detector)
});

// NAMESPACE OBJECT: ./src/utils/encoder-types.ts
var encoder_types_namespaceObject = {};
__webpack_require__.r(encoder_types_namespaceObject);
__webpack_require__.d(encoder_types_namespaceObject, {
  Encoding: () => (Encoding)
});

// NAMESPACE OBJECT: ./src/chain.ts
var chain_namespaceObject = {};
__webpack_require__.r(chain_namespaceObject);
__webpack_require__.d(chain_namespaceObject, {
  _getPollInterval: () => (_getPollInterval),
  awaitHeight: () => (awaitHeight),
  getAccount: () => (getAccount),
  getBalance: () => (getBalance),
  getContract: () => (getContract),
  getContractByteCode: () => (getContractByteCode),
  getCurrentGeneration: () => (getCurrentGeneration),
  getGeneration: () => (getGeneration),
  getHeight: () => (getHeight),
  getKeyBlock: () => (getKeyBlock),
  getMicroBlockHeader: () => (getMicroBlockHeader),
  getMicroBlockTransactions: () => (getMicroBlockTransactions),
  getName: () => (getName),
  poll: () => (poll),
  resolveName: () => (resolveName),
  txDryRun: () => (txDryRun),
  waitForTxConfirm: () => (waitForTxConfirm)
});

// NAMESPACE OBJECT: ./src/apis/node/models/mappers.ts
var mappers_namespaceObject = {};
__webpack_require__.r(mappers_namespaceObject);
__webpack_require__.d(mappers_namespaceObject, {
  Account: () => (Account),
  AuctionEntry: () => (AuctionEntry),
  ByteCode: () => (ByteCode),
  Channel: () => (Channel),
  ChannelCloseMutualTx: () => (ChannelCloseMutualTx),
  ChannelCloseSoloTx: () => (ChannelCloseSoloTx),
  ChannelCreateTx: () => (ChannelCreateTx),
  ChannelDepositTx: () => (ChannelDepositTx),
  ChannelForceProgressTx: () => (ChannelForceProgressTx),
  ChannelSetDelegatesTx: () => (ChannelSetDelegatesTx),
  ChannelSettleTx: () => (ChannelSettleTx),
  ChannelSlashTx: () => (ChannelSlashTx),
  ChannelSnapshotSoloTx: () => (ChannelSnapshotSoloTx),
  ChannelWithdrawTx: () => (ChannelWithdrawTx),
  CheckTxInPoolResponse: () => (CheckTxInPoolResponse),
  CommitmentId: () => (CommitmentId),
  ContractCallObject: () => (ContractCallObject),
  ContractCallTx: () => (ContractCallTx),
  ContractCreateTx: () => (ContractCreateTx),
  ContractObject: () => (ContractObject),
  CountResponse: () => (CountResponse),
  CreateContractUnsignedTx: () => (CreateContractUnsignedTx),
  Currency: () => (Currency),
  Delegates: () => (Delegates),
  DryRunAccount: () => (DryRunAccount),
  DryRunCallContext: () => (DryRunCallContext),
  DryRunCallReq: () => (DryRunCallReq),
  DryRunInput: () => (DryRunInput),
  DryRunInputItem: () => (DryRunInputItem),
  DryRunResult: () => (DryRunResult),
  DryRunResults: () => (DryRunResults),
  EncodedTx: () => (EncodedTx),
  ErrorModel: () => (ErrorModel),
  Event: () => (mappers_Event),
  GAAttachTx: () => (GAAttachTx),
  GAMetaTx: () => (GAMetaTx),
  GAObject: () => (GAObject),
  GasPricesItem: () => (GasPricesItem),
  Generation: () => (Generation),
  HCContractPubkeys: () => (HCContractPubkeys),
  HashResponse: () => (HashResponse),
  Header: () => (Header),
  HeightResponse: () => (HeightResponse),
  Image: () => (Image),
  KeyBlock: () => (KeyBlock),
  MicroBlockHeader: () => (MicroBlockHeader),
  NameClaimTx: () => (NameClaimTx),
  NameEntry: () => (NameEntry),
  NameHash: () => (NameHash),
  NamePointer: () => (NamePointer),
  NamePointerComplete: () => (NamePointerComplete),
  NamePreclaimTx: () => (NamePreclaimTx),
  NameRevokeTx: () => (NameRevokeTx),
  NameTransferTx: () => (NameTransferTx),
  NameUpdateTx: () => (NameUpdateTx),
  NextNonceResponse: () => (NextNonceResponse),
  OffChainCallContract: () => (OffChainCallContract),
  OffChainDeposit: () => (OffChainDeposit),
  OffChainNewContract: () => (OffChainNewContract),
  OffChainTransfer: () => (OffChainTransfer),
  OffChainUpdate: () => (OffChainUpdate),
  OffChainWithdrawal: () => (OffChainWithdrawal),
  OracleExtendTx: () => (OracleExtendTx),
  OracleQueries: () => (OracleQueries),
  OracleQuery: () => (OracleQuery),
  OracleQueryTx: () => (OracleQueryTx),
  OracleRegisterTx: () => (OracleRegisterTx),
  OracleRespondTx: () => (OracleRespondTx),
  PayingForTx: () => (PayingForTx),
  PeerConnections: () => (PeerConnections),
  PeerCount: () => (PeerCount),
  PeerCountAvailable: () => (PeerCountAvailable),
  PeerCountConnected: () => (PeerCountConnected),
  PeerDetails: () => (PeerDetails),
  PeerPubKey: () => (PeerPubKey),
  Peers: () => (Peers),
  PinningTx: () => (PinningTx),
  PoI: () => (PoI),
  PostTxResponse: () => (PostTxResponse),
  Protocol: () => (Protocol),
  PubKey: () => (PubKey),
  RegisteredOracle: () => (RegisteredOracle),
  RelativeTTL: () => (RelativeTTL),
  SignedTx: () => (SignedTx),
  SignedTxs: () => (SignedTxs),
  SpendTx: () => (SpendTx),
  Status: () => (Status),
  SyncStatus: () => (SyncStatus),
  TokenSupply: () => (TokenSupply),
  Ttl: () => (Ttl),
  Tx: () => (Tx),
  TxInfoObject: () => (TxInfoObject),
  UnsignedTx: () => (UnsignedTx),
  discriminators: () => (discriminators)
});

// NAMESPACE OBJECT: ./src/spend.ts
var spend_namespaceObject = {};
__webpack_require__.r(spend_namespaceObject);
__webpack_require__.d(spend_namespaceObject, {
  payForTransaction: () => (payForTransaction),
  spend: () => (spend),
  transferFunds: () => (transferFunds)
});

// NAMESPACE OBJECT: ./src/contract/ga.ts
var ga_namespaceObject = {};
__webpack_require__.r(ga_namespaceObject);
__webpack_require__.d(ga_namespaceObject, {
  buildAuthTxHash: () => (buildAuthTxHash),
  buildAuthTxHashByGaMetaTx: () => (buildAuthTxHashByGaMetaTx),
  createGeneralizedAccount: () => (createGeneralizedAccount)
});

// NAMESPACE OBJECT: ./src/apis/compiler/models/mappers.ts
var models_mappers_namespaceObject = {};
__webpack_require__.r(models_mappers_namespaceObject);
__webpack_require__.d(models_mappers_namespaceObject, {
  ApiVersion: () => (ApiVersion),
  ByteCodeInput: () => (ByteCodeInput),
  BytecodeCallResultInput: () => (BytecodeCallResultInput),
  Calldata: () => (Calldata),
  CompileOpts: () => (CompileOpts),
  CompileResult: () => (CompileResult),
  CompilerError: () => (mappers_CompilerError),
  CompilerVersion: () => (CompilerVersion),
  Contract: () => (mappers_Contract),
  DecodeCalldataBytecode: () => (DecodeCalldataBytecode),
  DecodeCalldataSource: () => (DecodeCalldataSource),
  DecodedCalldata: () => (DecodedCalldata),
  DecodedCallresult: () => (DecodedCallresult),
  ErrorModel: () => (mappers_ErrorModel),
  ErrorPos: () => (ErrorPos),
  FateAssembler: () => (FateAssembler),
  FunctionCallInput: () => (FunctionCallInput),
  SophiaBinaryData: () => (SophiaBinaryData),
  SophiaCallResultInput: () => (SophiaCallResultInput),
  SophiaJsonData: () => (SophiaJsonData),
  ValidateByteCodeInput: () => (ValidateByteCodeInput)
});

// NAMESPACE OBJECT: ./src/channel/handlers.ts
var handlers_namespaceObject = {};
__webpack_require__.r(handlers_namespaceObject);
__webpack_require__.d(handlers_namespaceObject, {
  appendSignature: () => (appendSignature),
  awaitingChannelCreateTx: () => (awaitingChannelCreateTx),
  awaitingCompletion: () => (awaitingCompletion),
  awaitingConnection: () => (awaitingConnection),
  awaitingLeave: () => (awaitingLeave),
  awaitingOnChainTx: () => (awaitingOnChainTx),
  awaitingReconnection: () => (awaitingReconnection),
  awaitingReestablish: () => (awaitingReestablish),
  awaitingShutdownTx: () => (awaitingShutdownTx),
  channelClosed: () => (channelClosed),
  channelOpen: () => (channelOpen),
  handleUnexpectedMessage: () => (handleUnexpectedMessage),
  signAndNotify: () => (signAndNotify)
});

// NAMESPACE OBJECT: ./src/apis/middleware/models/mappers.ts
var middleware_models_mappers_namespaceObject = {};
__webpack_require__.r(middleware_models_mappers_namespaceObject);
__webpack_require__.d(middleware_models_mappers_namespaceObject, {
  Activity: () => (Activity),
  ActivityPayload: () => (ActivityPayload),
  Aex141Response: () => (Aex141Response),
  Aex141TemplateTokensResponse: () => (Aex141TemplateTokensResponse),
  Aex141TemplatesResponse: () => (Aex141TemplatesResponse),
  Aex141TokenDetailResponse: () => (Aex141TokenDetailResponse),
  Aex141TokenResponse: () => (Aex141TokenResponse),
  Aex141TransferEvent: () => (Aex141TransferEvent),
  Aex9BalanceResponse: () => (Aex9BalanceResponse),
  Aex9ContractBalanceResponse: () => (Aex9ContractBalanceResponse),
  Aex9Response: () => (Aex9Response),
  Aex9TransferEvent: () => (Aex9TransferEvent),
  Aex9TransferResponse: () => (Aex9TransferResponse),
  Auction: () => (Auction),
  AuctionLastBid: () => (AuctionLastBid),
  AuctionLastBidTx: () => (AuctionLastBidTx),
  Channel: () => (mappers_Channel),
  ChannelCloseMutualTx: () => (mappers_ChannelCloseMutualTx),
  ChannelCloseSoloTx: () => (mappers_ChannelCloseSoloTx),
  ChannelCreateTx: () => (mappers_ChannelCreateTx),
  ChannelDepositTx: () => (mappers_ChannelDepositTx),
  ChannelForceProgressTx: () => (mappers_ChannelForceProgressTx),
  ChannelSetDelegatesTx: () => (mappers_ChannelSetDelegatesTx),
  ChannelSettleTx: () => (mappers_ChannelSettleTx),
  ChannelSlashTx: () => (mappers_ChannelSlashTx),
  ChannelSnapshotSoloTx: () => (mappers_ChannelSnapshotSoloTx),
  ChannelWithdrawTx: () => (mappers_ChannelWithdrawTx),
  Components171VsjiSchemasNametxPropertiesTxAllof1: () => (Components171VsjiSchemasNametxPropertiesTxAllof1),
  Components17W16A5SchemasAuctionPropertiesLastBidPropertiesTxAllof1: () => (Components17W16A5SchemasAuctionPropertiesLastBidPropertiesTxAllof1),
  Components1Viuqa3SchemasOracletxPropertiesTxAllof1: () => (Components1Viuqa3SchemasOracletxPropertiesTxAllof1),
  Contract: () => (models_mappers_Contract),
  ContractCall: () => (ContractCall),
  ContractCallTx: () => (mappers_ContractCallTx),
  ContractCreateTx: () => (mappers_ContractCreateTx),
  ContractLog: () => (ContractLog),
  Delegate: () => (Delegate),
  Delegates: () => (mappers_Delegates),
  DeltaStat: () => (DeltaStat),
  DexSwap: () => (DexSwap),
  DexSwapAmounts: () => (DexSwapAmounts),
  EpochInfo: () => (EpochInfo),
  EpochInfoValidatorsItem: () => (EpochInfoValidatorsItem),
  ErrorResponse: () => (ErrorResponse),
  GAAttachTx: () => (mappers_GAAttachTx),
  GAMetaTx: () => (mappers_GAMetaTx),
  Get200ApplicationJsonAllOfPropertiesItemsItem: () => (Get200ApplicationJsonAllOfPropertiesItemsItem),
  Get200ApplicationJsonProperties: () => (Get200ApplicationJsonProperties),
  InternalContractCallEvent: () => (InternalContractCallEvent),
  InternalTransferEvent: () => (InternalTransferEvent),
  KeyBlock: () => (mappers_KeyBlock),
  KeyBlockExtended: () => (KeyBlockExtended),
  MicroBlockExtended: () => (MicroBlockExtended),
  MicroBlockHeader: () => (mappers_MicroBlockHeader),
  Miner: () => (Miner),
  Name: () => (mappers_Name),
  NameClaim: () => (NameClaim),
  NameClaimEvent: () => (NameClaimEvent),
  NameClaimTx: () => (mappers_NameClaimTx),
  NameOwnership: () => (NameOwnership),
  NamePointer: () => (mappers_NamePointer),
  NamePreclaimTx: () => (mappers_NamePreclaimTx),
  NameRevokeTx: () => (mappers_NameRevokeTx),
  NameTransfer: () => (NameTransfer),
  NameTransferTx: () => (mappers_NameTransferTx),
  NameTx: () => (NameTx),
  NameTxTx: () => (NameTxTx),
  NameUpdate: () => (NameUpdate),
  NameUpdateTx: () => (mappers_NameUpdateTx),
  NotFoundResponse: () => (NotFoundResponse),
  OffChainUpdate: () => (mappers_OffChainUpdate),
  Oracle: () => (mappers_Oracle),
  OracleExtend: () => (OracleExtend),
  OracleExtendTx: () => (mappers_OracleExtendTx),
  OracleFormat: () => (OracleFormat),
  OracleQuery: () => (mappers_OracleQuery),
  OracleQueryTx: () => (mappers_OracleQueryTx),
  OracleRegisterTx: () => (mappers_OracleRegisterTx),
  OracleRespondTx: () => (mappers_OracleRespondTx),
  OracleResponse: () => (OracleResponse),
  OracleTx: () => (OracleTx),
  OracleTxTx: () => (OracleTxTx),
  PaginatedResponse: () => (PaginatedResponse),
  Paths108B3VtV3Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchemaAllof1: () => (Paths108B3VtV3Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchemaAllof1),
  Paths10Kk1UxV3ContractsLogsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths10Kk1UxV3ContractsLogsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths10R8Q7PV3AccountsAccountidDexSwapsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths10R8Q7PV3AccountsAccountidDexSwapsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths10Z6Jt8V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelDepositTx: () => (Paths10Z6Jt8V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelDepositTx),
  Paths1159W94V3KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchema: () => (Paths1159W94V3KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchema),
  Paths11Bqs5V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesSpendTx: () => (Paths11Bqs5V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesSpendTx),
  Paths12S1Nd4V3NamesGetResponses200ContentApplicationJsonSchema: () => (Paths12S1Nd4V3NamesGetResponses200ContentApplicationJsonSchema),
  Paths15Bkk50V3MicroBlocksHashTransactionsGetResponses200ContentApplicationJsonSchema: () => (Paths15Bkk50V3MicroBlocksHashTransactionsGetResponses200ContentApplicationJsonSchema),
  Paths15F3FfuV3StatsTotalAccountsGetResponses200ContentApplicationJsonSchema: () => (Paths15F3FfuV3StatsTotalAccountsGetResponses200ContentApplicationJsonSchema),
  Paths15K0AlgV3HyperchainValidatorsValidatorDelegatesTopGetResponses200ContentApplicationJsonSchema: () => (Paths15K0AlgV3HyperchainValidatorsValidatorDelegatesTopGetResponses200ContentApplicationJsonSchema),
  Paths15Mi2TaV3Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchema: () => (Paths15Mi2TaV3Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchema),
  Paths16Cyh9EV3AccountsAccountidNamesClaimsGetResponses200ContentApplicationJsonSchema: () => (Paths16Cyh9EV3AccountsAccountidNamesClaimsGetResponses200ContentApplicationJsonSchema),
  Paths16G4GzrV3AccountsAccountidNamesClaimsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths16G4GzrV3AccountsAccountidNamesClaimsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths17Dchb7V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleExtendTx: () => (Paths17Dchb7V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleExtendTx),
  Paths181AjwxV3Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchema: () => (Paths181AjwxV3Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchema),
  Paths181Cs9V3NamesGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths181Cs9V3NamesGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths18L84JcV3ContractsCallsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths18L84JcV3ContractsCallsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths194Lg3IV3HyperchainEpochsGetResponses200ContentApplicationJsonSchema: () => (Paths194Lg3IV3HyperchainEpochsGetResponses200ContentApplicationJsonSchema),
  Paths19IxhsmV3Aex9CountGetResponses200ContentApplicationJsonSchema: () => (Paths19IxhsmV3Aex9CountGetResponses200ContentApplicationJsonSchema),
  Paths1A27TirV3StatsBlocksGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1A27TirV3StatsBlocksGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1A8Ah39V3Aex141ContractidTransfersGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1A8Ah39V3Aex141ContractidTransfersGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1AeqodeV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCloseSoloTx: () => (Paths1AeqodeV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCloseSoloTx),
  Paths1D7Up0DV3StatsDifficultyGetResponses200ContentApplicationJsonSchema: () => (Paths1D7Up0DV3StatsDifficultyGetResponses200ContentApplicationJsonSchema),
  Paths1Di8FnjV3DexSwapsGetResponses200ContentApplicationJsonSchema: () => (Paths1Di8FnjV3DexSwapsGetResponses200ContentApplicationJsonSchema),
  Paths1E14NekV3OraclesGetResponses200ContentApplicationJsonSchema: () => (Paths1E14NekV3OraclesGetResponses200ContentApplicationJsonSchema),
  Paths1Ec8CltV3NamesIdUpdatesGetResponses200ContentApplicationJsonSchema: () => (Paths1Ec8CltV3NamesIdUpdatesGetResponses200ContentApplicationJsonSchema),
  Paths1EfdbjrV3AccountsAccountidActivitiesGetResponses200ContentApplicationJsonSchema: () => (Paths1EfdbjrV3AccountsAccountidActivitiesGetResponses200ContentApplicationJsonSchema),
  Paths1F8GzwrV3HyperchainEpochsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1F8GzwrV3HyperchainEpochsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1F98AqgV3NamesIdClaimsGetResponses200ContentApplicationJsonSchema: () => (Paths1F98AqgV3NamesIdClaimsGetResponses200ContentApplicationJsonSchema),
  Paths1Fl1Lh2V3StatsAex9TransfersGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1Fl1Lh2V3StatsAex9TransfersGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1I4U8D5V3HyperchainValidatorsValidatorDelegatesGetResponses200ContentApplicationJsonSchema: () => (Paths1I4U8D5V3HyperchainValidatorsValidatorDelegatesGetResponses200ContentApplicationJsonSchema),
  Paths1Ibn686V3HyperchainValidatorsGetResponses200ContentApplicationJsonSchema: () => (Paths1Ibn686V3HyperchainValidatorsGetResponses200ContentApplicationJsonSchema),
  Paths1IfhshmV3StatsTransactionsGetResponses200ContentApplicationJsonSchema: () => (Paths1IfhshmV3StatsTransactionsGetResponses200ContentApplicationJsonSchema),
  Paths1IskjkV3StatsHashrateGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1IskjkV3StatsHashrateGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1J83O75V3StatsDeltaGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1J83O75V3StatsDeltaGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1Jkl3L3V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelForceProgressTx: () => (Paths1Jkl3L3V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelForceProgressTx),
  Paths1K55ZdgV3StatsTotalGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1K55ZdgV3StatsTotalGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1L5C64RV3OraclesIdExtendsGetResponses200ContentApplicationJsonSchema: () => (Paths1L5C64RV3OraclesIdExtendsGetResponses200ContentApplicationJsonSchema),
  Paths1Mat0BzV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesGaAttachTx: () => (Paths1Mat0BzV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesGaAttachTx),
  Paths1Mheci5V3AccountsAccountidNamesPointeesGetResponses200ContentApplicationJsonSchema: () => (Paths1Mheci5V3AccountsAccountidNamesPointeesGetResponses200ContentApplicationJsonSchema),
  Paths1N61UurV3Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchema: () => (Paths1N61UurV3Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchema),
  Paths1N757S0V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesPayingForTx: () => (Paths1N757S0V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesPayingForTx),
  Paths1Ngkd7FV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleQueryTx: () => (Paths1Ngkd7FV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleQueryTx),
  Paths1O7Q6IhV3Aex141ContractidTransfersGetResponses200ContentApplicationJsonSchema: () => (Paths1O7Q6IhV3Aex141ContractidTransfersGetResponses200ContentApplicationJsonSchema),
  Paths1Pymq07V3TransactionsGetResponses200ContentApplicationJsonSchema: () => (Paths1Pymq07V3TransactionsGetResponses200ContentApplicationJsonSchema),
  Paths1Q9E32FV3AccountsAccountidAex141TokensGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1Q9E32FV3AccountsAccountidAex141TokensGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1Qg7SclV3HyperchainValidatorsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1Qg7SclV3HyperchainValidatorsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1Qk8BkgV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelWithdrawTx: () => (Paths1Qk8BkgV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelWithdrawTx),
  Paths1Qw6KhfV3StatsDifficultyGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1Qw6KhfV3StatsDifficultyGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1R08F8HV3NamesAuctionsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1R08F8HV3NamesAuctionsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1R4Z885V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNamePreclaimTx: () => (Paths1R4Z885V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNamePreclaimTx),
  Paths1Raw8PV3NamesIdTransfersGetResponses200ContentApplicationJsonSchema: () => (Paths1Raw8PV3NamesIdTransfersGetResponses200ContentApplicationJsonSchema),
  Paths1S5Zlt1V3HyperchainScheduleGetResponses200ContentApplicationJsonSchema: () => (Paths1S5Zlt1V3HyperchainScheduleGetResponses200ContentApplicationJsonSchema),
  Paths1Smy8TV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesGaMetaTx: () => (Paths1Smy8TV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesGaMetaTx),
  Paths1Sxjoy0V3StatsBlocksGetResponses200ContentApplicationJsonSchema: () => (Paths1Sxjoy0V3StatsBlocksGetResponses200ContentApplicationJsonSchema),
  Paths1Tcj5A9V3OraclesIdResponsesGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1Tcj5A9V3OraclesIdResponsesGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1TkisghV3Aex141ContractidTokensGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1TkisghV3Aex141ContractidTokensGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1Txblx8V3ContractsCallsGetResponses200ContentApplicationJsonSchema: () => (Paths1Txblx8V3ContractsCallsGetResponses200ContentApplicationJsonSchema),
  Paths1U2Ve7RV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleResponseTx: () => (Paths1U2Ve7RV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleResponseTx),
  Paths1Ukwk06V3NamesIdTransfersGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1Ukwk06V3NamesIdTransfersGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1Uni7AtV3OraclesIdQueriesGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1Uni7AtV3OraclesIdQueriesGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1Uqqby0V3Aex9GetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1Uqqby0V3Aex9GetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1UxyhelV3StatsAex9TransfersGetResponses200ContentApplicationJsonSchema: () => (Paths1UxyhelV3StatsAex9TransfersGetResponses200ContentApplicationJsonSchema),
  Paths1Uybd4PV3Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchema: () => (Paths1Uybd4PV3Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchema),
  Paths1Vr3Y2EV3Aex9GetResponses200ContentApplicationJsonSchema: () => (Paths1Vr3Y2EV3Aex9GetResponses200ContentApplicationJsonSchema),
  Paths1XwlyjtV3Aex141GetResponses200ContentApplicationJsonSchema: () => (Paths1XwlyjtV3Aex141GetResponses200ContentApplicationJsonSchema),
  Paths277OngV3KeyBlocksGetResponses200ContentApplicationJsonSchema: () => (Paths277OngV3KeyBlocksGetResponses200ContentApplicationJsonSchema),
  Paths3Bfys0V3StatsTotalAccountsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths3Bfys0V3StatsTotalAccountsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths3EzhapV3ChannelsGetResponses200ContentApplicationJsonSchema: () => (Paths3EzhapV3ChannelsGetResponses200ContentApplicationJsonSchema),
  Paths3Hsv3GV3AccountsAccountidAex141TokensGetResponses200ContentApplicationJsonSchema: () => (Paths3Hsv3GV3AccountsAccountidAex141TokensGetResponses200ContentApplicationJsonSchema),
  Paths4Pjk8DV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelOffchainTx: () => (Paths4Pjk8DV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelOffchainTx),
  Paths50Qhc7V3StatsMinersGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths50Qhc7V3StatsMinersGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths5Ehb0PV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSnapshotSoloTx: () => (Paths5Ehb0PV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSnapshotSoloTx),
  Paths5Xf9ScV3StatsDeltaGetResponses200ContentApplicationJsonSchema: () => (Paths5Xf9ScV3StatsDeltaGetResponses200ContentApplicationJsonSchema),
  Paths6PaqluV3StatsTransactionsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths6PaqluV3StatsTransactionsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths6Vze8ZV3DexContractIdSwapsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths6Vze8ZV3DexContractIdSwapsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths72Dp44V3StatsContractsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths72Dp44V3StatsContractsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths7A1M6RV3ContractsLogsGetResponses200ContentApplicationJsonSchema: () => (Paths7A1M6RV3ContractsLogsGetResponses200ContentApplicationJsonSchema),
  Paths7Ks32NV3HyperchainValidatorsValidatorDelegatesGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths7Ks32NV3HyperchainValidatorsValidatorDelegatesGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths7W5O80V3HyperchainScheduleGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths7W5O80V3HyperchainScheduleGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths8722JhV3OraclesIdQueriesGetResponses200ContentApplicationJsonSchema: () => (Paths8722JhV3OraclesIdQueriesGetResponses200ContentApplicationJsonSchema),
  Paths8I0YgwV3Aex141GetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths8I0YgwV3Aex141GetResponses200ContentApplicationJsonSchemaAllof0),
  Paths9Yfxl2V3DexSwapsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths9Yfxl2V3DexSwapsGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsA60QxwV3AccountsAccountidNamesPointeesGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsA60QxwV3AccountsAccountidNamesPointeesGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsA7P0KiV3TransfersGetResponses200ContentApplicationJsonSchema: () => (PathsA7P0KiV3TransfersGetResponses200ContentApplicationJsonSchema),
  PathsA8Q6T7V3StatsMinersGetResponses200ContentApplicationJsonSchema: () => (PathsA8Q6T7V3StatsMinersGetResponses200ContentApplicationJsonSchema),
  PathsBx0Ya3V3AccountsAccountidActivitiesGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsBx0Ya3V3AccountsAccountidActivitiesGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsC7WhtoV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameClaimTx: () => (PathsC7WhtoV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameClaimTx),
  PathsCeyhpaV3StatsNamesGetResponses200ContentApplicationJsonSchema: () => (PathsCeyhpaV3StatsNamesGetResponses200ContentApplicationJsonSchema),
  PathsCgzmimV3StatsActiveAccountsGetResponses200ContentApplicationJsonSchema: () => (PathsCgzmimV3StatsActiveAccountsGetResponses200ContentApplicationJsonSchema),
  PathsCrb9BgV3NamesAuctionsIdClaimsGetResponses200ContentApplicationJsonSchema: () => (PathsCrb9BgV3NamesAuctionsIdClaimsGetResponses200ContentApplicationJsonSchema),
  PathsCsym65V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSettleTx: () => (PathsCsym65V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSettleTx),
  PathsD92Xl6V3StatsNamesGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsD92Xl6V3StatsNamesGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsDwhnfdV3HyperchainValidatorsValidatorDelegatesTopGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsDwhnfdV3HyperchainValidatorsValidatorDelegatesTopGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsEeiffwV3Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsEeiffwV3Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsEue6HzV3KeyBlocksGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsEue6HzV3KeyBlocksGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsEvgmfsV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesContractCallTx: () => (PathsEvgmfsV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesContractCallTx),
  PathsEwav40V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSlashTx: () => (PathsEwav40V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSlashTx),
  PathsFso5IiV3StatsActiveAccountsGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsFso5IiV3StatsActiveAccountsGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsGcr9MrV3OraclesGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsGcr9MrV3OraclesGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsGp6EyrV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCreateTx: () => (PathsGp6EyrV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCreateTx),
  PathsHa9C78V3TransactionsGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsHa9C78V3TransactionsGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsI72FylV3TransactionsPendingGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsI72FylV3TransactionsPendingGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsJoz7P5V3StatsTotalGetResponses200ContentApplicationJsonSchema: () => (PathsJoz7P5V3StatsTotalGetResponses200ContentApplicationJsonSchema),
  PathsKjq4D4V3NamesAuctionsGetResponses200ContentApplicationJsonSchema: () => (PathsKjq4D4V3NamesAuctionsGetResponses200ContentApplicationJsonSchema),
  PathsKm52GqV3AccountsAccountidAex9BalancesGetResponses200ContentApplicationJsonSchema: () => (PathsKm52GqV3AccountsAccountidAex9BalancesGetResponses200ContentApplicationJsonSchema),
  PathsKr825V3Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchema: () => (PathsKr825V3Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchema),
  PathsKrpz02V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameRevokeTx: () => (PathsKrpz02V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameRevokeTx),
  PathsKwxlzlV3DexContractIdSwapsGetResponses200ContentApplicationJsonSchema: () => (PathsKwxlzlV3DexContractIdSwapsGetResponses200ContentApplicationJsonSchema),
  PathsMvqgifV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleRegisterTx: () => (PathsMvqgifV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleRegisterTx),
  PathsMyl4W2V3NamesIdClaimsGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsMyl4W2V3NamesIdClaimsGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsN9Iv8YV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSetDelegatesTx: () => (PathsN9Iv8YV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSetDelegatesTx),
  PathsNn60D7V3KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsNn60D7V3KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsPs07B4V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameTransferTx: () => (PathsPs07B4V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameTransferTx),
  PathsQmewnaV3ChannelsGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsQmewnaV3ChannelsGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsR51VshV3StatsHashrateGetResponses200ContentApplicationJsonSchema: () => (PathsR51VshV3StatsHashrateGetResponses200ContentApplicationJsonSchema),
  PathsRay4X0V3Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsRay4X0V3Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsRcnvllV3NamesIdUpdatesGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsRcnvllV3NamesIdUpdatesGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsTachlnV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCloseMutualTx: () => (PathsTachlnV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCloseMutualTx),
  PathsTug6HrV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameUpdateTx: () => (PathsTug6HrV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameUpdateTx),
  PathsUq0T7JV3TransactionsPendingGetResponses200ContentApplicationJsonSchema: () => (PathsUq0T7JV3TransactionsPendingGetResponses200ContentApplicationJsonSchema),
  PathsVdg67V3TransfersGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsVdg67V3TransfersGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsVron83V3OraclesIdResponsesGetResponses200ContentApplicationJsonSchema: () => (PathsVron83V3OraclesIdResponsesGetResponses200ContentApplicationJsonSchema),
  PathsWbrhqnV3StatsContractsGetResponses200ContentApplicationJsonSchema: () => (PathsWbrhqnV3StatsContractsGetResponses200ContentApplicationJsonSchema),
  PathsWkpcwaV3Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsWkpcwaV3Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsWl652MV3Aex141ContractidTokensGetResponses200ContentApplicationJsonSchema: () => (PathsWl652MV3Aex141ContractidTokensGetResponses200ContentApplicationJsonSchema),
  PathsXcg812V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchema: () => (PathsXcg812V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchema),
  PathsXhlqwrV3MicroBlocksHashTransactionsGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsXhlqwrV3MicroBlocksHashTransactionsGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsZ4L2QlV3OraclesIdExtendsGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsZ4L2QlV3OraclesIdExtendsGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsZ92TkfV3AccountsAccountidAex9BalancesGetResponses200ContentApplicationJsonSchemaAllof1: () => (PathsZ92TkfV3AccountsAccountidAex9BalancesGetResponses200ContentApplicationJsonSchemaAllof1),
  PathsZpy8S9V3AccountsAccountidDexSwapsGetResponses200ContentApplicationJsonSchema: () => (PathsZpy8S9V3AccountsAccountidDexSwapsGetResponses200ContentApplicationJsonSchema),
  PayingForTx: () => (mappers_PayingForTx),
  PendingTransaction: () => (PendingTransaction),
  Pointee: () => (Pointee),
  RelativeTTL: () => (mappers_RelativeTTL),
  Schedule: () => (Schedule),
  SignedTx: () => (mappers_SignedTx),
  SpendTx: () => (mappers_SpendTx),
  Stat: () => (Stat),
  Stats: () => (Stats),
  Status: () => (mappers_Status),
  StatusMdwAsyncTasks: () => (StatusMdwAsyncTasks),
  TotalStat: () => (TotalStat),
  Transaction: () => (Transaction),
  Transfer: () => (Transfer),
  Ttl: () => (mappers_Ttl),
  Tx: () => (mappers_Tx),
  Validator: () => (Validator),
  discriminators: () => (mappers_discriminators)
});

// EXTERNAL MODULE: external "bignumber.js"
var external_bignumber_js_ = __webpack_require__(6168);
var external_bignumber_js_default = /*#__PURE__*/__webpack_require__.n(external_bignumber_js_);
;// ./src/utils/bignumber.ts
/**
 * Big Number Helpers
 */


/**
 * Check if value is BigNumber, Number, BigInt or number string representation
 * @param number - number to check
 */
const isBigNumber = number => {
  if (typeof number === 'bigint') return true;
  return ['number', 'object', 'string'].includes(typeof number) && (
  // eslint-disable-next-line no-restricted-globals
  !isNaN(number) || Number.isInteger(number) || external_bignumber_js_default().isBigNumber(number));
};

/**
 * BigNumber ceil operation
 */
const ceil = bigNumber => bigNumber.integerValue((external_bignumber_js_default()).ROUND_CEIL);
;// ./src/utils/errors.ts
// eslint-disable-next-line max-classes-per-file

/**
 * aepp-sdk originated error
 * @category exception
 */
class BaseError extends Error {
  constructor(message) {
    super(message);
    this.name = 'BaseError';
  }
}

/**
 * @category exception
 */
class AccountError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'AccountError';
  }
}

/**
 * @category exception
 */
class AensError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'AensError';
  }
}

/**
 * @category exception
 */
class AeppError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'AeppError';
  }
}

/**
 * @category exception
 */
class ChannelError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'ChannelError';
  }
}

/**
 * @category exception
 */
class CompilerError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'CompilerError';
  }
}

/**
 * @category exception
 */
class ContractError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'ContractError';
  }
}

/**
 * @category exception
 */
class CryptographyError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'CryptographyError';
  }
}

/**
 * @category exception
 */
class NodeError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'NodeError';
  }
}

/**
 * @category exception
 */
class TransactionError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'TransactionError';
  }
}

/**
 * @category exception
 */
class WalletError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'WalletError';
  }
}

/**
 * @category exception
 */
class ArgumentError extends BaseError {
  constructor(argumentName, requirement, argumentValue) {
    super(`${argumentName} should be ${requirement}, got ${argumentValue} instead`);
    this.name = 'ArgumentError';
  }
}

/**
 * @category exception
 */
class IllegalArgumentError extends CryptographyError {
  constructor(message) {
    super(message);
    this.name = 'IllegalArgumentError';
  }
}

/**
 * @category exception
 */
class ArgumentCountMismatchError extends BaseError {
  constructor(functionName, requiredCount, providedCount) {
    super(`${functionName} expects ${requiredCount} arguments, got ${providedCount} instead`);
    this.name = 'ArgumentCountMismatchError';
  }
}

/**
 * @category exception
 */
class InsufficientBalanceError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'InsufficientBalanceError';
  }
}

/**
 * @category exception
 */
class MissingParamError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'MissingParamError';
  }
}

/**
 * @category exception
 */
class NoSerializerFoundError extends BaseError {
  constructor() {
    super('Byte serialization not supported');
    this.name = 'NoSerializerFoundError';
  }
}

/**
 * @category exception
 */
class RequestTimedOutError extends BaseError {
  constructor(height) {
    super(`Giving up at height ${height}`);
    this.name = 'RequestTimedOutError';
  }
}

/**
 * @category exception
 */
class TxTimedOutError extends BaseError {
  constructor(blocks, th) {
    super(`Giving up after ${blocks} blocks mined, transaction hash: ${th}`);
    this.name = 'TxTimedOutError';
  }
}

/**
 * @category exception
 */
class errors_TypeError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'TypeError';
  }
}

/**
 * @category exception
 */
class UnsupportedPlatformError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'UnsupportedPlatformError';
  }
}

/**
 * @category exception
 */
class UnsupportedProtocolError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'UnsupportedProtocolError';
  }
}

/**
 * @category exception
 */
class NotImplementedError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'NotImplementedError';
  }
}

/**
 * @category exception
 */
class UnsupportedVersionError extends BaseError {
  constructor(dependency, version, geVersion, ltVersion) {
    super(`Unsupported ${dependency} version ${version}. Supported: >= ${geVersion}` + (ltVersion == null ? '' : ` < ${ltVersion}`));
    this.name = 'UnsupportedVersionError';
  }
}

/**
 * @category exception
 */
class LogicError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'LogicError';
  }
}

/**
 * @category exception
 */
class InternalError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'InternalError';
  }
}

/**
 * @category exception
 */
class UnexpectedTsError extends InternalError {
  constructor(message = 'Expected to not happen, required for TS') {
    super(message);
    this.name = 'UnexpectedTsError';
  }
}

/**
 * @category exception
 */
class UnavailableAccountError extends AccountError {
  constructor(address) {
    super(`Account for ${address} not available`);
    this.name = 'UnavailableAccountError';
  }
}

/**
 * @category exception
 */
class AensPointerContextError extends AensError {
  constructor(nameOrId, prefix) {
    super(`Name ${nameOrId} don't have pointers for ${prefix}`);
    this.name = 'AensPointerContextError';
  }
}

/**
 * @category exception
 */
class InsufficientNameFeeError extends AensError {
  constructor(nameFee, minNameFee) {
    super(`the provided fee ${nameFee.toString()} is not enough to execute the claim, required: ${minNameFee.toString()}`);
    this.name = 'InsufficientNameFeeError';
  }
}

/**
 * @category exception
 */
class InvalidAensNameError extends AensError {
  constructor(message) {
    super(message);
    this.name = 'InvalidAensNameError';
  }
}

/**
 * @category exception
 */
class InvalidRpcMessageError extends AeppError {
  constructor(message) {
    super(`Received invalid message: ${message}`);
    this.name = 'InvalidRpcMessageError';
  }
}

/**
 * @category exception
 */
class MissingCallbackError extends AeppError {
  constructor(id) {
    super(`Can't find callback for this messageId ${id}`);
    this.name = 'MissingCallbackError';
  }
}

/**
 * @category exception
 */
class UnAuthorizedAccountError extends AeppError {
  constructor(onAccount) {
    super(`You do not have access to account ${onAccount}`);
    this.name = 'UnAuthorizedAccountError';
  }
}

/**
 * @category exception
 */
class UnknownRpcClientError extends AeppError {
  constructor(id) {
    super(`RpcClient with id ${id} do not exist`);
    this.name = 'UnknownRpcClientError';
  }
}

/**
 * @category exception
 */
class UnsubscribedAccountError extends AeppError {
  constructor() {
    super('You are not subscribed for an account.');
    this.name = 'UnsubscribedAccountError';
  }
}

/**
 * @category exception
 */
class ChannelCallError extends ChannelError {
  constructor(message) {
    super(message);
    this.name = 'ChannelCallError';
  }
}

/**
 * @category exception
 */
class ChannelConnectionError extends ChannelError {
  constructor(message) {
    super(message);
    this.name = 'ChannelConnectionError';
  }
}

/**
 * @category exception
 */
class ChannelPingTimedOutError extends ChannelError {
  constructor() {
    super('Server pong timed out');
    this.name = 'ChannelPingTimedOutError';
  }
}

/**
 * @category exception
 */
class UnexpectedChannelMessageError extends ChannelError {
  constructor(message) {
    super(message);
    this.name = 'UnexpectedChannelMessageError';
  }
}

/**
 * @category exception
 */
class ChannelIncomingMessageError extends ChannelError {
  constructor(handlerError, incomingMessage) {
    super(handlerError.message);
    this.handlerError = handlerError;
    this.incomingMessage = incomingMessage;
    this.name = 'ChannelIncomingMessageError';
  }
}

/**
 * @category exception
 */
class UnknownChannelStateError extends ChannelError {
  constructor() {
    super('State Channels FSM entered unknown state');
    this.name = 'UnknownChannelStateError';
  }
}

/**
 * @category exception
 */
class InvalidAuthDataError extends CompilerError {
  constructor(message) {
    super(message);
    this.name = 'InvalidAuthDataError';
  }
}

/**
 * @category exception
 */
class BytecodeMismatchError extends ContractError {
  constructor(source, details = '') {
    super(`Contract ${source} do not correspond to the bytecode deployed on the chain` + details);
    this.name = 'BytecodeMismatchError';
  }
}

/**
 * @category exception
 */
class DuplicateContractError extends ContractError {
  constructor() {
    super('Contract already deployed');
    this.name = 'DuplicateContractError';
  }
}

/**
 * @category exception
 */
class InactiveContractError extends ContractError {
  constructor(contractAddress) {
    super(`Contract with address ${contractAddress} not active`);
    this.name = 'InactiveContractError';
  }
}

/**
 * @category exception
 */
class InvalidMethodInvocationError extends ContractError {
  constructor(message) {
    super(message);
    this.name = 'InvalidMethodInvocationError';
  }
}

/**
 * @category exception
 */
class MissingContractAddressError extends ContractError {
  constructor(message) {
    super(message);
    this.name = 'MissingContractAddressError';
  }
}

/**
 * @category exception
 */
class MissingContractDefError extends ContractError {
  constructor() {
    super('Either ACI or sourceCode or sourceCodePath is required');
    this.name = 'MissingContractDefError';
  }
}

/**
 * @category exception
 */
class MissingFunctionNameError extends ContractError {
  constructor() {
    super('Function name is required');
    this.name = 'MissingFunctionNameError';
  }
}

/**
 * @category exception
 */
class NodeInvocationError extends ContractError {
  constructor(message, transaction) {
    super(`Invocation failed${message == null ? '' : `: "${message}"`}`);
    this.name = 'NodeInvocationError';
    this.transaction = transaction;
  }
}

/**
 * @category exception
 */
class NoSuchContractFunctionError extends ContractError {
  constructor(name) {
    super(`Function ${name} doesn't exist in contract`);
    this.name = 'NoSuchContractFunctionError';
  }
}

/**
 * @category exception
 */
class NotPayableFunctionError extends ContractError {
  constructor(amount, fn) {
    super(`You try to pay "${amount}" to function "${fn}" which is not payable. ` + 'Only payable function can accept coins');
    this.name = 'NotPayableFunctionError';
  }
}

/**
 * @category exception
 */
class MissingEventDefinitionError extends ContractError {
  constructor(eventNameHash, eventAddress) {
    super(`Can't find definition of ${eventNameHash} event emitted by ${eventAddress}` + ' (use omitUnknown option to ignore events like this)');
    this.name = 'MissingEventDefinitionError';
  }
}

/**
 * @category exception
 */
class AmbiguousEventDefinitionError extends ContractError {
  constructor(eventAddress, matchedEvents) {
    super(`Found multiple definitions of "${matchedEvents[0][1]}" event with different types emitted by` + ` ${eventAddress} in ${matchedEvents.map(([name]) => `"${name}"`).join(', ')} contracts` + ' (use contractAddressToName option to specify contract name corresponding to address)');
    this.name = 'AmbiguousEventDefinitionError';
  }
}

/**
 * @category exception
 */
class InvalidChecksumError extends CryptographyError {
  constructor() {
    super('Invalid checksum');
    this.name = 'InvalidChecksumError';
  }
}

/**
 * @category exception
 */
class MerkleTreeHashMismatchError extends CryptographyError {
  constructor() {
    super('Node hash is not equal to provided one');
    this.name = 'MerkleTreeHashMismatchError';
  }
}

/**
 * @category exception
 */
class MissingNodeInTreeError extends CryptographyError {
  constructor(message) {
    super(message);
    this.name = 'MissingNodeInTreeError';
  }
}

/**
 * @category exception
 */
class UnknownNodeLengthError extends CryptographyError {
  constructor(nodeLength) {
    super(`Unknown node length: ${nodeLength}`);
    this.name = 'UnknownNodeLengthError';
  }
}

/**
 * @category exception
 */
class UnknownPathNibbleError extends CryptographyError {
  constructor(nibble) {
    super(`Unknown path nibble: ${nibble}`);
    this.name = 'UnknownPathNibbleError';
  }
}

/**
 * @category exception
 */
class DuplicateNodeError extends NodeError {
  constructor(name) {
    super(`Node with name ${name} already exist`);
    this.name = 'DuplicateNodeError';
  }
}

/**
 * @category exception
 */
class NodeNotFoundError extends NodeError {
  constructor(message) {
    super(message);
    this.name = 'NodeNotFoundError';
  }
}

/**
 * @category exception
 */
class DecodeError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'DecodeError';
  }
}

/**
 * @category exception
 */
class PayloadLengthError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'PayloadLengthError';
  }
}

/**
 * @category exception
 */
class DryRunError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'DryRunError';
  }
}

/**
 * @category exception
 */
class IllegalBidFeeError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'IllegalBidFeeError';
  }
}

/**
 * @category exception
 */
class InvalidSignatureError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'InvalidSignatureError';
  }
}

/**
 * @category exception
 */
class PrefixNotFoundError extends TransactionError {
  constructor(tag) {
    super(`Prefix for id-tag ${tag} not found.`);
    this.name = 'PrefixNotFoundError';
  }
}

/**
 * @category exception
 */
class SchemaNotFoundError extends TransactionError {
  constructor(key, version) {
    super(`Transaction schema not implemented for tag ${key} version ${version}`);
    this.name = 'SchemaNotFoundError';
  }
}

/**
 * @category exception
 */
class TagNotFoundError extends TransactionError {
  constructor(prefix) {
    super(`Id tag for prefix ${prefix} not found.`);
    this.name = 'DecodeError';
  }
}

/**
 * @category exception
 */
class TxNotInChainError extends TransactionError {
  constructor(txHash) {
    super(`Transaction ${txHash} is removed from chain`);
    this.name = 'TxNotInChainError';
  }
}

/**
 * @category exception
 */
class AlreadyConnectedError extends WalletError {
  constructor(message) {
    super(message);
    this.name = 'AlreadyConnectedError';
  }
}

/**
 * @category exception
 */
class NoWalletConnectedError extends WalletError {
  constructor(message) {
    super(message);
    this.name = 'NoWalletConnectedError';
  }
}

/**
 * @category exception
 */
class RpcConnectionError extends WalletError {
  constructor(message) {
    super(message);
    this.name = 'RpcConnectionError';
  }
}
;// ./src/utils/amount-formatter.ts




/**
 * @deprecated no replacement implemented yet
 * @category utils
 */
let AE_AMOUNT_FORMATS = /*#__PURE__*/function (AE_AMOUNT_FORMATS) {
  AE_AMOUNT_FORMATS["AE"] = "ae";
  AE_AMOUNT_FORMATS["MILI_AE"] = "miliAE";
  AE_AMOUNT_FORMATS["MICRO_AE"] = "microAE";
  AE_AMOUNT_FORMATS["NANO_AE"] = "nanoAE";
  AE_AMOUNT_FORMATS["PICO_AE"] = "picoAE";
  AE_AMOUNT_FORMATS["FEMTO_AE"] = "femtoAE";
  AE_AMOUNT_FORMATS["AETTOS"] = "aettos";
  return AE_AMOUNT_FORMATS;
}({});

/**
 * DENOMINATION_MAGNITUDE
 */
const DENOMINATION_MAGNITUDE = {
  [AE_AMOUNT_FORMATS.AE]: 0,
  [AE_AMOUNT_FORMATS.MILI_AE]: -3,
  [AE_AMOUNT_FORMATS.MICRO_AE]: -6,
  [AE_AMOUNT_FORMATS.NANO_AE]: -9,
  [AE_AMOUNT_FORMATS.PICO_AE]: -12,
  [AE_AMOUNT_FORMATS.FEMTO_AE]: -15,
  [AE_AMOUNT_FORMATS.AETTOS]: -18
};

/**
 * Convert amount from one to other denomination
 * @deprecated no replacement implemented yet
 * @category utils
 * @param value - amount to convert
 * @param options - options
 * @param options.denomination - denomination of amount, can be ['ae', 'aettos']
 * @param options.targetDenomination - target denomination,
 * can be ['ae', 'aettos']
 */
const formatAmount = (value, {
  denomination = AE_AMOUNT_FORMATS.AETTOS,
  targetDenomination = AE_AMOUNT_FORMATS.AETTOS
}) => {
  if (!isBigNumber(value)) throw new ArgumentError('value', 'a number', value);
  return new (external_bignumber_js_default())(typeof value === 'bigint' ? value.toString() : value).shiftedBy(DENOMINATION_MAGNITUDE[denomination] - DENOMINATION_MAGNITUDE[targetDenomination]).toFixed();
};

/**
 * Convert amount to AE
 * @deprecated no replacement implemented yet
 * @category utils
 * @param value - amount to convert
 * @param options - options
 * @param options.denomination - denomination of amount, can be ['ae', 'aettos']
 */
const toAe = (value, {
  denomination = AE_AMOUNT_FORMATS.AETTOS
} = {}) => formatAmount(value, {
  denomination,
  targetDenomination: AE_AMOUNT_FORMATS.AE
});

/**
 * Convert amount to aettos
 * @deprecated no replacement implemented yet
 * @category utils
 * @param value - amount to convert
 * @param options - options
 * @param options.denomination - denomination of amount, can be ['ae', 'aettos']
 */
const toAettos = (value, {
  denomination = AE_AMOUNT_FORMATS.AE
} = {}) => formatAmount(value, {
  denomination
});
const prefixes = [{
  name: 'exa',
  magnitude: 18
}, {
  name: 'giga',
  magnitude: 9
}, {
  name: '',
  magnitude: 0
}, {
  name: 'pico',
  magnitude: -12
}];
const getNearestPrefix = exponent => prefixes.reduce((p, n) => Math.abs(n.magnitude - exponent) < Math.abs(p.magnitude - exponent) ? n : p);
const getLowerBoundPrefix = exponent => {
  var _prefixes$find;
  return (_prefixes$find = prefixes.find(p => p.magnitude <= exponent)) !== null && _prefixes$find !== void 0 ? _prefixes$find : prefixes[prefixes.length - 1];
};

/**
 * @deprecated no replacement implemented yet
 * @category utils
 */
const prefixedAmount = rawValue => {
  var _value$e;
  const value = new (external_bignumber_js_default())(rawValue);
  const exp = (_value$e = value.e) !== null && _value$e !== void 0 ? _value$e : 0;
  const {
    name,
    magnitude
  } = (exp < 0 ? getNearestPrefix : getLowerBoundPrefix)(exp);
  const v = value.shiftedBy(-magnitude).precision(9 + Math.min(exp - magnitude, 0)).toFixed();
  return `${v}${name !== '' ? ' ' : ''}${name}`;
};
// EXTERNAL MODULE: external "@azure/core-rest-pipeline"
var core_rest_pipeline_ = __webpack_require__(833);
;// ./src/utils/other.ts

const pause = async duration => new Promise(resolve => {
  setTimeout(resolve, duration);
});
const mapObject = (object, fn) => Object.fromEntries(Object.entries(object).map(fn));

// remove after dropping webpack4 support
const isWebpack4Buffer = (() => {
  try {
    Buffer.concat([Uint8Array.from([])]);
    return false;
  } catch (error) {
    return true;
  }
})();
const concatBuffers = isWebpack4Buffer ? (list, totalLength) => Buffer.concat(list.map(el => Buffer.from(el)), totalLength) : Buffer.concat;

/**
 * Object key type guard
 * @param key - Maybe object key
 * @param object - Object
 */
function isKeyOfObject(key, object) {
  return key in object;
}

/**
 * Array item type guard
 * @param item - Maybe array item
 * @param array - Array
 */
function isItemOfArray(item, array) {
  return array.includes(item);
}
function isAccountNotFoundError(error) {
  return error instanceof core_rest_pipeline_.RestError && error.statusCode === 404 && error.message.includes('Account not found');
}

// based on https://stackoverflow.com/a/50375286

// based on https://stackoverflow.com/a/61108377

function ensureError(error) {
  if (error instanceof Error) return;
  throw error;
}
;// ./src/utils/wrap-proxy.ts

function wrapWithProxy(valueCb) {
  return new Proxy({}, Object.fromEntries(['apply', 'construct', 'defineProperty', 'deleteProperty', 'getOwnPropertyDescriptor', 'getPrototypeOf', 'isExtensible', 'ownKeys', 'preventExtensions', 'set', 'setPrototypeOf', 'get', 'has'].map(name => [name, (t, ...args) => {
    const target = valueCb();
    if (target == null) throw new ArgumentError('wrapped value', 'defined', target);
    if (name === 'get' && args[0] === '_wrappedValue') return target;
    const res = Reflect[name](target, ...args);
    return typeof res === 'function' && name === 'get' ? res.bind(target) : res;
  }])));
}
function unwrapProxy(value) {
  var _wrappedValue;
  return (_wrappedValue = value._wrappedValue) !== null && _wrappedValue !== void 0 ? _wrappedValue : value;
}
// EXTERNAL MODULE: external "tweetnacl"
var external_tweetnacl_ = __webpack_require__(1655);
var external_tweetnacl_default = /*#__PURE__*/__webpack_require__.n(external_tweetnacl_);
// EXTERNAL MODULE: ./node_modules/blakejs/blake2b.js
var blake2b = __webpack_require__(4156);
;// ./src/utils/encoder-types.ts
/**
 * @category utils
 * @see {@link https://github.com/aeternity/protocol/blob/master/node/api/api_encoding.md}
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L205-L230}
 */
let Encoding = /*#__PURE__*/function (Encoding) {
  Encoding["KeyBlockHash"] = "kh";
  Encoding["MicroBlockHash"] = "mh";
  Encoding["BlockPofHash"] = "bf";
  Encoding["BlockTxHash"] = "bx";
  Encoding["BlockStateHash"] = "bs";
  Encoding["Channel"] = "ch";
  Encoding["ContractAddress"] = "ct";
  Encoding["ContractBytearray"] = "cb";
  Encoding["ContractStoreKey"] = "ck";
  Encoding["ContractStoreValue"] = "cv";
  Encoding["Transaction"] = "tx";
  Encoding["TxHash"] = "th";
  Encoding["OracleAddress"] = "ok";
  Encoding["OracleQuery"] = "ov";
  Encoding["OracleQueryId"] = "oq";
  Encoding["OracleResponse"] = "or";
  Encoding["AccountAddress"] = "ak";
  Encoding["AccountSecretKey"] = "sk";
  Encoding["Signature"] = "sg";
  Encoding["Commitment"] = "cm";
  Encoding["PeerPubkey"] = "pp";
  Encoding["Name"] = "nm";
  Encoding["State"] = "st";
  Encoding["Poi"] = "pi";
  Encoding["StateTrees"] = "ss";
  Encoding["CallStateTree"] = "cs";
  Encoding["Bytearray"] = "ba";
  return Encoding;
}({});
// EXTERNAL MODULE: external "bs58"
var external_bs58_ = __webpack_require__(4578);
var external_bs58_default = /*#__PURE__*/__webpack_require__.n(external_bs58_);
// EXTERNAL MODULE: ./node_modules/sha.js/sha256.js
var sha256 = __webpack_require__(4107);
var sha256_default = /*#__PURE__*/__webpack_require__.n(sha256);
;// ./src/utils/encoder.ts

// js extension is required for mjs build, not importing the whole package to reduce bundle size
// eslint-disable-next-line import/extensions







/**
 * Calculate SHA256 hash of `input`
 * @param input - Data to hash
 * @returns Hash
 */
function sha256hash(input) {
  return new (sha256_default())().update(input).digest();
}

/**
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L177-L202}
 */
const base64Types = [Encoding.ContractBytearray, Encoding.ContractStoreKey, Encoding.ContractStoreValue, Encoding.Transaction, Encoding.OracleQuery, Encoding.OracleResponse, Encoding.State, Encoding.Poi, Encoding.StateTrees, Encoding.CallStateTree, Encoding.Bytearray];
const base58Types = [Encoding.KeyBlockHash, Encoding.MicroBlockHash, Encoding.BlockPofHash, Encoding.BlockTxHash, Encoding.BlockStateHash, Encoding.Channel, Encoding.ContractAddress, Encoding.TxHash, Encoding.OracleAddress, Encoding.OracleQueryId, Encoding.AccountAddress, Encoding.AccountSecretKey, Encoding.Signature, Encoding.Commitment, Encoding.PeerPubkey, Encoding.Name];

/**
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L261-L286}
 */
const byteSizeForType = {
  [Encoding.KeyBlockHash]: 32,
  [Encoding.MicroBlockHash]: 32,
  [Encoding.BlockPofHash]: 32,
  [Encoding.BlockTxHash]: 32,
  [Encoding.BlockStateHash]: 32,
  [Encoding.Channel]: 32,
  [Encoding.ContractAddress]: 32,
  [Encoding.TxHash]: 32,
  [Encoding.OracleAddress]: 32,
  [Encoding.OracleQueryId]: 32,
  [Encoding.AccountAddress]: 32,
  [Encoding.AccountSecretKey]: 32,
  [Encoding.Signature]: 64,
  [Encoding.Commitment]: 32,
  [Encoding.PeerPubkey]: 32,
  [Encoding.State]: 32
};
function ensureValidLength(data, type) {
  if (!isKeyOfObject(type, byteSizeForType)) return;
  const reqLen = byteSizeForType[type];
  if (reqLen == null || data.length === reqLen) return;
  throw new PayloadLengthError(`Payload should be ${reqLen} bytes, got ${data.length} instead`);
}
const getChecksum = payload => sha256hash(sha256hash(payload)).slice(0, 4);
const addChecksum = payload => concatBuffers([payload, getChecksum(payload)]);
function getPayload(buffer) {
  const payload = buffer.slice(0, -4);
  if (!getChecksum(payload).equals(buffer.slice(-4))) throw new InvalidChecksumError();
  return payload;
}
const base64 = {
  encode: buffer => addChecksum(buffer).toString('base64'),
  decode: string => getPayload(Buffer.from(string, 'base64'))
};
const base58 = {
  encode: buffer => external_bs58_default().encode(addChecksum(buffer)),
  decode: string => getPayload(Buffer.from(external_bs58_default().decode(string)))
};
const parseType = maybeType => {
  const base64Type = base64Types.find(t => t === maybeType);
  if (base64Type != null) return [base64Type, base64];
  const base58Type = base58Types.find(t => t === maybeType);
  if (base58Type != null) return [base58Type, base58];
  throw new ArgumentError('prefix', `one of ${[...base58Types, ...base64Types].join(', ')}`, maybeType);
};

/**
 * Decode data using the default encoding/decoding algorithm
 * @param data - An Base58/64check encoded and prefixed string
 * (ex tx_..., sg_..., ak_....)
 * @returns Decoded data
 * @category utils
 */
function decode(data) {
  const [prefix, encodedPayload, extra] = data.split('_');
  if (encodedPayload == null) throw new DecodeError(`Encoded string missing payload: ${data}`);
  if (extra != null) throw new DecodeError(`Encoded string have extra parts: ${data}`);
  const [type, encoder] = parseType(prefix);
  const payload = encoder.decode(encodedPayload);
  ensureValidLength(payload, type);
  return payload;
}

/**
 * Encode data using the default encoding/decoding algorithm
 * @param data - An decoded data
 * @param type - Prefix of Transaction
 * @returns Encoded string Base58check or Base64check data
 * @category utils
 */
function encode(data, type) {
  const [, encoder] = parseType(type);
  ensureValidLength(data, type);
  return `${type}_${encoder.encode(data)}`;
}
;// ./src/utils/crypto.ts

// js extension is required for mjs build, not importing the whole package to reduce bundle size
// eslint-disable-next-line import/extensions





/**
 * Check if address is valid
 * @param maybeAddress - Address to check
 * @category utils
 * @deprecated Use {@link isEncoded} instead
 */

/**
 * Check if data is encoded in one of provided encodings
 * @param maybeEncoded - Data to check
 * @param encodings - Rest parameters with encodings to check against
 * @deprecated Use {@link isEncoded} instead
 */

function isAddressValid(maybeEncoded, ...encodings) {
  if (encodings.length === 0) encodings = [Encoding.AccountAddress];
  try {
    decode(maybeEncoded);
    const encoding = maybeEncoded.split('_')[0];
    if (!isItemOfArray(encoding, encodings)) {
      throw new ArgumentError('Encoded string type', encodings.length > 1 ? `one of ${encodings.join(', ')}` : encodings[0], encoding);
    }
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Check if data is encoded in any encoding
 * @param maybeEncoded - Data to check
 * @category utils
 */

/**
 * Check if data is encoded in one of provided encodings
 * @param maybeEncoded - Data to check
 * @param encodings - Rest parameters with encodings to check against
 */

function ensureEncoded(maybeEncoded, ...encodings) {
  decode(maybeEncoded);
  if (encodings.length === 0) return;
  const encoding = maybeEncoded.split('_')[0];
  if (isItemOfArray(encoding, encodings)) return;
  throw new ArgumentError('Encoded string type', encodings.length > 1 ? `one of ${encodings.join(', ')}` : encodings[0], encoding);
}

/**
 * Check if data is encoded in any encoding
 * @param maybeEncoded - Data to check
 * @category utils
 */

/**
 * Check if data is encoded in one of provided encodings
 * @param maybeEncoded - Data to check
 * @param encodings - Rest parameters with encodings to check against
 */

function isEncoded(maybeEncoded, ...encodings) {
  try {
    ensureEncoded(maybeEncoded, ...encodings);
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Generate a random salt (positive integer)
 * @returns random salt
 * @category utils
 */
function genSalt() {
  const [random] = new BigUint64Array(external_tweetnacl_default().randomBytes(8).buffer);
  return Number(random % BigInt(Number.MAX_SAFE_INTEGER));
}

/**
 * Converts a positive integer to the smallest possible
 * representation in a binary digit representation
 * @param value - Value to encode
 * @returns Encoded number
 * @category utils
 * @deprecated This function is out of the sdk scope. Copy implementation from sdk if necessary.
 */
function encodeUnsigned(value) {
  const binary = Buffer.allocUnsafe(4);
  binary.writeUInt32BE(value);
  return binary.subarray(binary.findIndex(i => i !== 0));
}

/**
 * Calculate 256bits Blake2b hash of `input`
 * @param input - Data to hash
 * @returns Hash
 * @category utils
 * @deprecated use "blakejs" package directly
 */
function hash(input) {
  return Buffer.from((0,blake2b.blake2b)(input, undefined, 32)); // 256 bits
}

/**
 * Verify that data was signed by account
 * @param data - Data that was signed
 * @param signature - Signature of data
 * @param address - Address of account to verify against
 * @returns is data was signed by account
 * @category utils
 */
function verifySignature(data, signature, address) {
  return external_tweetnacl_default().sign.detached.verify(data, signature, decode(address));
}
function encodeVarUInt(value) {
  if (value < 0xfd) {
    return Buffer.from([value]);
  }
  if (value <= 0xffff) {
    return concatBuffers([Buffer.from([0xfd]), Buffer.from(new Uint16Array([value]).buffer)]);
  }
  if (value <= 0xffffffff) {
    return concatBuffers([Buffer.from([0xfe]), Buffer.from(new Uint32Array([value]).buffer)]);
  }
  return concatBuffers([Buffer.from([0xff]), Buffer.from(new BigUint64Array([BigInt(value)]).buffer)]);
}
const messagePrefix = Buffer.from('aeternity Signed Message:\n', 'utf8');
const messagePrefixLength = encodeVarUInt(messagePrefix.length);

/**
 * Hash message
 * @param message - Message to hash
 * @returns Hash of message
 * @category utils
 */
function hashMessage(message) {
  const msg = Buffer.from(message, 'utf8');
  return hash(concatBuffers([messagePrefixLength, messagePrefix, encodeVarUInt(msg.length), msg]));
}

/**
 * Verify that message was signed by address
 * @param message - Message that was signed
 * @param signature - Signature of message
 * @param address - Address to verify against
 * @returns is data was signed by address
 * @category utils
 */
function verifyMessageSignature(message, signature, address) {
  return verifySignature(hashMessage(message), signature, address);
}
;// ./src/utils/bytes.ts



/**
 * Convert string, number, or BigNumber to byte array
 * @param val - value to convert
 * @param big - enables force conversion to BigNumber
 * @returns Buffer
 * @category utils
 * @deprecated use `Buffer.from(<string>)` or `Buffer.from(<number>.toString(16), 'hex')` instead
 */
// eslint-disable-next-line import/prefer-default-export
function toBytes(val, big = false) {
  // Encode a value to bytes.
  // If the value is an int it will be encoded as bytes big endian
  // Raises ValueError if the input is not an int or string

  if (val == null) return Buffer.from([]);
  if (Number.isInteger(val) || external_bignumber_js_default().isBigNumber(val) || big) {
    if (!external_bignumber_js_default().isBigNumber(val)) val = new (external_bignumber_js_default())(val);
    if (!val.isInteger()) throw new errors_TypeError(`Unexpected not integer value: ${val.toFixed()}`);
    let hexString = val.toString(16);
    if (hexString.length % 2 === 1) hexString = `0${hexString}`;
    return Buffer.from(hexString, 'hex');
  }
  if (typeof val === 'string') {
    return Buffer.from(val);
  }
  throw new NoSerializerFoundError();
}
;// ./src/tx/builder/constants.ts



/**
 * @category transaction builder
 */
const DRY_RUN_ACCOUNT = {
  pub: 'ak_11111111111111111111111111111111273Yts',
  amount: 100000000000000000000000000000000000n
};

/**
 * @category account generalized
 * @deprecated transaction builder will ensure that gas doesn't exceed the maximum value by itself
 */
const MAX_AUTH_FUN_GAS = 50000;
/**
 * @category utils
 */

/**
 * @category AENS
 */

/**
 * @category transaction builder
 */
const MIN_GAS_PRICE = 1e9; // TODO: don't use number for ae
/**
 * @category AENS
 * @see {@link https://github.com/aeternity/aeternity/blob/72e440b8731422e335f879a31ecbbee7ac23a1cf/apps/aecore/src/aec_governance.erl#L67}
 * @deprecated use {@link getMinimumNameFee} instead
 */
const NAME_FEE_MULTIPLIER = 1e14;
/**
 * The next bid should be at least 5% bigger than the previous one
 * @category AENS
 * @deprecated use {@link computeBidFee} instead
 */
const NAME_FEE_BID_INCREMENT = 0.05;
/**
 * Approximately 1 day
 * @category AENS
 * @see {@link https://github.com/aeternity/aeternity/blob/72e440b8731422e335f879a31ecbbee7ac23a1cf/apps/aecore/src/aec_governance.erl#L272}
 * @deprecated use {@link computeAuctionEndBlock} instead
 */
const NAME_BID_TIMEOUT_BLOCKS = 480;
/**
 * This is the max length for a domain that requires a base fee to be paid
 * @category AENS
 * @deprecated use {@link getMinimumNameFee} instead
 */
const NAME_MAX_LENGTH_FEE = 31;
/**
 * @category AENS
 * @see {@link https://github.com/aeternity/aeternity/blob/72e440b8731422e335f879a31ecbbee7ac23a1cf/apps/aecore/src/aec_governance.erl#L290}
 * @see {@link https://github.com/aeternity/protocol/blob/master/AENS.md#protocol-fees-and-protection-times}
 * @deprecated use {@link getMinimumNameFee} instead
 */
const NAME_BID_RANGES = mapObject({
  31: 3,
  30: 5,
  29: 8,
  28: 13,
  27: 21,
  26: 34,
  25: 55,
  24: 89,
  23: 144,
  22: 233,
  21: 377,
  20: 610,
  19: 987,
  18: 1597,
  17: 2584,
  16: 4181,
  15: 6765,
  14: 10946,
  13: 17711,
  12: 28657,
  11: 46368,
  10: 75025,
  9: 121393,
  8: 196418,
  7: 317811,
  6: 514229,
  5: 832040,
  4: 1346269,
  3: 2178309,
  2: 3524578,
  1: 5702887
}, ([key, value]) => [key, new (external_bignumber_js_default())(value).times(NAME_FEE_MULTIPLIER)]);

/**
 * @category chain
 */
let ConsensusProtocolVersion = /*#__PURE__*/function (ConsensusProtocolVersion) {
  ConsensusProtocolVersion[ConsensusProtocolVersion["Ceres"] = 6] = "Ceres";
  return ConsensusProtocolVersion;
}({});

/**
 * @category contract
 * @see {@link https://github.com/aeternity/protocol/blob/0f6dee3d9d1e8e2469816798f5c7587a6c918f94/contracts/contract_vms.md#virtual-machines-on-the-%C3%A6ternity-blockchain}
 */
let VmVersion = /*#__PURE__*/function (VmVersion) {
  VmVersion[VmVersion["NoVm"] = 0] = "NoVm";
  VmVersion[VmVersion["Sophia"] = 1] = "Sophia";
  VmVersion[VmVersion["SophiaImprovementsMinerva"] = 3] = "SophiaImprovementsMinerva";
  VmVersion[VmVersion["SophiaImprovementsFortuna"] = 4] = "SophiaImprovementsFortuna";
  VmVersion[VmVersion["Fate"] = 5] = "Fate";
  VmVersion[VmVersion["SophiaImprovementsLima"] = 6] = "SophiaImprovementsLima";
  VmVersion[VmVersion["Fate2"] = 7] = "Fate2";
  VmVersion[VmVersion["Fate3"] = 8] = "Fate3";
  return VmVersion;
}({});

/**
 * @category contract
 * @see {@link https://github.com/aeternity/protocol/blob/0f6dee3d9d1e8e2469816798f5c7587a6c918f94/contracts/contract_vms.md#virtual-machines-on-the-%C3%A6ternity-blockchain}
 */
let AbiVersion = /*#__PURE__*/function (AbiVersion) {
  AbiVersion[AbiVersion["NoAbi"] = 0] = "NoAbi";
  AbiVersion[AbiVersion["Sophia"] = 1] = "Sophia";
  AbiVersion[AbiVersion["Fate"] = 3] = "Fate";
  return AbiVersion;
}({});

/**
 * Enum with tag types
 * @category transaction builder
 * @see {@link https://github.com/aeternity/protocol/blob/0f6dee3d9d1e8e2469816798f5c7587a6c918f94/serializations.md#binary-serialization}
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_chain_objects.erl#L39-L97}
 */
// TODO: implement serialisation for commented-out tags
let Tag = /*#__PURE__*/function (Tag) {
  Tag[Tag["SignedTx"] = 11] = "SignedTx";
  Tag[Tag["SpendTx"] = 12] = "SpendTx";
  Tag[Tag["OracleRegisterTx"] = 22] = "OracleRegisterTx";
  Tag[Tag["OracleQueryTx"] = 23] = "OracleQueryTx";
  /**
   * @deprecated use `OracleRespondTx` instead
   */
  Tag[Tag["OracleResponseTx"] = 24] = "OracleResponseTx";
  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
  Tag[Tag["OracleRespondTx"] = 24] = "OracleRespondTx";
  Tag[Tag["OracleExtendTx"] = 25] = "OracleExtendTx";
  Tag[Tag["NameClaimTx"] = 32] = "NameClaimTx";
  Tag[Tag["NamePreclaimTx"] = 33] = "NamePreclaimTx";
  Tag[Tag["NameUpdateTx"] = 34] = "NameUpdateTx";
  Tag[Tag["NameRevokeTx"] = 35] = "NameRevokeTx";
  Tag[Tag["NameTransferTx"] = 36] = "NameTransferTx";
  Tag[Tag["ContractCreateTx"] = 42] = "ContractCreateTx";
  Tag[Tag["ContractCallTx"] = 43] = "ContractCallTx";
  Tag[Tag["ChannelCreateTx"] = 50] = "ChannelCreateTx";
  Tag[Tag["ChannelDepositTx"] = 51] = "ChannelDepositTx";
  Tag[Tag["ChannelWithdrawTx"] = 52] = "ChannelWithdrawTx";
  Tag[Tag["ChannelForceProgressTx"] = 521] = "ChannelForceProgressTx";
  Tag[Tag["ChannelCloseMutualTx"] = 53] = "ChannelCloseMutualTx";
  Tag[Tag["ChannelCloseSoloTx"] = 54] = "ChannelCloseSoloTx";
  Tag[Tag["ChannelSlashTx"] = 55] = "ChannelSlashTx";
  Tag[Tag["ChannelSettleTx"] = 56] = "ChannelSettleTx";
  Tag[Tag["ChannelOffChainTx"] = 57] = "ChannelOffChainTx";
  Tag[Tag["ChannelSnapshotSoloTx"] = 59] = "ChannelSnapshotSoloTx";
  Tag[Tag["GaAttachTx"] = 80] = "GaAttachTx";
  Tag[Tag["GaMetaTx"] = 81] = "GaMetaTx";
  Tag[Tag["PayingForTx"] = 82] = "PayingForTx";
  return Tag;
}({});
;// ./src/tx/builder/helpers.ts









/**
 * JavaScript-based Transaction builder helper function's
 */

/**
 * Build a contract address
 * @category contract
 * @param owner - Address of contract owner
 * @param nonce - Nonce of ContractCreateTx or state channel round when contract was created
 * @returns Contract address
 */
function buildContractId(owner, nonce) {
  const ownerIdAndNonce = Buffer.from([...decode(owner), ...toBytes(nonce)]);
  const b2bHash = hash(ownerIdAndNonce);
  return encode(b2bHash, Encoding.ContractAddress);
}

// TODO: add `build` prefix the same as others
/**
 * Build a oracle query id
 * @category oracle
 * @param senderId - The public key of the sender account
 * @param nonce - the nonce of the transaction
 * @param oracleId - The oracle public key
 * @returns Contract public key
 */
function oracleQueryId(senderId, nonce, oracleId) {
  function _int32(val) {
    const nonceBE = toBytes(val, true);
    return concatBuffers([Buffer.alloc(32 - nonceBE.length), nonceBE]);
  }
  const b2bHash = hash(Buffer.from([...decode(senderId), ..._int32(nonce), ...decode(oracleId)]));
  return encode(b2bHash, Encoding.OracleQueryId);
}
const AENS_SUFFIX = '.chain';
function nameToPunycode(maybeName) {
  const [name, suffix, ...other] = maybeName.split('.');
  if (other.length !== 0) throw new ArgumentError('aens name', 'including only one dot', maybeName);
  if (suffix !== AENS_SUFFIX.slice(1)) {
    throw new ArgumentError('aens name', `suffixed with ${AENS_SUFFIX}`, maybeName);
  }
  if (/\p{Emoji_Presentation}/u.test(name)) {
    throw new ArgumentError('aens name', 'not containing emoji', maybeName);
  }
  if (name[2] === '-' && name[3] === '-') {
    throw new ArgumentError('aens name', 'without "-" char in both the third and fourth positions', maybeName);
  }
  if (name[0] === '-') {
    throw new ArgumentError('aens name', 'starting with no "-" char', maybeName);
  }
  if (name.at(-1) === '-') {
    throw new ArgumentError('aens name', 'ending with no "-" char', maybeName);
  }
  let punycode;
  try {
    const u = new URL(`http://${name}.${suffix}`);
    if (u.username + u.password + u.port + u.search + u.hash !== '' || u.pathname !== '/') {
      throw new ArgumentError('aens name', 'valid', maybeName);
    }
    punycode = u.host;
  } catch (error) {
    if (error instanceof TypeError && error.message.includes('Invalid URL')) {
      throw new ArgumentError('aens name', 'valid', maybeName);
    }
    throw error;
  }
  if (!/^[a-z0-9.-]+$/i.test(punycode)) {
    throw new ArgumentError('aens name', 'without illegal chars', maybeName);
  }
  if (punycode.length > 63 + AENS_SUFFIX.length) {
    throw new ArgumentError('aens name', 'not too long', maybeName);
  }
  return punycode;
}

// TODO: replace `produce` with `build` the same as others
/**
 * Encode an AENS name
 * @category AENS
 * @param name - Name to encode
 * @returns `nm_` prefixed encoded AENS name
 */
function produceNameId(name) {
  return encode(hash(nameToPunycode(name)), Encoding.Name);
}

// TODO: add `build` the same as others
/**
 * Generate the commitment hash by hashing the salt and
 * name, base 58 encoding the result and prepending 'cm_'
 * @category transaction builder
 * @param name - Name to be registered
 * @param salt - Random number
 * @returns Commitment hash
 */
function commitmentHash(name, salt = genSalt()) {
  return encode(hash(concatBuffers([Buffer.from(nameToPunycode(name)), Buffer.from(salt.toString(16).padStart(64, '0'), 'hex')])), Encoding.Commitment);
}

/**
 * Utility function to convert bytes to int
 * @category utils
 * @param buffer - Value
 * @returns Buffer Buffer from number(BigEndian)
 * @deprecated use `BigInt('0x' + <buffer>.toString('hex')).toString()` instead
 */
function readInt(buffer = Buffer.from([])) {
  return BigInt('0x' + Buffer.from(buffer).toString('hex')).toString();
}

/**
 * Ensure that name is valid AENS name, would throw an exception otherwise
 * @category AENS
 * @param maybeName - AENS name
 */
function ensureName(maybeName) {
  nameToPunycode(maybeName);
}

/**
 * Is AENS name valid
 * @category AENS
 * @param maybeName - AENS name
 */
function isName(maybeName) {
  try {
    ensureName(maybeName);
    return true;
  } catch (error) {
    return false;
  }
}
const encodingToPointerKey = [[Encoding.AccountAddress, 'account_pubkey'], [Encoding.OracleAddress, 'oracle_pubkey'], [Encoding.ContractAddress, 'contract_pubkey'], [Encoding.Channel, 'channel']];

/**
 * @category AENS
 * @param identifier - account/oracle/contract address, or channel
 * @returns default AENS pointer key
 */
function getDefaultPointerKey(identifier) {
  decode(identifier);
  const encoding = identifier.substring(0, 2);
  const result = encodingToPointerKey.find(([e]) => e === encoding)?.[1];
  if (result != null) return result;
  throw new ArgumentError('identifier', `prefixed with one of ${encodingToPointerKey.map(([e]) => `${e}_`).join(', ')}`, identifier);
}

/**
 * Get the minimum AENS name fee
 * @category AENS
 * @param name - the AENS name to get the fee for
 * @returns the minimum fee for the AENS name auction
 */
function getMinimumNameFee(name) {
  const nameLength = nameToPunycode(name).length - AENS_SUFFIX.length;
  return NAME_BID_RANGES[Math.min(nameLength, NAME_MAX_LENGTH_FEE)];
}

/**
 * Compute bid fee for AENS auction
 * @category AENS
 * @param name - the AENS name to get the fee for
 * @param options - Options
 * @param options.startFee - Auction start fee
 * @param options.increment - Bid multiplier(In percentage, must be between 0 and 1)
 * @returns Bid fee
 */
function computeBidFee(name, {
  startFee,
  increment = NAME_FEE_BID_INCREMENT
} = {}) {
  if (!(Number(increment) === increment && increment % 1 !== 0)) throw new IllegalBidFeeError(`Increment must be float. Current increment ${increment}`);
  if (increment < NAME_FEE_BID_INCREMENT) throw new IllegalBidFeeError(`minimum increment percentage is ${NAME_FEE_BID_INCREMENT}`);
  // FIXME: increment should be used somehow here
  return ceil(new (external_bignumber_js_default())(startFee !== null && startFee !== void 0 ? startFee : getMinimumNameFee(name)).times(new (external_bignumber_js_default())(NAME_FEE_BID_INCREMENT).plus(1)));
}

/**
 * Compute approximate auction end height.
 *
 * From Ceres, each time a new (successful!) bid is made for a name the auction is extended for up
 * to 120 key-blocks/generations. I.e. after the bid there is always at least 120 generations to
 * make a higher bid.
 *
 * @category AENS
 * @param name - Name to compute auction end for
 * @param claimHeight - Auction starting height
 * @see {@link https://github.com/aeternity/protocol/blob/cfb19ce/AENS.md#from-ceres-protocol-upgrade}
 * @returns Auction end height
 */
function computeAuctionEndBlock(name, claimHeight) {
  var _ref, _ref2, _ref3;
  const length = nameToPunycode(name).length - AENS_SUFFIX.length;
  const h = (_ref = (_ref2 = (_ref3 = length <= 4 ? 2400 : null) !== null && _ref3 !== void 0 ? _ref3 : length <= 8 ? 960 : null) !== null && _ref2 !== void 0 ? _ref2 : length <= 12 ? 480 : null) !== null && _ref !== void 0 ? _ref : 0;
  return h + claimHeight;
}

/**
 * Is name accept going to auction
 * @category AENS
 */
function isAuctionName(name) {
  return nameToPunycode(name).length < 13 + AENS_SUFFIX.length;
}
;// ./src/chain.ts







async function getEventInterval(type, {
  _expectedMineRate,
  _microBlockCycle,
  onNode
}) {
  if (_expectedMineRate != null && type === 'key-block') return _expectedMineRate;
  if (_microBlockCycle != null && type === 'micro-block') return _microBlockCycle;
  const networkId = await onNode.getNetworkId();
  if (networkId === 'ae_dev') return 0;
  if (!['ae_mainnet', 'ae_uat'].includes(networkId) && (await onNode._isHyperchain())) return 3000;
  if (type === 'key-block') return 180000;else return 3000;
}

/**
 * @category chain
 * @param type - Type
 * @param options - Options
 */
async function _getPollInterval(type, options) {
  return Math.floor((await getEventInterval(type, options)) / 3);
}
const heightCache = new WeakMap();

/**
 * Obtain current height of the chain
 * @category chain
 * @param options - Options
 * @param options.cached - Get height from the cache. The lag behind the actual height shouldn't
 * be more than 1 block. Use if needed to reduce requests count, and approximate value can be used.
 * For example, for timeout check in transaction status polling.
 * @returns Current chain height
 */
async function getHeight({
  cached = false,
  ...options
}) {
  const onNode = unwrapProxy(options.onNode);
  if (cached) {
    const cache = heightCache.get(onNode);
    if (cache != null && cache.time > Date.now() - (await _getPollInterval('key-block', options))) {
      return cache.height;
    }
  }
  const {
    height
  } = await onNode.getCurrentKeyBlockHeight();
  heightCache.set(onNode, {
    height,
    time: Date.now()
  });
  return height;
}

/**
 * Return transaction details if it is mined, fail otherwise.
 * If the transaction has ttl specified then would wait till it leaves the mempool.
 * Otherwise would fail if a specified amount of blocks were mined.
 * @category chain
 * @param th - The hash of transaction to poll
 * @param options - Options
 * @param options.interval - Interval (in ms) at which to poll the chain
 * @param options.blocks - Number of blocks mined after which to fail if transaction ttl is not set
 * @param options.onNode - Node to use
 * @returns The transaction as it was mined
 */
async function poll(th, {
  blocks = 5,
  interval,
  ...options
}) {
  interval !== null && interval !== void 0 ? interval : interval = await _getPollInterval('micro-block', options);
  let max;
  do {
    const tx = await options.onNode.getTransactionByHash(th);
    if (tx.blockHeight !== -1) return tx;
    if (max == null) {
      max = tx.tx.ttl !== 0 ? -1 : (await getHeight({
        ...options,
        cached: true
      })) + blocks;
    }
    await pause(interval);
  } while (max === -1 ? true : (await getHeight({
    ...options,
    cached: true
  })) < max);
  throw new TxTimedOutError(blocks, th);
}

/**
 * Wait for the chain to reach a specific height
 * @category chain
 * @param height - Height to wait for
 * @param options - Options
 * @param options.interval - Interval (in ms) at which to poll the chain
 * @param options.onNode - Node to use
 * @returns Current chain height
 */
async function awaitHeight(height, {
  interval,
  ...options
}) {
  interval !== null && interval !== void 0 ? interval : interval = Math.min(await _getPollInterval('key-block', options), 5000);
  let currentHeight;
  do {
    if (currentHeight != null) await pause(interval);
    currentHeight = await getHeight(options);
  } while (currentHeight < height);
  return currentHeight;
}

/**
 * Wait for transaction confirmation
 * @category chain
 * @param txHash - Transaction hash
 * @param options - Options
 * @param options.confirm - Number of micro blocks to wait for transaction confirmation
 * @param options.onNode - Node to use
 * @returns Current Height
 */
async function waitForTxConfirm(txHash, {
  confirm = 3,
  onNode,
  ...options
}) {
  const {
    blockHeight
  } = await onNode.getTransactionByHash(txHash);
  const height = await awaitHeight(blockHeight + confirm, {
    onNode,
    ...options
  });
  const {
    blockHeight: newBlockHeight
  } = await onNode.getTransactionByHash(txHash);
  switch (newBlockHeight) {
    case -1:
      throw new TxNotInChainError(txHash);
    case blockHeight:
      return height;
    default:
      return waitForTxConfirm(txHash, {
        onNode,
        confirm,
        ...options
      });
  }
}

/**
 * Get account by account public key
 * @category chain
 * @param address - Account address (public key)
 * @param options - Options
 * @param options.height - Get account on specific block by block height
 * @param options.hash - Get account on specific block by micro block hash or key block hash
 * @param options.onNode - Node to use
 */
async function getAccount(address, {
  height,
  hash,
  onNode
}) {
  if (height != null) return onNode.getAccountByPubkeyAndHeight(address, height);
  if (hash != null) return onNode.getAccountByPubkeyAndHash(address, hash);
  return onNode.getAccountByPubkey(address);
}

/**
 * Request the balance of specified account
 * @category chain
 * @param address - The public account address to obtain the balance for
 * @param options - Options
 * @param options.format
 * @param options.height - The chain height at which to obtain the balance for
 * (default: top of chain)
 * @param options.hash - The block hash on which to obtain the balance for (default: top of chain)
 */
async function getBalance(address, {
  /**
   * @deprecated no replacement implemented yet
   */
  format = AE_AMOUNT_FORMATS.AETTOS,
  ...options
}) {
  const addr = address.startsWith('ok_') ? encode(decode(address), Encoding.AccountAddress) : address;
  const {
    balance
  } = await getAccount(addr, options).catch(error => {
    if (!isAccountNotFoundError(error)) throw error;
    return {
      balance: 0n
    };
  });
  return formatAmount(balance, {
    targetDenomination: format
  });
}

/**
 * Obtain current generation
 * @category chain
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Current Generation
 * @deprecated Use {@link Node.getCurrentGeneration} instead
 */
async function getCurrentGeneration({
  onNode
}) {
  return onNode.getCurrentGeneration();
}

/**
 * Get generation by hash or height
 * @category chain
 * @param hashOrHeight - Generation hash or height
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Generation
 * @deprecated Use {@link Node.getGenerationByHash} or {@link Node.getGenerationByHeight} instead
 */
async function getGeneration(hashOrHeight, {
  onNode
}) {
  if (typeof hashOrHeight === 'number') return onNode.getGenerationByHeight(hashOrHeight);
  return onNode.getGenerationByHash(hashOrHeight);
}

/**
 * Get micro block transactions
 * @category chain
 * @param hash - Micro block hash
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Transactions
 * @deprecated Use {@link Node.getMicroBlockTransactionsByHash} instead
 */
async function getMicroBlockTransactions(hash, {
  onNode
}) {
  return (await onNode.getMicroBlockTransactionsByHash(hash)).transactions;
}

/**
 * Get key block
 * @category chain
 * @param hashOrHeight - Key block hash or height
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Key Block
 * @deprecated Use {@link Node.getKeyBlockByHeight} or {@link Node.getKeyBlockByHash} instead
 */
async function getKeyBlock(hashOrHeight, {
  onNode
}) {
  if (typeof hashOrHeight === 'number') return onNode.getKeyBlockByHeight(hashOrHeight);
  return onNode.getKeyBlockByHash(hashOrHeight);
}

/**
 * Get micro block header
 * @category chain
 * @param hash - Micro block hash
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Micro block header
 * @deprecated Use {@link Node.getMicroBlockHeaderByHash} instead
 */
async function getMicroBlockHeader(hash, {
  onNode
}) {
  return onNode.getMicroBlockHeaderByHash(hash);
}
const txDryRunRequests = new Map();
async function txDryRunHandler(key, onNode) {
  const rs = txDryRunRequests.get(key);
  txDryRunRequests.delete(key);
  if (rs == null) throw new InternalError("Can't get dry-run request");
  let dryRunRes;
  try {
    const top = typeof rs[0].top === 'number' ? (await onNode.getKeyBlockByHeight(rs[0].top)).hash : rs[0].top;
    dryRunRes = await onNode.protectedDryRunTxs({
      top,
      txEvents: rs[0].txEvents,
      txs: rs.map(req => ({
        tx: req.tx
      })),
      accounts: Array.from(new Set(rs.map(req => req.accountAddress))).map(pubKey => ({
        pubKey,
        amount: DRY_RUN_ACCOUNT.amount
      }))
    });
  } catch (error) {
    rs.forEach(({
      reject
    }) => reject(error));
    return;
  }
  const {
    results,
    txEvents
  } = dryRunRes;
  results.forEach(({
    result,
    reason,
    ...resultPayload
  }, idx) => {
    const {
      resolve,
      reject,
      tx,
      accountAddress
    } = rs[idx];
    if (result === 'ok') resolve({
      ...resultPayload,
      txEvents
    });else reject(Object.assign(new DryRunError(reason), {
      tx,
      accountAddress
    }));
  });
}

/**
 * Transaction dry-run
 * @category chain
 * @param tx - transaction to execute
 * @param accountAddress - address that will be used to execute transaction
 * @param options - Options
 * @param options.top - hash of block on which to make dry-run
 * @param options.txEvents - collect and return on-chain tx events that would result from the call
 * @param options.combine - Enables combining of similar requests to a single dry-run call
 * @param options.onNode - Node to use
 */
async function txDryRun(tx, accountAddress, {
  top,
  txEvents,
  combine,
  onNode
}) {
  var _txDryRunRequests$get;
  const key = combine === true ? [top, txEvents].join() : 'immediate';
  const requests = (_txDryRunRequests$get = txDryRunRequests.get(key)) !== null && _txDryRunRequests$get !== void 0 ? _txDryRunRequests$get : [];
  txDryRunRequests.set(key, requests);
  return new Promise((resolve, reject) => {
    var _requests$timeout;
    requests.push({
      tx,
      accountAddress,
      top,
      txEvents,
      resolve,
      reject
    });
    if (combine !== true) {
      void txDryRunHandler(key, onNode);
      return;
    }
    (_requests$timeout = requests.timeout) !== null && _requests$timeout !== void 0 ? _requests$timeout : requests.timeout = setTimeout(() => {
      void txDryRunHandler(key, onNode);
    });
  });
}

/**
 * Get contract byte code
 * @category contract
 * @param contractId - Contract address
 * @param options - Options
 * @param options.onNode - Node to use
 * @deprecated Use {@link Node.getContractCode} instead
 */
async function getContractByteCode(contractId, {
  onNode
}) {
  return onNode.getContractCode(contractId);
}

/**
 * Get contract entry
 * @category contract
 * @param contractId - Contract address
 * @param options - Options
 * @param options.onNode - Node to use
 * @deprecated Use {@link Node.getContract} instead
 */
async function getContract(contractId, {
  onNode
}) {
  return onNode.getContract(contractId);
}

/**
 * Get name entry
 * @category AENS
 * @param name - AENS name
 * @param options - Options
 * @param options.onNode - Node to use
 * @deprecated Use {@link Node.getNameEntryByName} or {@link Name.getState} instead
 */
async function getName(name, {
  onNode
}) {
  return onNode.getNameEntryByName(name);
}

/**
 * Resolve AENS name and return name hash
 * @category AENS
 * @param nameOrId - AENS name or address
 * @param key - in AENS pointers record
 * @param options - Options
 * @param options.verify - To ensure that name exist and have a corresponding pointer
 * // TODO: avoid that to don't trust to current api gateway
 * @param options.resolveByNode - Enables pointer resolving using node
 * @param options.onNode - Node to use
 * @returns Address or AENS name hash
 */
async function resolveName(nameOrId, key, {
  verify = true,
  resolveByNode = false,
  onNode
}) {
  if (isName(nameOrId)) {
    if (verify || resolveByNode) {
      const name = await onNode.getNameEntryByName(nameOrId);
      const pointer = name.pointers.find(p => p.key === key);
      if (pointer == null) throw new AensPointerContextError(nameOrId, key);
      if (resolveByNode) return pointer.id;
    }
    return produceNameId(nameOrId);
  }
  try {
    decode(nameOrId);
    return nameOrId;
  } catch (error) {
    throw new InvalidAensNameError(`Invalid name or address: ${nameOrId}`);
  }
}
;// ./src/tx/builder/field-types/ct-version.ts

/*
 * First abi/vm by default
 * @see {@link https://github.com/aeternity/protocol/blob/71cf111/contracts/contract_vms.md#virtual-machines-on-the-ternity-blockchain}
 */
const ProtocolToVmAbi = {
  [ConsensusProtocolVersion.Ceres]: {
    'contract-create': {
      vmVersion: [VmVersion.Fate3],
      abiVersion: [AbiVersion.Fate]
    },
    'contract-call': {
      vmVersion: [],
      abiVersion: [AbiVersion.Fate]
    },
    'oracle-call': {
      vmVersion: [],
      abiVersion: [AbiVersion.NoAbi, AbiVersion.Fate]
    }
  }
};
function getProtocolDetails(protocolVersion, type) {
  var _protocol$vmVersion$;
  const protocol = ProtocolToVmAbi[protocolVersion][type];
  return {
    vmVersion: (_protocol$vmVersion$ = protocol.vmVersion[0]) !== null && _protocol$vmVersion$ !== void 0 ? _protocol$vmVersion$ : VmVersion.Fate2,
    abiVersion: protocol.abiVersion[0]
  };
}
/* harmony default export */ const ct_version = ({
  serialize(value, params, {
    consensusProtocolVersion = ConsensusProtocolVersion.Ceres
  }) {
    value !== null && value !== void 0 ? value : value = getProtocolDetails(consensusProtocolVersion, 'contract-create');
    return Buffer.from([value.vmVersion, 0, value.abiVersion]);
  },
  async prepare(value, params,
  // TODO: { consensusProtocolVersion: ConsensusProtocolVersion } | { onNode: Node } | {}
  options) {
    if (value != null) return value;
    if (options.consensusProtocolVersion != null) return undefined;
    if (Object.keys(ConsensusProtocolVersion).length === 2) return undefined;
    if (options.onNode != null) {
      return getProtocolDetails((await options.onNode.getNodeInfo()).consensusProtocolVersion, 'contract-create');
    }
    return undefined;
  },
  deserialize(buffer) {
    const [vm,, abi] = buffer;
    return {
      vmVersion: +vm,
      abiVersion: +abi
    };
  }
});
;// ./src/tx/builder/field-types/abi-version.ts


/* harmony default export */ const abi_version = ({
  _getProtocolDetails(c, tag) {
    const kind = Tag.ContractCallTx === tag || Tag.GaMetaTx === tag ? 'contract-call' : 'oracle-call';
    return getProtocolDetails(c, kind).abiVersion;
  },
  serialize(value, {
    tag
  }, {
    consensusProtocolVersion = ConsensusProtocolVersion.Ceres
  }) {
    const result = value !== null && value !== void 0 ? value : this._getProtocolDetails(consensusProtocolVersion, tag);
    return Buffer.from([result]);
  },
  async prepare(value, {
    tag
  },
  // TODO: { consensusProtocolVersion: ConsensusProtocolVersion } | { onNode: Node } | {}
  options) {
    if (value != null) return value;
    if (options.consensusProtocolVersion != null) return undefined;
    if (Object.keys(ConsensusProtocolVersion).length === 2) return undefined;
    if (options.onNode != null) {
      return this._getProtocolDetails((await options.onNode.getNodeInfo()).consensusProtocolVersion, tag);
    }
    return undefined;
  },
  deserialize(buffer) {
    return buffer[0];
  }
});
;// ./src/tx/builder/field-types/address.ts





/**
 * Map of prefix to ID tag constant
 * @see {@link https://github.com/aeternity/protocol/blob/master/serializations.md#the-id-type}
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_id.erl#L97-L102}
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L163-L168}
 */
const idTagToEncoding = [Encoding.AccountAddress, Encoding.Name, Encoding.Commitment, Encoding.OracleAddress, Encoding.ContractAddress, Encoding.Channel];
function genAddressField(...encodings) {
  return {
    /**
     * Utility function to create and _id type
     * @param hashId - Encoded hash
     * @returns Buffer Buffer with ID tag and decoded HASh
     */
    serialize(hashId) {
      const enc = hashId.slice(0, 2);
      if (!isItemOfArray(enc, idTagToEncoding)) throw new TagNotFoundError(enc);
      if (!isItemOfArray(enc, encodings)) {
        throw new ArgumentError('Address encoding', encodings.join(', '), enc);
      }
      const idTag = idTagToEncoding.indexOf(enc) + 1;
      return Buffer.from([...toBytes(idTag), ...decode(hashId)]);
    },
    /**
     * Utility function to read and _id type
     * @param buf - Data
     * @returns Encoded hash string with prefix
     */
    deserialize(buf) {
      const idTag = Buffer.from(buf).readUIntBE(0, 1);
      const enc = idTagToEncoding[idTag - 1];
      if (enc == null) throw new PrefixNotFoundError(idTag);
      if (!isItemOfArray(enc, encodings)) {
        throw new ArgumentError('Address encoding', encodings.join(', '), enc);
      }
      return encode(buf.subarray(1), enc);
    }
  };
}
;// ./src/tx/builder/field-types/array.ts
function genArrayField(itemHandler) {
  return {
    serialize(items, params) {
      return items.map(item => itemHandler.serialize(item, params));
    },
    deserialize(buffers, params) {
      return buffers.map(buffer => itemHandler.deserialize(buffer, params));
    }
  };
}
;// ./src/tx/builder/field-types/u-int.ts



/* harmony default export */ const u_int = ({
  serialize(value) {
    if (Number(value) < 0) throw new ArgumentError('value', 'greater or equal to 0', value);
    return toBytes(value, true);
  },
  deserialize(value) {
    return readInt(value);
  }
});
;// ./src/tx/builder/field-types/coin-amount.ts


/* harmony default export */ const coin_amount = ({
  ...u_int,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  serializeAettos(value, params, options) {
    return value !== null && value !== void 0 ? value : '0';
  },
  serialize(value, params, {
    denomination = AE_AMOUNT_FORMATS.AETTOS,
    ...options
  }) {
    return u_int.serialize(this.serializeAettos(value != null ? formatAmount(value, {
      denomination
    }) : value, params, options));
  }
});
;// ./src/tx/builder/field-types/encoded.ts


function genEncodedField(encoding, optional) {
  return {
    serialize(encodedData) {
      if (encodedData == null) {
        if (optional === true) return Buffer.from([]);
        throw new ArgumentError('Encoded data', 'provided', encodedData);
      }
      return decode(encodedData);
    },
    deserialize(buffer) {
      return encode(buffer, encoding);
    }
  };
}
;// ./src/tx/builder/field-types/entry.ts

function genEntryField(tag) {
  return {
    serialize(txParams, {
      packEntry
    }) {
      if (ArrayBuffer.isView(txParams)) return Buffer.from(txParams);
      if (typeof txParams === 'string' && txParams.startsWith('tx_')) {
        return decode(txParams);
      }
      return decode(packEntry({
        ...txParams,
        ...(tag != null && {
          tag
        })
      }));
    },
    deserialize(buf, {
      unpackEntry
    }) {
      return unpackEntry(encode(buf, Encoding.Bytearray), tag);
    }
  };
}
;// ./src/tx/builder/field-types/enumeration.ts


function genEnumerationField(enm) {
  const values = Object.values(enm).filter(v => typeof v === 'number');
  return {
    serialize(value) {
      if (typeof value !== 'number') throw new ArgumentError('value', 'to be a number', value);
      if (value > 0xff) throw new ArgumentError('value', 'to be less than 256', value);
      if (!isItemOfArray(value, values)) {
        throw new ArgumentError('value', 'to be a value of Enum', value);
      }
      return Buffer.from([value]);
    },
    deserialize(buffer) {
      if (buffer.length !== 1) {
        throw new ArgumentError('buffer', 'to have single element', buffer.length);
      }
      const value = buffer[0];
      if (!isItemOfArray(value, values)) {
        throw new ArgumentError('value', 'to be a value of Enum', value);
      }
      return value;
    }
  };
}
;// ./src/tx/builder/field-types/gas-price.ts





const gasPriceCache = new WeakMap();
async function getCachedIncreasedGasPrice(node) {
  const cache = gasPriceCache.get(node);
  if (cache != null && cache.time > Date.now() - 20 * 1000) {
    return cache.gasPrice;
  }
  const {
    minGasPrice,
    utilization
  } = (await node.getRecentGasPrices())[0];
  let gasPrice = utilization < 70 ? 0n : BigInt(new (external_bignumber_js_default())(minGasPrice.toString()).times(1.01).integerValue().toFixed());
  const maxSafeGasPrice = BigInt(MIN_GAS_PRICE) * 100000n; // max microblock fee is 600ae or 35usd
  if (gasPrice > maxSafeGasPrice) {
    console.warn(`Estimated gas price ${gasPrice} exceeds the maximum safe value for unknown reason.` + ` It will be limited to ${maxSafeGasPrice}.` + ' To overcome this restriction provide `gasPrice`/`fee` in options.');
    gasPrice = maxSafeGasPrice;
  }
  gasPriceCache.set(node, {
    gasPrice,
    time: Date.now()
  });
  return gasPrice;
}

// TODO: use withFormatting after using a single type for coins representation
/* harmony default export */ const gas_price = ({
  ...coin_amount,
  async prepare(value, params, {
    onNode,
    denomination
  }) {
    if (value != null) return value;
    if (onNode == null) {
      throw new ArgumentError('onNode', 'provided (or provide `gasPrice` instead)', onNode);
    }
    const gasPrice = await getCachedIncreasedGasPrice(onNode);
    if (gasPrice === 0n) return undefined;
    return formatAmount(gasPrice, {
      targetDenomination: denomination
    });
  },
  serializeAettos(value = MIN_GAS_PRICE.toString()) {
    if (+value < MIN_GAS_PRICE) {
      throw new IllegalArgumentError(`Gas price ${value.toString()} must be bigger than ${MIN_GAS_PRICE}`);
    }
    return value;
  }
});
;// ./src/tx/builder/field-types/fee.ts








const BASE_GAS = 15000;
const GAS_PER_BYTE = 20;
const KEY_BLOCK_INTERVAL = 3;

/**
 * Calculate the base gas
 * @see {@link https://github.com/aeternity/protocol/blob/master/consensus/README.md#gas}
 * @param txType - The transaction type
 * @returns The base gas
 * @example
 * ```js
 * TX_BASE_GAS(Tag.ChannelForceProgressTx) => 30 * 15000
 * ```
 */
const TX_BASE_GAS = txType => {
  var _feeFactors;
  const feeFactors = {
    [Tag.ChannelForceProgressTx]: 30,
    [Tag.ChannelOffChainTx]: 0,
    [Tag.ContractCreateTx]: 5,
    [Tag.ContractCallTx]: 12,
    [Tag.GaAttachTx]: 5,
    [Tag.GaMetaTx]: 5,
    [Tag.PayingForTx]: 1 / 5
  };
  const factor = (_feeFactors = feeFactors[txType]) !== null && _feeFactors !== void 0 ? _feeFactors : 1;
  return factor * BASE_GAS;
};

/**
 * Calculate gas for other types of transactions
 * @see {@link https://github.com/aeternity/protocol/blob/master/consensus/README.md#gas}
 * @param txType - The transaction type
 * @param txSize - The transaction size
 * @returns parameters - The transaction parameters
 * @returns parameters.relativeTtl - The relative ttl
 * @returns parameters.innerTxSize - The size of the inner transaction
 * @returns The other gas
 * @example
 * ```js
 * TX_OTHER_GAS(Tag.OracleRespondTx, 10, { relativeTtl: 12, innerTxSize: 0 })
 *  => 10 * 20 + Math.ceil(32000 * 12 / Math.floor(60 * 24 * 365 / 3))
 * ```
 */
const TX_OTHER_GAS = (txType, txSize, {
  relativeTtl,
  innerTxSize
}) => {
  switch (txType) {
    case Tag.OracleRegisterTx:
    case Tag.OracleExtendTx:
    case Tag.OracleQueryTx:
    case Tag.OracleRespondTx:
      return txSize * GAS_PER_BYTE + Math.ceil(32000 * relativeTtl / Math.floor(60 * 24 * 365 / KEY_BLOCK_INTERVAL));
    case Tag.GaMetaTx:
    case Tag.PayingForTx:
      return (txSize - innerTxSize) * GAS_PER_BYTE;
    default:
      return txSize * GAS_PER_BYTE;
  }
};
function getOracleRelativeTtl(params) {
  const ttlKeys = {
    [Tag.OracleRegisterTx]: 'oracleTtlValue',
    [Tag.OracleExtendTx]: 'oracleTtlValue',
    [Tag.OracleQueryTx]: 'queryTtlValue',
    [Tag.OracleRespondTx]: 'responseTtlValue'
  };
  const {
    tag
  } = params;
  if (!isKeyOfObject(tag, ttlKeys)) return 1;
  return params[ttlKeys[tag]];
}

/**
 * Calculate gas based on tx type and params
 */
function buildGas(builtTx, unpackTx, buildTx) {
  const {
    length
  } = decode(builtTx);
  const txObject = unpackTx(builtTx);
  let innerTxSize = 0;
  if (txObject.tag === Tag.GaMetaTx || txObject.tag === Tag.PayingForTx) {
    innerTxSize = decode(buildTx(txObject.tx.encodedTx)).length;
  }
  return TX_BASE_GAS(txObject.tag) + TX_OTHER_GAS(txObject.tag, length, {
    relativeTtl: getOracleRelativeTtl(txObject),
    innerTxSize
  });
}

/**
 * Calculate min fee
 * @category transaction builder
 * @param rebuildTx - Callback to get built transaction with specific fee
 */
function calculateMinFee(rebuildTx, unpackTx, buildTx) {
  let fee = new (external_bignumber_js_default())(0);
  let previousFee;
  do {
    previousFee = fee;
    fee = new (external_bignumber_js_default())(MIN_GAS_PRICE).times(buildGas(rebuildTx(fee), unpackTx, buildTx));
  } while (!fee.eq(previousFee));
  return fee;
}

// TODO: Get rid of this workaround. Transaction builder can't accept/return gas price instead of
// fee because it may get a decimal gas price. So, it should accept the optional `gasPrice` even
// if it is not a contract-related transaction. And use this `gasPrice` to calculate `fee`.
const gasPricePrefix = '_gas-price:';
/* harmony default export */ const fee = ({
  ...coin_amount,
  async prepare(value, params, {
    onNode
  }) {
    if (value != null) return value;
    if (onNode == null) {
      throw new ArgumentError('onNode', 'provided (or provide `fee` instead)', onNode);
    }
    const gasPrice = await getCachedIncreasedGasPrice(onNode);
    if (gasPrice === 0n) return undefined;
    return gasPricePrefix + gasPrice;
  },
  serializeAettos(_value, {
    rebuildTx,
    unpackTx,
    buildTx,
    _computingMinFee
  }, {
    _canIncreaseFee
  }) {
    if (_computingMinFee != null) return _computingMinFee.toFixed();
    const minFee = calculateMinFee(fee => rebuildTx({
      _computingMinFee: fee
    }), unpackTx, buildTx);
    const value = _value?.startsWith(gasPricePrefix) === true ? minFee.dividedBy(MIN_GAS_PRICE).times(_value.replace(gasPricePrefix, '')) : new (external_bignumber_js_default())(_value !== null && _value !== void 0 ? _value : minFee);
    if (minFee.gt(value)) {
      if (_canIncreaseFee === true) return minFee.toFixed();
      throw new IllegalArgumentError(`Fee ${value.toString()} must be bigger than ${minFee}`);
    }
    return value.toFixed();
  },
  serialize(value, params, options) {
    if (typeof value === 'string' && value.startsWith(gasPricePrefix)) {
      return u_int.serialize(this.serializeAettos(value, params, options));
    }
    return coin_amount.serialize.call(this, value, params, options);
  }
});
;// ./src/tx/builder/field-types/short-u-int.ts

/* harmony default export */ const short_u_int = ({
  serialize(value) {
    return u_int.serialize(value);
  },
  deserialize(value) {
    return +u_int.deserialize(value);
  }
});
;// ./src/tx/builder/field-types/gas-limit.ts




function calculateGasLimitMax(gasMax, rebuildTx, unpackTx, buildTx) {
  return gasMax - +buildGas(rebuildTx(gasMax), unpackTx, buildTx);
}
/* harmony default export */ const gas_limit = ({
  ...short_u_int,
  serialize(_value, {
    tag,
    rebuildTx,
    unpackTx,
    buildTx,
    _computingGasLimit
  }, {
    gasMax = 6e6
  }) {
    if (_computingGasLimit != null) return short_u_int.serialize(_computingGasLimit);
    const gasLimitMax = tag === Tag.GaMetaTx ? MAX_AUTH_FUN_GAS : calculateGasLimitMax(gasMax, gasLimit => rebuildTx({
      _computingGasLimit: gasLimit,
      _canIncreaseFee: true
    }), unpackTx, buildTx);
    const value = _value !== null && _value !== void 0 ? _value : gasLimitMax;
    if (value > gasLimitMax) {
      throw new IllegalArgumentError(`Gas limit ${value} must be less or equal to ${gasLimitMax}`);
    }
    return short_u_int.serialize(value);
  }
});
;// ./src/tx/builder/field-types/field.ts
/* harmony default export */ const field = ({
  serialize(value) {
    return Buffer.from(value);
  },
  deserialize(value) {
    return value.toString();
  }
});
;// ./src/tx/builder/field-types/name.ts

/* harmony default export */ const field_types_name = ({
  /**
   * @param value - AENS name
   */
  serialize(value) {
    return field.serialize(value);
  },
  /**
   * @param value - AENS name
   */
  deserialize(value) {
    return field.deserialize(value);
  }
});
;// ./src/tx/builder/field-types/name-fee.ts




/* harmony default export */ const name_fee = ({
  ...coin_amount,
  serializeAettos(_value, txFields) {
    const minNameFee = getMinimumNameFee(txFields.name);
    const value = new (external_bignumber_js_default())(_value !== null && _value !== void 0 ? _value : minNameFee);
    if (minNameFee.gt(value)) throw new InsufficientNameFeeError(value, minNameFee);
    return value.toFixed();
  },
  /**
   * @param value - AENS name fee
   * @param txFields - Transaction fields
   * @param txFields.name - AENS Name in transaction
   */
  serialize(value, txFields, parameters) {
    return coin_amount.serialize.call(this, value, txFields, parameters);
  }
});
;// ./src/tx/builder/field-types/name-id.ts



const addressName = genAddressField(Encoding.Name);
/* harmony default export */ const name_id = ({
  ...addressName,
  /**
   * @param value - AENS name ID
   */
  serialize(value) {
    return addressName.serialize(isName(value) ? produceNameId(value) : value);
  }
});
;// ./src/tx/builder/field-types/nonce.ts




function genNonceField(senderKey) {
  return {
    ...short_u_int,
    serialize(value, {
      tag
    }) {
      if (Tag.GaAttachTx === tag && value !== 1) {
        throw new ArgumentError('nonce', 'equal 1 if GaAttachTx', value);
      }
      return short_u_int.serialize(value);
    },
    async prepare(value, params, options) {
      if (value != null) return value;
      // TODO: uncomment the below line
      // if (options._isInternalBuild === true) return 0;
      const {
        onNode,
        strategy
      } = options;
      const senderId = options[senderKey];
      const requirement = 'provided (or provide `nonce` instead)';
      if (onNode == null) throw new ArgumentError('onNode', requirement, onNode);
      if (senderId == null) throw new ArgumentError('senderId', requirement, senderId);
      return (await onNode.getAccountNextNonce(senderId.replace(/^ok_/, 'ak_'), {
        strategy
      }).catch(error => {
        if (!isAccountNotFoundError(error)) throw error;
        return {
          nextNonce: 1
        };
      })).nextNonce;
    },
    senderKey
  };
}
;// ./src/tx/builder/field-types/pointers.ts





const ID_TAG = Buffer.from([1]);
const DATA_TAG = Buffer.from([2]);
const DATA_LENGTH_MAX = 1024;
const addressAny = genAddressField(...idTagToEncoding);

// TODO: remove after fixing node types

/* harmony default export */ const pointers = (allowRaw => ({
  /**
   * Helper function to build pointers for name update TX
   * @param pointers - Array of pointers
   * `([ { key: 'account_pubkey', id: 'ak_32klj5j23k23j5423l434l2j3423'} ])`
   * @returns Serialized pointers array
   */
  serialize(pointers) {
    if (pointers.length > 32) {
      throw new IllegalArgumentError(`Expected 32 pointers or less, got ${pointers.length} instead`);
    }
    return pointers.map(({
      key,
      id
    }) => {
      let payload;
      if (isEncoded(id, ...idTagToEncoding)) {
        payload = [...(allowRaw ? [ID_TAG] : []), addressAny.serialize(id)];
      }
      if (isEncoded(id, Encoding.Bytearray)) {
        const data = decode(id);
        if (data.length > DATA_LENGTH_MAX) {
          throw new ArgumentError('Raw pointer', `shorter than ${DATA_LENGTH_MAX + 1} bytes`, `${data.length} bytes`);
        }
        payload = [DATA_TAG, data];
      }
      if (payload == null) throw new DecodeError(`Unknown AENS pointer value: ${id}`);
      return [toBytes(key), Buffer.concat(payload)];
    });
  },
  /**
   * Helper function to read pointers from name update TX
   * @param pointers - Array of pointers
   * @returns Deserialize pointer array
   */
  deserialize(pointers) {
    return pointers.map(([bKey, bId]) => {
      if (!allowRaw) return {
        key: bKey.toString(),
        id: addressAny.deserialize(bId)
      };
      const tag = bId.subarray(0, 1);
      const payload = bId.subarray(1);
      let id;
      if (tag.equals(ID_TAG)) id = addressAny.deserialize(payload);
      // TS can't figure out the real type depending on allowRaw
      if (tag.equals(DATA_TAG)) id = encode(payload, Encoding.Bytearray);
      if (id == null) throw new DecodeError(`Unknown AENS pointer tag: ${tag}`);
      return {
        key: bKey.toString(),
        id
      };
    });
  }
}));
;// ./src/tx/builder/field-types/query-fee.ts



/**
 * Oracle query fee
 */
/* harmony default export */ const query_fee = ({
  ...coin_amount,
  async prepare(value, params, options) {
    if (value != null) return value;
    const {
      onNode,
      oracleId
    } = options;
    const requirement = 'provided (or provide `queryFee` instead)';
    if (onNode == null) throw new ArgumentError('onNode', requirement, onNode);
    if (oracleId == null) throw new ArgumentError('oracleId', requirement, oracleId);
    return (await onNode.getOracleByPubkey(oracleId)).queryFee.toString();
  }
});
;// ./src/tx/builder/field-types/raw.ts
/* harmony default export */ const raw = ({
  serialize(buffer) {
    return Buffer.from(buffer);
  },
  deserialize(buffer) {
    return buffer;
  }
});
;// ./src/tx/builder/field-types/short-u-int-const.ts


function genShortUIntConstField(constValue, optional) {
  return {
    serialize(value) {
      if ((optional !== true || value != null) && value !== constValue) {
        throw new ArgumentError('ShortUIntConst', constValue, value);
      }
      return short_u_int.serialize(constValue);
    },
    deserialize(buf) {
      const value = short_u_int.deserialize(buf);
      if (value !== constValue) throw new ArgumentError('ShortUIntConst', constValue, value);
      return constValue;
    },
    constValue,
    constValueOptional: optional === true
  };
}
;// ./src/tx/builder/field-types/string.ts

/* harmony default export */ const string = ({
  serialize(string) {
    return toBytes(string);
  },
  deserialize(buffer) {
    return buffer.toString();
  }
});
;// ./src/tx/builder/field-types/transaction.ts

function genTransactionField(tag) {
  return {
    serialize(txParams, {
      buildTx
    }) {
      if (ArrayBuffer.isView(txParams)) return Buffer.from(txParams);
      if (typeof txParams === 'string' && txParams.startsWith('tx_')) {
        return decode(txParams);
      }
      return decode(buildTx({
        ...txParams,
        ...(tag != null && {
          tag
        })
      }));
    },
    deserialize(buf, {
      unpackTx
    }) {
      return unpackTx(encode(buf, Encoding.Transaction), tag);
    }
  };
}
;// ./src/tx/builder/field-types/ttl.ts




/**
 * Time to leave
 */
/* harmony default export */ const ttl = ({
  ...short_u_int,
  serialize(value) {
    return short_u_int.serialize(value !== null && value !== void 0 ? value : 0);
  },
  async prepare(value, params,
  // TODO: { absoluteTtl: true } | { absoluteTtl: false, onNode: Node }
  {
    onNode,
    absoluteTtl,
    _isInternalBuild,
    ...options
  }) {
    if (absoluteTtl !== true && value !== 0 && (value != null || _isInternalBuild === true)) {
      if (onNode == null) throw new ArgumentError('onNode', 'provided', onNode);
      value = (value !== null && value !== void 0 ? value : 3) + (await getHeight({
        ...options,
        onNode,
        cached: true
      }));
    }
    return value;
  }
});
;// ./src/tx/builder/field-types/with-default.ts
function withDefault(defaultValue, field) {
  return {
    ...field,
    serialize(value, params) {
      return field.serialize(value !== null && value !== void 0 ? value : defaultValue, params);
    }
  };
}
;// ./src/tx/builder/field-types/with-formatting.ts
function withFormatting(format, field) {
  return {
    ...field,
    serialize(value, params, options) {
      return field.serialize(format(value), params, options);
    }
  };
}
;// ./src/tx/builder/entry/constants.ts
/**
 * @category contract
 */
let CallReturnType = /*#__PURE__*/function (CallReturnType) {
  CallReturnType[CallReturnType["Ok"] = 0] = "Ok";
  CallReturnType[CallReturnType["Error"] = 1] = "Error";
  CallReturnType[CallReturnType["Revert"] = 2] = "Revert";
  return CallReturnType;
}({});

/**
 * @category entry builder
 */
let EntryTag = /*#__PURE__*/function (EntryTag) {
  EntryTag[EntryTag["Account"] = 10] = "Account";
  EntryTag[EntryTag["Oracle"] = 20] = "Oracle";
  // OracleQuery = 21,
  EntryTag[EntryTag["Name"] = 30] = "Name";
  // NameCommitment = 31,
  // NameAuction = 37,
  EntryTag[EntryTag["Contract"] = 40] = "Contract";
  EntryTag[EntryTag["ContractCall"] = 41] = "ContractCall";
  EntryTag[EntryTag["ChannelOffChainUpdateTransfer"] = 570] = "ChannelOffChainUpdateTransfer";
  EntryTag[EntryTag["ChannelOffChainUpdateDeposit"] = 571] = "ChannelOffChainUpdateDeposit";
  EntryTag[EntryTag["ChannelOffChainUpdateWithdraw"] = 572] = "ChannelOffChainUpdateWithdraw";
  EntryTag[EntryTag["ChannelOffChainUpdateCreateContract"] = 573] = "ChannelOffChainUpdateCreateContract";
  EntryTag[EntryTag["ChannelOffChainUpdateCallContract"] = 574] = "ChannelOffChainUpdateCallContract";
  // ChannelOffChainUpdateMeta = 576,
  EntryTag[EntryTag["Channel"] = 58] = "Channel";
  EntryTag[EntryTag["TreesPoi"] = 60] = "TreesPoi";
  // TreesDb = 61,
  EntryTag[EntryTag["StateTrees"] = 62] = "StateTrees";
  EntryTag[EntryTag["Mtree"] = 63] = "Mtree";
  EntryTag[EntryTag["MtreeValue"] = 64] = "MtreeValue";
  EntryTag[EntryTag["ContractsMtree"] = 621] = "ContractsMtree";
  EntryTag[EntryTag["CallsMtree"] = 622] = "CallsMtree";
  EntryTag[EntryTag["ChannelsMtree"] = 623] = "ChannelsMtree";
  EntryTag[EntryTag["NameserviceMtree"] = 624] = "NameserviceMtree";
  EntryTag[EntryTag["OraclesMtree"] = 625] = "OraclesMtree";
  EntryTag[EntryTag["AccountsMtree"] = 626] = "AccountsMtree";
  // CompilerSophia = 70,
  EntryTag[EntryTag["GaMetaTxAuthData"] = 810] = "GaMetaTxAuthData";
  return EntryTag;
}({});
;// ./src/tx/builder/schema.ts
/**
 * Transaction Schema for TxBuilder
 */
// # RLP version number
// # https://github.com/aeternity/protocol/blob/master/serializations.md#binary-serialization































/**
 * @category oracle
 */
let ORACLE_TTL_TYPES = /*#__PURE__*/function (ORACLE_TTL_TYPES) {
  ORACLE_TTL_TYPES[ORACLE_TTL_TYPES["delta"] = 0] = "delta";
  ORACLE_TTL_TYPES[ORACLE_TTL_TYPES["block"] = 1] = "block";
  return ORACLE_TTL_TYPES;
}({});

// TODO: figure out how to omit overriding types of recursive fields

const transactionAny = genTransactionField();
const transactionSignedTx = genTransactionField(Tag.SignedTx);
const entryTreesPoi = genEntryField(EntryTag.TreesPoi);
const clientTtl = withDefault(60 * 60, short_u_int);
// https://github.com/aeternity/protocol/blob/fd17982/AENS.md#update
/**
 * Name ttl represented in number of blocks (Max value is 50000 blocks)
 */
const nameTtl = withFormatting(value => {
  const NAME_TTL = 180000;
  value !== null && value !== void 0 ? value : value = NAME_TTL;
  if (value >= 1 && value <= NAME_TTL) return value;
  throw new ArgumentError('nameTtl', `a number between 1 and ${NAME_TTL} blocks`, value);
}, short_u_int);

/**
 * @see {@link https://github.com/aeternity/protocol/blob/c007deeac4a01e401238412801ac7084ac72d60e/serializations.md#accounts-version-1-basic-accounts}
 */
const txSchema = [{
  tag: genShortUIntConstField(Tag.SignedTx),
  version: genShortUIntConstField(1, true),
  signatures: genArrayField(raw),
  // TODO: use sg_ (Encoding.Signature) instead
  encodedTx: transactionAny
}, {
  tag: genShortUIntConstField(Tag.SpendTx),
  version: genShortUIntConstField(1, true),
  senderId: genAddressField(Encoding.AccountAddress),
  // TODO: accept also an AENS name
  recipientId: genAddressField(Encoding.AccountAddress, Encoding.ContractAddress, Encoding.Name),
  amount: coin_amount,
  fee: fee,
  ttl: ttl,
  nonce: genNonceField('senderId'),
  payload: genEncodedField(Encoding.Bytearray, true)
}, {
  tag: genShortUIntConstField(Tag.NamePreclaimTx),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('accountId'),
  commitmentId: genAddressField(Encoding.Commitment),
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.NameClaimTx),
  version: genShortUIntConstField(2, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('accountId'),
  name: field_types_name,
  nameSalt: withDefault(0, u_int),
  nameFee: name_fee,
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.NameUpdateTx),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('accountId'),
  nameId: name_id,
  nameTtl,
  pointers: pointers(false),
  clientTtl,
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.NameUpdateTx),
  version: genShortUIntConstField(2),
  accountId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('accountId'),
  nameId: name_id,
  nameTtl,
  pointers: pointers(true),
  clientTtl,
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.NameTransferTx),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('accountId'),
  nameId: name_id,
  // TODO: accept also an AENS name
  recipientId: genAddressField(Encoding.AccountAddress, Encoding.Name),
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.NameRevokeTx),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('accountId'),
  nameId: name_id,
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.ContractCreateTx),
  version: genShortUIntConstField(1, true),
  ownerId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('ownerId'),
  code: genEncodedField(Encoding.ContractBytearray),
  ctVersion: ct_version,
  fee: fee,
  ttl: ttl,
  deposit: withFormatting((value = 0) => {
    if (+value === 0) return value;
    throw new ArgumentError('deposit', 'equal 0 (because is not refundable)', value);
  }, coin_amount),
  amount: coin_amount,
  gasLimit: gas_limit,
  gasPrice: gas_price,
  callData: genEncodedField(Encoding.ContractBytearray)
}, {
  tag: genShortUIntConstField(Tag.ContractCallTx),
  version: genShortUIntConstField(1, true),
  callerId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('callerId'),
  // TODO: accept also an AENS name
  contractId: genAddressField(Encoding.ContractAddress, Encoding.Name),
  abiVersion: abi_version,
  fee: fee,
  ttl: ttl,
  amount: coin_amount,
  gasLimit: gas_limit,
  gasPrice: gas_price,
  callData: genEncodedField(Encoding.ContractBytearray)
}, {
  tag: genShortUIntConstField(Tag.OracleRegisterTx),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('accountId'),
  queryFormat: string,
  responseFormat: string,
  queryFee: coin_amount,
  oracleTtlType: withDefault(ORACLE_TTL_TYPES.delta, genEnumerationField(ORACLE_TTL_TYPES)),
  oracleTtlValue: withDefault(500, short_u_int),
  fee: fee,
  ttl: ttl,
  abiVersion: abi_version
}, {
  tag: genShortUIntConstField(Tag.OracleExtendTx),
  version: genShortUIntConstField(1, true),
  // TODO: accept also an AENS name
  oracleId: genAddressField(Encoding.OracleAddress, Encoding.Name),
  nonce: genNonceField('oracleId'),
  oracleTtlType: withDefault(ORACLE_TTL_TYPES.delta, genEnumerationField(ORACLE_TTL_TYPES)),
  oracleTtlValue: withDefault(500, short_u_int),
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.OracleQueryTx),
  version: genShortUIntConstField(1, true),
  senderId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('senderId'),
  // TODO: accept also an AENS name
  oracleId: genAddressField(Encoding.OracleAddress, Encoding.Name),
  query: string,
  queryFee: query_fee,
  queryTtlType: withDefault(ORACLE_TTL_TYPES.delta, genEnumerationField(ORACLE_TTL_TYPES)),
  queryTtlValue: withDefault(10, short_u_int),
  responseTtlType: withDefault(ORACLE_TTL_TYPES.delta, genEnumerationField(ORACLE_TTL_TYPES)),
  responseTtlValue: withDefault(10, short_u_int),
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.OracleRespondTx),
  version: genShortUIntConstField(1, true),
  oracleId: genAddressField(Encoding.OracleAddress),
  nonce: genNonceField('oracleId'),
  queryId: genEncodedField(Encoding.OracleQueryId),
  response: string,
  responseTtlType: withDefault(ORACLE_TTL_TYPES.delta, genEnumerationField(ORACLE_TTL_TYPES)),
  responseTtlValue: withDefault(10, short_u_int),
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.ChannelCreateTx),
  version: genShortUIntConstField(2, true),
  initiator: genAddressField(Encoding.AccountAddress),
  initiatorAmount: u_int,
  responder: genAddressField(Encoding.AccountAddress),
  responderAmount: u_int,
  channelReserve: u_int,
  lockPeriod: u_int,
  ttl: ttl,
  fee: fee,
  initiatorDelegateIds: genArrayField(genAddressField(...idTagToEncoding)),
  responderDelegateIds: genArrayField(genAddressField(...idTagToEncoding)),
  stateHash: genEncodedField(Encoding.State),
  nonce: genNonceField('initiator')
}, {
  tag: genShortUIntConstField(Tag.ChannelCloseMutualTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  initiatorAmountFinal: u_int,
  responderAmountFinal: u_int,
  ttl: ttl,
  fee: fee,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelCloseSoloTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  payload: genEncodedField(Encoding.Transaction),
  poi: entryTreesPoi,
  ttl: ttl,
  fee: fee,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelSlashTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  payload: genEncodedField(Encoding.Transaction),
  poi: entryTreesPoi,
  ttl: ttl,
  fee: fee,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelDepositTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  amount: u_int,
  ttl: ttl,
  fee: fee,
  stateHash: genEncodedField(Encoding.State),
  round: short_u_int,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelWithdrawTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  toId: genAddressField(Encoding.AccountAddress),
  amount: u_int,
  ttl: ttl,
  fee: fee,
  stateHash: genEncodedField(Encoding.State),
  round: short_u_int,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelSettleTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  initiatorAmountFinal: u_int,
  responderAmountFinal: u_int,
  ttl: ttl,
  fee: fee,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelForceProgressTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  payload: genEncodedField(Encoding.Transaction),
  round: short_u_int,
  update: genEncodedField(Encoding.ContractBytearray),
  stateHash: genEncodedField(Encoding.State),
  offChainTrees: genEncodedField(Encoding.StateTrees),
  ttl: ttl,
  fee: fee,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelOffChainTx),
  version: genShortUIntConstField(2, true),
  channelId: genAddressField(Encoding.Channel),
  round: short_u_int,
  stateHash: genEncodedField(Encoding.State)
}, {
  tag: genShortUIntConstField(Tag.ChannelSnapshotSoloTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  payload: genEncodedField(Encoding.Transaction),
  ttl: ttl,
  fee: fee,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.GaAttachTx),
  version: genShortUIntConstField(1, true),
  ownerId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('ownerId'),
  code: genEncodedField(Encoding.ContractBytearray),
  authFun: raw,
  ctVersion: ct_version,
  fee: fee,
  ttl: ttl,
  gasLimit: gas_limit,
  gasPrice: gas_price,
  callData: genEncodedField(Encoding.ContractBytearray)
}, {
  tag: genShortUIntConstField(Tag.GaMetaTx),
  version: genShortUIntConstField(2, true),
  gaId: genAddressField(Encoding.AccountAddress),
  authData: genEncodedField(Encoding.ContractBytearray),
  abiVersion: abi_version,
  fee: fee,
  gasLimit: gas_limit,
  gasPrice: gas_price,
  tx: transactionSignedTx
}, {
  tag: genShortUIntConstField(Tag.PayingForTx),
  version: genShortUIntConstField(1, true),
  payerId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('payerId'),
  fee: fee,
  tx: transactionSignedTx
}];
// EXTERNAL MODULE: external "rlp"
var external_rlp_ = __webpack_require__(6514);
;// ./src/tx/builder/common.ts



function getSchema(schemas, Tag, tag, version) {
  const subSchemas = schemas.filter(s => s.tag.constValue === tag);
  if (subSchemas.length === 0) throw new SchemaNotFoundError(`${Tag[tag]} (${tag})`, 0);
  if (version == null) {
    const defaultSchema = subSchemas.find(schema => schema.version.constValueOptional);
    if (defaultSchema == null) throw new InternalError(`Can't find default schema of ${Tag[tag]} (${tag})`);
    version = defaultSchema.version.constValue;
  }
  const schema = subSchemas.find(s => s.version.constValue === version);
  if (schema == null) throw new SchemaNotFoundError(`${Tag[tag]} (${tag})`, version);
  return Object.entries(schema);
}
function packRecord(schemas, Tag, params, extraParams, encoding) {
  const schema = getSchema(schemas, Tag, params.tag, params.version);
  const binary = schema.map(([key, field]) => field.serialize(params[key], {
    ...params,
    ...extraParams
  }, params));
  return encode((0,external_rlp_.encode)(binary), encoding);
}
function unpackRecord(schemas, Tag, encodedRecord, expectedTag, extraParams) {
  const binary = (0,external_rlp_.decode)(decode(encodedRecord));
  if (!ArrayBuffer.isView(binary[0]) || !ArrayBuffer.isView(binary[1])) {
    throw new DecodeError("Can't parse tag or version in provided RLP");
  }
  const tag = Buffer.from(binary[0]).readUintBE(0, binary[0].length);
  const version = Buffer.from(binary[1]).readUintBE(0, binary[1].length);
  const schema = getSchema(schemas, Tag, tag, version);
  if (expectedTag != null && expectedTag !== tag) {
    throw new DecodeError(`Expected ${Tag[expectedTag]} tag, got ${Tag[tag]} instead`);
  }
  if (binary.length !== schema.length) {
    throw new ArgumentError('RLP length', schema.length, binary.length);
  }
  return Object.fromEntries(schema.map(([name, field], index) => [name, field.deserialize(binary[index], extraParams)]));
}
;// ./src/tx/builder/field-types/boolean.ts
/* harmony default export */ const field_types_boolean = ({
  serialize(value) {
    return Buffer.from([value ? 1 : 0]);
  },
  deserialize(buffer) {
    return buffer[0] === 1;
  }
});
;// ./src/tx/builder/field-types/map.ts


function genMapField(encoding, tag) {
  return {
    serialize(object, {
      packEntry
    }) {
      return decode(packEntry({
        tag: EntryTag.Mtree,
        values: Object.entries(object).map(([key, value]) => ({
          tag: EntryTag.MtreeValue,
          key: decode(key),
          value: decode(packEntry({
            ...value,
            tag
          }))
        }))
      }));
    },
    deserialize(buffer, {
      unpackEntry
    }) {
      const {
        values
      } = unpackEntry(encode(buffer, Encoding.Bytearray), EntryTag.Mtree);
      return Object.fromEntries(values
      // TODO: remove after resolving https://github.com/aeternity/aeternity/issues/4066
      .filter(({
        key
      }) => encoding !== Encoding.ContractAddress || key.length === 32).map(({
        key,
        value
      }) => [encode(key, encoding), unpackEntry(encode(value, Encoding.Bytearray), tag)]));
    },
    recursiveType: true
  };
}
;// ./src/tx/builder/field-types/mptree.ts
var _MPTree;
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }




var NodeType = /*#__PURE__*/function (NodeType) {
  NodeType[NodeType["Branch"] = 0] = "Branch";
  NodeType[NodeType["Extension"] = 1] = "Extension";
  NodeType[NodeType["Leaf"] = 2] = "Leaf";
  return NodeType;
}(NodeType || {});
var _rootHash = /*#__PURE__*/new WeakMap();
var _isComplete = /*#__PURE__*/new WeakMap();
var _nodes = /*#__PURE__*/new WeakMap();
var _encoding = /*#__PURE__*/new WeakMap();
var _tag = /*#__PURE__*/new WeakMap();
var _unpackEntry = /*#__PURE__*/new WeakMap();
var _MPTree_brand = /*#__PURE__*/new WeakSet();
class MPTree {
  get isComplete() {
    return _classPrivateFieldGet(_isComplete, this);
  }
  /**
   * Deserialize Merkle Patricia Tree
   * @param binary - Binary
   * @param tag - Tag to use to decode value
   * @param unpEnt - Implementation of unpackEntry use to decode values
   * @returns Merkle Patricia Tree
   */
  constructor(binary, encoding, tag, unpEnt) {
    /**
     * Retrieve value from Merkle Patricia Tree
     * @param _key - The key of the element to retrieve
     * @returns Value associated to the specified key
     */
    _classPrivateMethodInitSpec(this, _MPTree_brand);
    _classPrivateFieldInitSpec(this, _rootHash, void 0);
    _classPrivateFieldInitSpec(this, _isComplete, true);
    _classPrivateFieldInitSpec(this, _nodes, void 0);
    _classPrivateFieldInitSpec(this, _encoding, void 0);
    _classPrivateFieldInitSpec(this, _tag, void 0);
    _classPrivateFieldInitSpec(this, _unpackEntry, void 0);
    _classPrivateFieldSet(_encoding, this, encoding);
    _classPrivateFieldSet(_tag, this, tag);
    _classPrivateFieldSet(_unpackEntry, this, unpEnt);
    _classPrivateFieldSet(_rootHash, this, binary[0].toString('hex'));
    _classPrivateFieldSet(_nodes, this, Object.fromEntries(binary[1].map(node => [node[0].toString('hex'), node[1]])));
    if (_classPrivateFieldGet(_nodes, this)[_classPrivateFieldGet(_rootHash, this)] == null) {
      if (Object.keys(_classPrivateFieldGet(_nodes, this)).length !== 0) {
        throw new MissingNodeInTreeError("Can't find a node by root hash");
      }
      _classPrivateFieldSet(_isComplete, this, false);
      return;
    }
    Object.entries(_classPrivateFieldGet(_nodes, this)).forEach(([key, node]) => {
      if (_nodeHash.call(MPTree, node) !== key) throw new MerkleTreeHashMismatchError();
      const {
        type
      } = _parseNode.call(MPTree, node);
      switch (type) {
        case NodeType.Branch:
          node.slice(0, 16).filter(n => n.length).forEach(n => {
            // TODO: enable after resolving https://github.com/aeternity/aeternity/issues/4066
            // if (n.length !== 32) {
            //   throw new ArgumentError('MPTree branch item length', 32, n.length);
            // }
            if (_classPrivateFieldGet(_nodes, this)[n.toString('hex')] == null) _classPrivateFieldSet(_isComplete, this, false);
          });
          break;
        case NodeType.Extension:
          if (_classPrivateFieldGet(_nodes, this)[node[1].toString('hex')] == null) {
            throw new MissingNodeInTreeError("Can't find a node by hash in extension node");
          }
          break;
        case NodeType.Leaf:
          break;
        default:
          throw new InternalError(`Unknown MPTree node type: ${type}`);
      }
    });
  }
  isEqual(tree) {
    return _classPrivateFieldGet(_rootHash, this) === _classPrivateFieldGet(_rootHash, tree);
  }
  /**
   * Serialize Merkle Patricia Tree
   * @returns Binary
   */
  serialize() {
    return [Buffer.from(_classPrivateFieldGet(_rootHash, this), 'hex'), Object.entries(_classPrivateFieldGet(_nodes, this)).map(([mptHash, value]) => [Buffer.from(mptHash, 'hex'), value])];
  }
  /**
   * Retrieve value from Merkle Patricia Tree
   * @param key - The key of the element to retrieve
   * @returns Value associated to the specified key
   */
  get(key) {
    const d = _assertClassBrand(_MPTree_brand, this, _getRaw).call(this, decode(key).toString('hex'));
    if (d == null) return d;
    return _classPrivateFieldGet(_unpackEntry, this).call(this, encode(d, Encoding.Bytearray), _classPrivateFieldGet(_tag, this));
  }
  toObject() {
    return Object.fromEntries(_assertClassBrand(_MPTree_brand, this, _entriesRaw).call(this) // TODO: remove after resolving https://github.com/aeternity/aeternity/issues/4066
    .filter(([k]) => _classPrivateFieldGet(_encoding, this) !== Encoding.ContractAddress || k.length !== 66).map(([k, v]) => [encode(Buffer.from(k, 'hex'), _classPrivateFieldGet(_encoding, this)), _classPrivateFieldGet(_unpackEntry, this).call(this, encode(v, Encoding.Bytearray), _classPrivateFieldGet(_tag, this))]));
  }
}
_MPTree = MPTree;
function _nodeHash(node) {
  return Buffer.from(hash((0,external_rlp_.encode)(node))).toString('hex');
}
function _parseNode(node) {
  switch (node.length) {
    case 17:
      return {
        type: NodeType.Branch,
        ...(node[16].length !== 0 && {
          value: node[16]
        })
      };
    case 2:
      {
        const nibble = node[0][0] >> 4; // eslint-disable-line no-bitwise
        if (nibble > 3) throw new UnknownPathNibbleError(nibble);
        const type = nibble <= 1 ? NodeType.Extension : NodeType.Leaf;
        const slice = [0, 2].includes(nibble) ? 2 : 1;
        return {
          type,
          ...(type === NodeType.Leaf && {
            value: node[1]
          }),
          path: node[0].toString('hex').slice(slice)
        };
      }
    default:
      throw new UnknownNodeLengthError(node.length);
  }
}
function _getRaw(_key) {
  let searchFrom = _classPrivateFieldGet(_rootHash, this);
  let key = _key;
  while (true) {
    // eslint-disable-line no-constant-condition
    const node = _classPrivateFieldGet(_nodes, this)[searchFrom];
    if (node == null) {
      if (!this.isComplete) return undefined;
      throw new InternalError("Can't find node in complete tree");
    }
    const {
      type,
      value,
      path
    } = _parseNode.call(_MPTree, node);
    switch (type) {
      case NodeType.Branch:
        if (key.length === 0) return value;
        searchFrom = node[+`0x${key[0]}`].toString('hex');
        key = key.substring(1);
        break;
      case NodeType.Extension:
        if (key.substring(0, path?.length) !== path) return undefined;
        searchFrom = node[1].toString('hex');
        key = key.substring(path.length);
        break;
      case NodeType.Leaf:
        if (path !== key) return undefined;
        return value;
      default:
        throw new InternalError(`Unknown MPTree node type: ${type}`);
    }
  }
}
function _entriesRaw() {
  const entries = [];
  const rec = (searchFrom, key) => {
    const node = _classPrivateFieldGet(_nodes, this)[searchFrom];
    if (node == null) {
      if (!this.isComplete) return;
      throw new InternalError("Can't find node in complete tree");
    }
    const {
      type,
      value,
      path
    } = _parseNode.call(_MPTree, node);
    switch (type) {
      case NodeType.Branch:
        node.slice(0, 16).map((t, idx) => [t, idx]).filter(([t]) => t.length).forEach(([t, idx]) => rec(t.toString('hex'), key + idx.toString(16)));
        if (value != null) entries.push([key, value]);
        break;
      case NodeType.Extension:
        rec(node[1].toString('hex'), key + path);
        break;
      case NodeType.Leaf:
        if (value == null) throw new UnexpectedTsError();
        entries.push([key + path, value]);
        break;
      default:
        throw new InternalError(`Unknown MPTree node type: ${type}`);
    }
  };
  rec(_classPrivateFieldGet(_rootHash, this), '');
  return entries;
}
function genMPTreeField(encoding, tag) {
  return {
    serialize(value) {
      return value.serialize();
    },
    deserialize(value, {
      unpackEntry
    }) {
      return new MPTree(value, encoding, tag, unpackEntry);
    }
  };
}
;// ./src/tx/builder/field-types/wrapped.ts

function genWrappedField(tag) {
  return {
    serialize(payload, {
      packEntry
    }) {
      return decode(packEntry({
        tag,
        payload
      }));
    },
    deserialize(buffer, {
      unpackEntry
    }) {
      return unpackEntry(encode(buffer, Encoding.Bytearray), tag).payload;
    },
    recursiveType: true
  };
}
;// ./src/tx/builder/entry/schema.ts






















const entryMtreeValueArray = genArrayField(genEntryField(EntryTag.MtreeValue));
const mapContracts = genMapField(Encoding.ContractAddress, EntryTag.Contract);
const mapAccounts = genMapField(Encoding.AccountAddress, EntryTag.Account);
const mapCalls = genMapField(Encoding.Bytearray, EntryTag.ContractCall);
const mapChannels = genMapField(Encoding.Channel, EntryTag.Channel);
const mapNames = genMapField(Encoding.Name, EntryTag.Name);
const mapOracles = genMapField(Encoding.OracleAddress, EntryTag.Oracle);

/**
 * @see {@link https://github.com/aeternity/protocol/blob/8a9d1d1206174627f6aaef86159dc9c643080653/contracts/fate.md#from-ceres-serialized-signature-data}
 */
const schemas = [{
  tag: genShortUIntConstField(EntryTag.Account),
  version: genShortUIntConstField(1),
  nonce: short_u_int,
  balance: u_int
}, {
  tag: genShortUIntConstField(EntryTag.Account),
  version: genShortUIntConstField(2, true),
  flags: u_int,
  nonce: short_u_int,
  balance: u_int,
  gaContract: genAddressField(Encoding.ContractAddress, Encoding.Name),
  gaAuthFun: genEncodedField(Encoding.ContractBytearray)
}, {
  tag: genShortUIntConstField(EntryTag.Name),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nameTtl: short_u_int,
  status: raw,
  /**
   * a suggestion as to how long any clients should cache this information
   */
  clientTtl: short_u_int,
  pointers: pointers
}, {
  tag: genShortUIntConstField(EntryTag.Contract),
  version: genShortUIntConstField(1, true),
  owner: genAddressField(Encoding.AccountAddress),
  ctVersion: ct_version,
  code: genEncodedField(Encoding.ContractBytearray),
  log: genEncodedField(Encoding.ContractBytearray),
  active: field_types_boolean,
  referers: genArrayField(genAddressField(Encoding.AccountAddress)),
  deposit: coin_amount
}, {
  tag: genShortUIntConstField(EntryTag.ContractCall),
  version: genShortUIntConstField(2, true),
  callerId: genAddressField(Encoding.AccountAddress),
  callerNonce: short_u_int,
  height: short_u_int,
  contractId: genAddressField(Encoding.ContractAddress),
  // TODO: rename after resolving https://github.com/aeternity/protocol/issues/506
  gasPrice: u_int,
  gasUsed: short_u_int,
  returnValue: genEncodedField(Encoding.ContractBytearray),
  returnType: genEnumerationField(CallReturnType),
  // TODO: add serialization for
  //  <log> :: [ { <address> :: id, [ <topics> :: binary() }, <data> :: binary() } ]
  log: genArrayField(raw)
}, {
  tag: genShortUIntConstField(EntryTag.Oracle),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  queryFormat: string,
  responseFormat: string,
  queryFee: coin_amount,
  oracleTtlValue: short_u_int,
  abiVersion: abi_version
}, {
  tag: genShortUIntConstField(EntryTag.Channel),
  version: genShortUIntConstField(3, true),
  initiator: genAddressField(Encoding.AccountAddress),
  responder: genAddressField(Encoding.AccountAddress),
  channelAmount: u_int,
  initiatorAmount: u_int,
  responderAmount: u_int,
  channelReserve: u_int,
  initiatorDelegateIds: genArrayField(genAddressField(...idTagToEncoding)),
  responderDelegateIds: genArrayField(genAddressField(...idTagToEncoding)),
  stateHash: genEncodedField(Encoding.State),
  round: short_u_int,
  soloRound: u_int,
  lockPeriod: u_int,
  lockedUntil: u_int,
  initiatorAuth: genEncodedField(Encoding.ContractBytearray),
  responderAuth: genEncodedField(Encoding.ContractBytearray)
}, {
  tag: genShortUIntConstField(EntryTag.ChannelOffChainUpdateTransfer),
  version: genShortUIntConstField(1, true),
  from: genAddressField(Encoding.AccountAddress),
  to: genAddressField(Encoding.AccountAddress),
  amount: u_int
}, {
  tag: genShortUIntConstField(EntryTag.ChannelOffChainUpdateDeposit),
  version: genShortUIntConstField(1, true),
  from: genAddressField(Encoding.AccountAddress),
  amount: u_int
}, {
  tag: genShortUIntConstField(EntryTag.ChannelOffChainUpdateWithdraw),
  version: genShortUIntConstField(1, true),
  from: genAddressField(Encoding.AccountAddress),
  amount: u_int
}, {
  tag: genShortUIntConstField(EntryTag.ChannelOffChainUpdateCreateContract),
  version: genShortUIntConstField(1, true),
  owner: genAddressField(Encoding.AccountAddress),
  ctVersion: ct_version,
  code: genEncodedField(Encoding.ContractBytearray),
  deposit: u_int,
  callData: genEncodedField(Encoding.ContractBytearray)
}, {
  tag: genShortUIntConstField(EntryTag.ChannelOffChainUpdateCallContract),
  version: genShortUIntConstField(1, true),
  caller: genAddressField(Encoding.AccountAddress),
  contract: genAddressField(Encoding.ContractAddress),
  abiVersion: abi_version,
  amount: u_int,
  callData: genEncodedField(Encoding.ContractBytearray),
  callStack: raw,
  gasPrice: gas_price,
  gasLimit: gas_limit
}, {
  tag: genShortUIntConstField(EntryTag.TreesPoi),
  version: genShortUIntConstField(1, true),
  // TODO: inline an extra wrapping array after resolving https://github.com/aeternity/protocol/issues/505
  accounts: genArrayField(genMPTreeField(Encoding.AccountAddress, EntryTag.Account)),
  calls: genArrayField(genMPTreeField(Encoding.Bytearray, EntryTag.ContractCall)),
  channels: genArrayField(genMPTreeField(Encoding.Channel, EntryTag.Channel)),
  contracts: genArrayField(genMPTreeField(Encoding.ContractAddress, EntryTag.Contract)),
  ns: genArrayField(genMPTreeField(Encoding.Name, EntryTag.Name)),
  oracles: genArrayField(genMPTreeField(Encoding.OracleAddress, EntryTag.Oracle))
}, {
  tag: genShortUIntConstField(EntryTag.StateTrees),
  version: genShortUIntConstField(0, true),
  contracts: genWrappedField(EntryTag.ContractsMtree),
  calls: genWrappedField(EntryTag.CallsMtree),
  channels: genWrappedField(EntryTag.ChannelsMtree),
  ns: genWrappedField(EntryTag.NameserviceMtree),
  oracles: genWrappedField(EntryTag.OraclesMtree),
  accounts: genWrappedField(EntryTag.AccountsMtree)
}, {
  tag: genShortUIntConstField(EntryTag.Mtree),
  version: genShortUIntConstField(1, true),
  values: entryMtreeValueArray
}, {
  tag: genShortUIntConstField(EntryTag.MtreeValue),
  version: genShortUIntConstField(1, true),
  key: raw,
  value: raw
}, {
  tag: genShortUIntConstField(EntryTag.ContractsMtree),
  version: genShortUIntConstField(1, true),
  payload: mapContracts
}, {
  tag: genShortUIntConstField(EntryTag.CallsMtree),
  version: genShortUIntConstField(1, true),
  payload: mapCalls
}, {
  tag: genShortUIntConstField(EntryTag.ChannelsMtree),
  version: genShortUIntConstField(1, true),
  payload: mapChannels
}, {
  tag: genShortUIntConstField(EntryTag.NameserviceMtree),
  version: genShortUIntConstField(1, true),
  payload: mapNames
}, {
  tag: genShortUIntConstField(EntryTag.OraclesMtree),
  version: genShortUIntConstField(1, true),
  payload: mapOracles
}, {
  tag: genShortUIntConstField(EntryTag.AccountsMtree),
  version: genShortUIntConstField(1, true),
  payload: mapAccounts
}, {
  tag: genShortUIntConstField(EntryTag.GaMetaTxAuthData),
  version: genShortUIntConstField(1, true),
  fee: coin_amount,
  gasPrice: gas_price,
  txHash: genEncodedField(Encoding.TxHash)
}];
;// ./src/tx/builder/entry/index.ts




const encodingTag = [[EntryTag.CallsMtree, Encoding.CallStateTree], [EntryTag.StateTrees, Encoding.StateTrees], [EntryTag.TreesPoi, Encoding.Poi]];

/**
 * Pack entry
 * @category entry builder
 * @param params - Params of entry
 * @returns Encoded entry
 */

function packEntry(params) {
  var _encodingTag$find$;
  const encoding = (_encodingTag$find$ = encodingTag.find(([tag]) => tag === params.tag)?.[1]) !== null && _encodingTag$find$ !== void 0 ? _encodingTag$find$ : Encoding.Bytearray;
  return packRecord(schemas, EntryTag, params, {
    packEntry
  }, encoding);
}

/**
 * Unpack entry
 * @category entry builder
 * @param encoded - Encoded entry
 * @param expectedTag - Expected entry type
 * @returns Params of entry
 */

function unpackEntry(encoded, expectedTag) {
  expectedTag !== null && expectedTag !== void 0 ? expectedTag : expectedTag = encodingTag.find(([, enc]) => encoded.startsWith(enc))?.[0];
  return unpackRecord(schemas, EntryTag, encoded, expectedTag, {
    unpackEntry
  });
}
;// ./src/tx/builder/index.ts









/**
 * JavaScript-based Transaction builder
 */

function builder_getSchema(tag, version) {
  return getSchema(txSchema, Tag, tag, version);
}
/**
 * Build transaction
 * @category transaction builder
 * @param params - Transaction params
 */
function buildTx(params) {
  return packRecord(txSchema, Tag, params, {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    unpackTx,
    buildTx,
    rebuildTx: overrideParams => buildTx({
      ...params,
      ...overrideParams
    }),
    packEntry: packEntry
  }, Encoding.Transaction);
}
// TODO: require onNode because it is the only reason this builder is async [breaking change]
/**
 * Build transaction async (may request node for additional data)
 * @category transaction builder
 * @param params - Transaction params
 * @returns tx_-encoded transaction
 */
async function buildTxAsync(params) {
  await Promise.all(builder_getSchema(params.tag, params.version).map(async ([key, field]) => {
    if (field.prepare == null) return;
    // @ts-expect-error the type of `params[key]` can't be determined accurately
    params[key] = await field.prepare(params[key], params, params);
  }));

  // @ts-expect-error after preparation properties should be compatible with sync tx builder
  return buildTx(params);
}

/**
 * Unpack transaction encoded as string
 * @category transaction builder
 * @param encodedTx - Encoded transaction
 * @param txType - Expected transaction type
 * @returns Transaction params
 */
function unpackTx(encodedTx, txType) {
  return unpackRecord(txSchema, Tag, encodedTx, txType, {
    unpackTx,
    unpackEntry: unpackEntry
  });
}

/**
 * Build a transaction hash
 * @category transaction builder
 * @param rawTx - base64 or rlp encoded transaction
 * @returns Transaction hash
 */
function buildTxHash(rawTx) {
  const data = typeof rawTx === 'string' && rawTx.startsWith('tx_') ? decode(rawTx) : rawTx;
  return encode(hash(data), Encoding.TxHash);
}

/**
 * Build a contract public key by contractCreateTx, gaAttach or signedTx
 * @category contract
 * @param contractTx - Transaction
 * @returns Contract public key
 */
function buildContractIdByContractTx(contractTx) {
  let params = unpackTx(contractTx);
  if (Tag.SignedTx === params.tag) params = params.encodedTx;
  if (Tag.ContractCreateTx !== params.tag && Tag.GaAttachTx !== params.tag) {
    throw new ArgumentError('contractTx', 'a contractCreateTx or gaAttach', params.tag);
  }
  return buildContractId(params.ownerId, params.nonce);
}
// EXTERNAL MODULE: external "@azure/core-client"
var core_client_ = __webpack_require__(1081);
;// ./src/utils/semver-satisfies.ts
function verCmp(a, b) {
  const getComponents = v => v.split(/[-+]/)[0].split('.').map(i => +i);
  const aComponents = getComponents(a);
  const bComponents = getComponents(b);
  const base = Math.max(...aComponents, ...bComponents) + 1;
  const componentsToNumber = components => components.reverse().reduce((acc, n, idx) => acc + n * base ** idx, 0);
  return componentsToNumber(aComponents) - componentsToNumber(bComponents);
}
function semverSatisfies(version, geVersion, ltVersion) {
  return verCmp(version, geVersion) >= 0 && (ltVersion == null || verCmp(version, ltVersion) < 0);
}
;// ./src/utils/autorest.ts





const bigIntPrefix = '_sdk-big-int-';
const createSerializer = (...args) => {
  const serializer = (0,core_client_.createSerializer)(...args);
  const {
    serialize,
    deserialize
  } = serializer;
  return Object.assign(serializer, {
    serialize(...[mapper, object, objectName, options]) {
      // @ts-expect-error we are extending autorest with BigInt support
      if (mapper.type.name !== 'BigInt' || object == null) {
        return serialize.call(this, mapper, object, objectName, options);
      }
      if (typeof object !== 'bigint') {
        objectName !== null && objectName !== void 0 ? objectName : objectName = mapper.serializedName;
        throw new Error(`${objectName} with value ${object} must be of type bigint.`);
      }
      return object.toString();
    },
    deserialize(...[mapper, responseBody, objectName, options]) {
      // @ts-expect-error we are extending autorest with BigInt support
      if (mapper.type.name !== 'BigInt' || responseBody == null) {
        if (typeof responseBody === 'string' && responseBody.startsWith(bigIntPrefix)) {
          console.warn(`AeSdk internal error: BigInt value ${responseBody} handled incorrectly`);
          responseBody = +responseBody.replace(bigIntPrefix, '');
        }
        const result = deserialize.call(this, mapper, responseBody, objectName, options);
        // TODO: remove after fixing https://github.com/aeternity/ae_mdw/issues/1891
        // and https://github.com/aeternity/aeternity/issues/4386
        if (result instanceof Date) return new Date(+result / 1000);
        return result;
      }
      if (typeof responseBody === 'number' && responseBody > Number.MAX_SAFE_INTEGER) {
        throw new InternalError(`Number ${responseBody} is not accurate to be converted to BigInt`);
      }
      return BigInt(responseBody.toString().replace(bigIntPrefix, ''));
    }
  });
};
const safeLength = Number.MAX_SAFE_INTEGER.toString().length;
const bigIntPropertyRe = new RegExp(String.raw`("\w+":\s*)(\d{${safeLength},})(\s*[,}])`, 'm');
const bigIntArrayItemRe = new RegExp(String.raw`([[,]\s*)(\d{${safeLength},})\b`, 'm');
const parseBigIntPolicy = {
  name: 'parse-big-int',
  async sendRequest(request, next) {
    const response = await next(request);
    if (response.bodyAsText == null) return response;
    // TODO: replace with https://caniuse.com/mdn-javascript_builtins_json_parse_reviver_parameter_context_argument when it gets support in FF and Safari
    response.bodyAsText = response.bodyAsText.replaceAll(new RegExp(bigIntPropertyRe, 'g'), matched => {
      const match = matched.match(bigIntPropertyRe);
      if (match == null) throw new UnexpectedTsError();
      const [, name, value, end] = match;
      return [name, +value > Number.MAX_SAFE_INTEGER ? `"${bigIntPrefix}${value}"` : value, end].join('');
    });
    // FIXME: may break strings inside json
    response.bodyAsText = response.bodyAsText.replaceAll(new RegExp(bigIntArrayItemRe, 'g'), matched => {
      const match = matched.match(bigIntArrayItemRe);
      if (match == null) throw new UnexpectedTsError();
      const [, prefix, value] = match;
      return `${prefix}"${bigIntPrefix}${value}"`;
    });
    return response;
  }
};
const genRequestQueuesPolicy = () => {
  const requestQueues = new Map();
  return {
    policy: {
      name: 'request-queues',
      async sendRequest(request, next) {
        var _requestQueues$get;
        const key = request.headers.get('__queue');
        request.headers.delete('__queue');
        const getResponse = async () => next(request);
        if (key == null) return getResponse();
        const req = ((_requestQueues$get = requestQueues.get(key)) !== null && _requestQueues$get !== void 0 ? _requestQueues$get : Promise.resolve()).then(getResponse);
        requestQueues.set(key, req.catch(() => {}));
        return req;
      }
    },
    position: 'perCall'
  };
};
const genCombineGetRequestsPolicy = () => {
  const pendingGetRequests = new Map();
  return {
    policy: {
      name: 'combine-get-requests',
      async sendRequest(request, next) {
        var _pendingGetRequests$g;
        if (request.method !== 'GET') return next(request);
        const key = JSON.stringify([request.url, request.body]);
        const response = (_pendingGetRequests$g = pendingGetRequests.get(key)) !== null && _pendingGetRequests$g !== void 0 ? _pendingGetRequests$g : next(request);
        pendingGetRequests.set(key, response);
        try {
          return await response;
        } finally {
          pendingGetRequests.delete(key);
        }
      }
    },
    position: 'perCall'
  };
};
const genAggressiveCacheGetResponsesPolicy = () => {
  const getRequests = new Map();
  return {
    policy: {
      name: 'aggressive-cache-get-responses',
      async sendRequest(request, next) {
        var _getRequests$get;
        if (request.method !== 'GET') return next(request);
        const key = JSON.stringify([request.url, request.body]);
        const response = (_getRequests$get = getRequests.get(key)) !== null && _getRequests$get !== void 0 ? _getRequests$get : next(request);
        getRequests.set(key, response);
        return response;
      }
    },
    position: 'perCall'
  };
};
const genErrorFormatterPolicy = getMessage => ({
  policy: {
    name: 'error-formatter',
    async sendRequest(request, next) {
      try {
        return await next(request);
      } catch (error) {
        if (!(error instanceof core_rest_pipeline_.RestError) || error.request == null || error.message.startsWith('Error ')) throw error;
        const prefix = `${new URL(error.request.url).pathname.slice(1)} error`;
        if (error.response?.bodyAsText == null) {
          if (error.message === '') error.message = `${prefix}: ${error.code}`;
          throw error;
        }
        const body = error.response.parsedBody;
        error.message = prefix;
        const message = body == null ? ` ${error.response.status} status code` : getMessage(body);
        if (message !== '') error.message += `:${message}`;
        throw error;
      }
    }
  },
  position: 'perCall'
});
const genVersionCheckPolicy = (name, versionCb, geVersion, ltVersion, ignoreVersion) => ({
  policy: {
    name: 'version-check',
    async sendRequest(request, next) {
      if (request.headers.has('__version-check')) {
        request.headers.delete('__version-check');
        return next(request);
      }
      const options = {
        requestOptions: {
          customHeaders: {
            '__version-check': 'true'
          }
        }
      };
      const args = [await versionCb(options), geVersion, ltVersion];
      if (!semverSatisfies(...args)) {
        const error = new UnsupportedVersionError(name, ...args);
        if (ignoreVersion) console.warn(error.message);else throw error;
      }
      return next(request);
    }
  },
  position: 'perCall'
});
const genRetryOnFailurePolicy = (retryCount, retryOverallDelay) => ({
  policy: {
    name: 'retry-on-failure',
    async sendRequest(request, next) {
      var _request$headers$get;
      if (request.headers.get('__no-retry') != null) {
        request.headers.delete('__no-retry');
        return next(request);
      }
      const retryCode = (_request$headers$get = request.headers.get('__retry-code')) !== null && _request$headers$get !== void 0 ? _request$headers$get : NaN;
      request.headers.delete('__retry-code');
      const statusesToNotRetry = [200, 400, 403, 410, 500].filter(c => c !== +retryCode);
      const intervals = new Array(retryCount).fill(0).map((_, idx) => ((idx + 1) / retryCount) ** 2);
      const intervalSum = intervals.reduce((a, b) => a + b, 0);
      const intervalsInMs = intervals.map(e => Math.floor(e / intervalSum * retryOverallDelay));
      let error = new core_rest_pipeline_.RestError('Not expected to be thrown');
      for (let attempt = 0; attempt <= retryCount; attempt += 1) {
        if (attempt !== 0) {
          await pause(intervalsInMs[attempt - 1]);
          const urlParsed = new URL(request.url);
          urlParsed.searchParams.set('__sdk-retry', attempt.toString());
          request.url = urlParsed.toString();
        }
        try {
          return await next(request);
        } catch (e) {
          var _e$response$status;
          if (!(e instanceof core_rest_pipeline_.RestError)) throw e;
          if (statusesToNotRetry.includes((_e$response$status = e.response?.status) !== null && _e$response$status !== void 0 ? _e$response$status : 0)) throw e;
          error = e;
        }
      }
      throw error;
    }
  },
  position: 'perCall'
});
;// ./src/apis/node/models/mappers.ts
const Account = {
  type: {
    name: "Composite",
    className: "Account",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      balance: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "balance",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        required: true,
        type: {
          name: "Number"
        }
      },
      payable: {
        serializedName: "payable",
        type: {
          name: "Boolean"
        }
      },
      kind: {
        serializedName: "kind",
        type: {
          name: "Enum",
          allowedValues: ["basic", "generalized"]
        }
      },
      contractId: {
        serializedName: "contract_id",
        type: {
          name: "String"
        }
      },
      authFun: {
        serializedName: "auth_fun",
        type: {
          name: "String"
        }
      }
    }
  }
};
const ErrorModel = {
  type: {
    name: "Composite",
    className: "ErrorModel",
    modelProperties: {
      reason: {
        serializedName: "reason",
        required: true,
        type: {
          name: "String"
        }
      },
      errorCode: {
        serializedName: "error_code",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NextNonceResponse = {
  type: {
    name: "Composite",
    className: "NextNonceResponse",
    modelProperties: {
      nextNonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "next_nonce",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const SignedTxs = {
  type: {
    name: "Composite",
    className: "SignedTxs",
    modelProperties: {
      transactions: {
        serializedName: "transactions",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "SignedTx"
            }
          }
        }
      }
    }
  }
};
const SignedTx = {
  type: {
    name: "Composite",
    className: "SignedTx",
    modelProperties: {
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "Tx"
        }
      },
      blockHeight: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: -1
        },
        serializedName: "block_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      blockHash: {
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      encodedTx: {
        serializedName: "encoded_tx",
        type: {
          name: "String"
        }
      },
      signatures: {
        serializedName: "signatures",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const Tx = {
  type: {
    name: "Composite",
    className: "Tx",
    modelProperties: {
      recipientId: {
        serializedName: "recipient_id",
        type: {
          name: "String"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      senderId: {
        serializedName: "sender_id",
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      payload: {
        serializedName: "payload",
        type: {
          name: "String"
        }
      },
      initiatorId: {
        serializedName: "initiator_id",
        type: {
          name: "String"
        }
      },
      initiatorAmount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "initiator_amount",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      responderId: {
        serializedName: "responder_id",
        type: {
          name: "String"
        }
      },
      responderAmount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "responder_amount",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      channelReserve: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "channel_reserve",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      lockPeriod: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "lock_period",
        type: {
          name: "Number"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        type: {
          name: "String"
        }
      },
      delegateIds: {
        serializedName: "delegate_ids",
        type: {
          name: "Composite",
          className: "Delegates"
        }
      },
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        type: {
          name: "String"
        }
      },
      round: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "round",
        type: {
          name: "Number"
        }
      },
      toId: {
        serializedName: "to_id",
        type: {
          name: "String"
        }
      },
      update: {
        serializedName: "update",
        type: {
          name: "Composite",
          className: "OffChainUpdate"
        }
      },
      offchainTrees: {
        serializedName: "offchain_trees",
        type: {
          name: "String"
        }
      },
      initiatorAmountFinal: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "initiator_amount_final",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      responderAmountFinal: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "responder_amount_final",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      poi: {
        serializedName: "poi",
        type: {
          name: "String"
        }
      },
      initiatorDelegateIds: {
        serializedName: "initiator_delegate_ids",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      responderDelegateIds: {
        serializedName: "responder_delegate_ids",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      queryFormat: {
        serializedName: "query_format",
        type: {
          name: "String"
        }
      },
      responseFormat: {
        serializedName: "response_format",
        type: {
          name: "String"
        }
      },
      queryFee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "query_fee",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      oracleTtl: {
        serializedName: "oracle_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      accountId: {
        serializedName: "account_id",
        type: {
          name: "String"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        type: {
          name: "Number"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        type: {
          name: "String"
        }
      },
      queryTtl: {
        serializedName: "query_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      queryId: {
        serializedName: "query_id",
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        type: {
          name: "String"
        }
      },
      commitmentId: {
        serializedName: "commitment_id",
        type: {
          name: "String"
        }
      },
      name: {
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      nameSalt: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "name_salt",
        type: {
          name: "Number"
        }
      },
      nameFee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "name_fee",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nameId: {
        serializedName: "name_id",
        type: {
          name: "String"
        }
      },
      nameTtl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "name_ttl",
        type: {
          name: "Number"
        }
      },
      pointers: {
        serializedName: "pointers",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NamePointer"
            }
          }
        }
      },
      clientTtl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "client_ttl",
        type: {
          name: "Number"
        }
      },
      ownerId: {
        serializedName: "owner_id",
        type: {
          name: "String"
        }
      },
      code: {
        serializedName: "code",
        type: {
          name: "String"
        }
      },
      vmVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "vm_version",
        type: {
          name: "Number"
        }
      },
      deposit: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "deposit",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      gas: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "gas",
        type: {
          name: "Number"
        }
      },
      gasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas_price",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      callData: {
        serializedName: "call_data",
        type: {
          name: "String"
        }
      },
      callerId: {
        serializedName: "caller_id",
        type: {
          name: "String"
        }
      },
      contractId: {
        serializedName: "contract_id",
        type: {
          name: "String"
        }
      },
      authFun: {
        constraints: {
          Pattern: new RegExp("^(0x|0X)?[a-fA-F0-9]+$")
        },
        serializedName: "auth_fun",
        type: {
          name: "String"
        }
      },
      gaId: {
        serializedName: "ga_id",
        type: {
          name: "String"
        }
      },
      authData: {
        serializedName: "auth_data",
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "SignedTx"
        }
      },
      payerId: {
        serializedName: "payer_id",
        type: {
          name: "String"
        }
      },
      version: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "version",
        required: true,
        type: {
          name: "Number"
        }
      },
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["SpendTx", "ChannelCreateTx", "ChannelDepositTx", "ChannelWithdrawTx", "ChannelForceProgressTx", "ChannelCloseMutualTx", "ChannelCloseSoloTx", "ChannelSlashTx", "ChannelSettleTx", "ChannelSnapshotSoloTx", "ChannelSetDelegatesTx", "OracleRegisterTx", "OracleExtendTx", "OracleQueryTx", "OracleRespondTx", "NamePreclaimTx", "NameClaimTx", "NameUpdateTx", "NameTransferTx", "NameRevokeTx", "ContractCreateTx", "ContractCallTx", "GAAttachTx", "GAMetaTx", "PayingForTx"]
        }
      }
    }
  }
};
const Delegates = {
  type: {
    name: "Composite",
    className: "Delegates",
    modelProperties: {
      initiator: {
        serializedName: "initiator",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      responder: {
        serializedName: "responder",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const OffChainUpdate = {
  type: {
    name: "Composite",
    className: "OffChainUpdate",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: {
      serializedName: "op",
      clientName: "op"
    },
    modelProperties: {
      op: {
        serializedName: "op",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const RelativeTTL = {
  type: {
    name: "Composite",
    className: "RelativeTTL",
    modelProperties: {
      type: {
        defaultValue: "delta",
        isConstant: true,
        serializedName: "type",
        type: {
          name: "String"
        }
      },
      value: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "value",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Ttl = {
  type: {
    name: "Composite",
    className: "Ttl",
    modelProperties: {
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["delta", "block"]
        }
      },
      value: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "value",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const NamePointer = {
  type: {
    name: "Composite",
    className: "NamePointer",
    modelProperties: {
      key: {
        serializedName: "key",
        required: true,
        type: {
          name: "String"
        }
      },
      encodedKey: {
        serializedName: "encoded_key",
        type: {
          name: "String"
        }
      },
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const AuctionEntry = {
  type: {
    name: "Composite",
    className: "AuctionEntry",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      startedAt: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "started_at",
        required: true,
        type: {
          name: "Number"
        }
      },
      endsAt: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ends_at",
        required: true,
        type: {
          name: "Number"
        }
      },
      highestBidder: {
        serializedName: "highest_bidder",
        required: true,
        type: {
          name: "String"
        }
      },
      highestBid: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "highest_bid",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      }
    }
  }
};
const Channel = {
  type: {
    name: "Composite",
    className: "Channel",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorId: {
        serializedName: "initiator_id",
        required: true,
        type: {
          name: "String"
        }
      },
      responderId: {
        serializedName: "responder_id",
        required: true,
        type: {
          name: "String"
        }
      },
      channelAmount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "channel_amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      initiatorAmount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "initiator_amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      responderAmount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "responder_amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      channelReserve: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "channel_reserve",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      delegateIds: {
        serializedName: "delegate_ids",
        type: {
          name: "Composite",
          className: "Delegates"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "round",
        required: true,
        type: {
          name: "Number"
        }
      },
      soloRound: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "solo_round",
        required: true,
        type: {
          name: "Number"
        }
      },
      lockPeriod: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "lock_period",
        required: true,
        type: {
          name: "Number"
        }
      },
      lockedUntil: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "locked_until",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const ContractObject = {
  type: {
    name: "Composite",
    className: "ContractObject",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      ownerId: {
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "vm_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      active: {
        serializedName: "active",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      referrerIds: {
        serializedName: "referrer_ids",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      deposit: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "deposit",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      }
    }
  }
};
const ByteCode = {
  type: {
    name: "Composite",
    className: "ByteCode",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PoI = {
  type: {
    name: "Composite",
    className: "PoI",
    modelProperties: {
      poi: {
        serializedName: "poi",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Currency = {
  type: {
    name: "Composite",
    className: "Currency",
    modelProperties: {
      name: {
        serializedName: "name",
        required: true,
        type: {
          name: "String"
        }
      },
      symbol: {
        serializedName: "symbol",
        required: true,
        type: {
          name: "String"
        }
      },
      subunit: {
        serializedName: "subunit",
        required: true,
        type: {
          name: "String"
        }
      },
      subunitsPerUnit: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "subunits_per_unit",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fiatConverstionUrl: {
        serializedName: "fiat_converstion_url",
        type: {
          name: "String"
        }
      },
      fiatConversionUrl: {
        serializedName: "fiat_conversion_url",
        type: {
          name: "String"
        }
      },
      logo: {
        serializedName: "logo",
        type: {
          name: "Composite",
          className: "Image"
        }
      },
      primaryColour: {
        serializedName: "primary_colour",
        required: true,
        type: {
          name: "String"
        }
      },
      secondaryColour: {
        serializedName: "secondary_colour",
        required: true,
        type: {
          name: "String"
        }
      },
      networkName: {
        serializedName: "network_name",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Image = {
  type: {
    name: "Composite",
    className: "Image",
    modelProperties: {
      type: {
        serializedName: "type",
        type: {
          name: "String"
        }
      },
      data: {
        serializedName: "data",
        type: {
          name: "String"
        }
      }
    }
  }
};
const DryRunInput = {
  type: {
    name: "Composite",
    className: "DryRunInput",
    modelProperties: {
      top: {
        serializedName: "top",
        type: {
          name: "String"
        }
      },
      accounts: {
        serializedName: "accounts",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DryRunAccount"
            }
          }
        }
      },
      txs: {
        serializedName: "txs",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DryRunInputItem"
            }
          }
        }
      },
      txEvents: {
        defaultValue: false,
        serializedName: "tx_events",
        type: {
          name: "Boolean"
        }
      }
    }
  }
};
const DryRunAccount = {
  type: {
    name: "Composite",
    className: "DryRunAccount",
    modelProperties: {
      pubKey: {
        serializedName: "pub_key",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      }
    }
  }
};
const DryRunInputItem = {
  type: {
    name: "Composite",
    className: "DryRunInputItem",
    modelProperties: {
      tx: {
        serializedName: "tx",
        type: {
          name: "String"
        }
      },
      txHash: {
        serializedName: "tx_hash",
        type: {
          name: "String"
        }
      },
      callReq: {
        serializedName: "call_req",
        type: {
          name: "Composite",
          className: "DryRunCallReq"
        }
      }
    }
  }
};
const DryRunCallReq = {
  type: {
    name: "Composite",
    className: "DryRunCallReq",
    modelProperties: {
      calldata: {
        serializedName: "calldata",
        required: true,
        type: {
          name: "String"
        }
      },
      contract: {
        serializedName: "contract",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      gas: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas",
        type: {
          name: "Number"
        }
      },
      caller: {
        serializedName: "caller",
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        type: {
          name: "Number"
        }
      },
      context: {
        serializedName: "context",
        type: {
          name: "Composite",
          className: "DryRunCallContext"
        }
      }
    }
  }
};
const DryRunCallContext = {
  type: {
    name: "Composite",
    className: "DryRunCallContext",
    modelProperties: {
      tx: {
        serializedName: "tx",
        type: {
          name: "String"
        }
      },
      txHash: {
        serializedName: "tx_hash",
        type: {
          name: "String"
        }
      },
      stateful: {
        serializedName: "stateful",
        type: {
          name: "Boolean"
        }
      }
    }
  }
};
const DryRunResults = {
  type: {
    name: "Composite",
    className: "DryRunResults",
    modelProperties: {
      results: {
        serializedName: "results",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DryRunResult"
            }
          }
        }
      },
      txEvents: {
        serializedName: "tx_events",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Dictionary",
              value: {
                type: {
                  name: "any"
                }
              }
            }
          }
        }
      }
    }
  }
};
const DryRunResult = {
  type: {
    name: "Composite",
    className: "DryRunResult",
    modelProperties: {
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "String"
        }
      },
      result: {
        serializedName: "result",
        required: true,
        type: {
          name: "String"
        }
      },
      reason: {
        serializedName: "reason",
        type: {
          name: "String"
        }
      },
      callObj: {
        serializedName: "call_obj",
        type: {
          name: "Composite",
          className: "ContractCallObject"
        }
      }
    }
  }
};
const ContractCallObject = {
  type: {
    name: "Composite",
    className: "ContractCallObject",
    modelProperties: {
      callerId: {
        serializedName: "caller_id",
        required: true,
        type: {
          name: "String"
        }
      },
      callerNonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "caller_nonce",
        required: true,
        type: {
          name: "Number"
        }
      },
      height: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas_price",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      gasUsed: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "gas_used",
        required: true,
        type: {
          name: "Number"
        }
      },
      log: {
        serializedName: "log",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Event"
            }
          }
        }
      },
      returnValue: {
        serializedName: "return_value",
        required: true,
        type: {
          name: "String"
        }
      },
      returnType: {
        serializedName: "return_type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["ok", "error", "revert"]
        }
      }
    }
  }
};
const mappers_Event = {
  type: {
    name: "Composite",
    className: "Event",
    modelProperties: {
      address: {
        serializedName: "address",
        required: true,
        type: {
          name: "String"
        }
      },
      topics: {
        serializedName: "topics",
        required: true,
        type: {
          name: "Sequence",
          element: {
            constraints: {
              InclusiveMinimum: 0
            },
            type: {
              // @ts-expect-error we are extending autorest with BigInt support
              name: "BigInt"
            }
          }
        }
      },
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Generation = {
  type: {
    name: "Composite",
    className: "Generation",
    modelProperties: {
      keyBlock: {
        serializedName: "key_block",
        type: {
          name: "Composite",
          className: "KeyBlock"
        }
      },
      microBlocks: {
        serializedName: "micro_blocks",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const KeyBlock = {
  type: {
    name: "Composite",
    className: "KeyBlock",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      miner: {
        serializedName: "miner",
        required: true,
        type: {
          name: "String"
        }
      },
      beneficiary: {
        serializedName: "beneficiary",
        required: true,
        type: {
          name: "String"
        }
      },
      flags: {
        serializedName: "flags",
        required: true,
        type: {
          name: "String"
        }
      },
      target: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "target",
        required: true,
        type: {
          name: "Number"
        }
      },
      pow: {
        constraints: {
          MinItems: 42,
          MaxItems: 42
        },
        serializedName: "pow",
        type: {
          name: "Sequence",
          element: {
            constraints: {
              InclusiveMaximum: 4294967295,
              InclusiveMinimum: 0
            },
            type: {
              name: "Number"
            }
          }
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      time: {
        serializedName: "time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      version: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "version",
        required: true,
        type: {
          name: "Number"
        }
      },
      info: {
        serializedName: "info",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Header = {
  type: {
    name: "Composite",
    className: "Header",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      miner: {
        serializedName: "miner",
        type: {
          name: "String"
        }
      },
      beneficiary: {
        serializedName: "beneficiary",
        type: {
          name: "String"
        }
      },
      flags: {
        serializedName: "flags",
        type: {
          name: "String"
        }
      },
      target: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "target",
        type: {
          name: "Number"
        }
      },
      pow: {
        constraints: {
          MinItems: 42,
          MaxItems: 42
        },
        serializedName: "pow",
        type: {
          name: "Sequence",
          element: {
            constraints: {
              InclusiveMaximum: 4294967295,
              InclusiveMinimum: 0
            },
            type: {
              name: "Number"
            }
          }
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      time: {
        serializedName: "time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      version: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "version",
        required: true,
        type: {
          name: "Number"
        }
      },
      info: {
        serializedName: "info",
        type: {
          name: "String"
        }
      },
      pofHash: {
        serializedName: "pof_hash",
        type: {
          name: "String"
        }
      },
      txsHash: {
        serializedName: "txs_hash",
        type: {
          name: "String"
        }
      },
      signature: {
        serializedName: "signature",
        type: {
          name: "String"
        }
      }
    }
  }
};
const PinningTx = {
  type: {
    name: "Composite",
    className: "PinningTx",
    modelProperties: {
      epoch: {
        serializedName: "epoch",
        required: true,
        type: {
          name: "Number"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      blockHash: {
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      parentPayload: {
        serializedName: "parent_payload",
        required: true,
        type: {
          name: "String"
        }
      },
      lastLeader: {
        serializedName: "last_leader",
        required: true,
        type: {
          name: "String"
        }
      },
      parentType: {
        serializedName: "parent_type",
        required: true,
        type: {
          name: "String"
        }
      },
      parentNetworkId: {
        serializedName: "parent_network_id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const HCContractPubkeys = {
  type: {
    name: "Composite",
    className: "HCContractPubkeys",
    modelProperties: {
      staking: {
        serializedName: "staking",
        required: true,
        type: {
          name: "String"
        }
      },
      election: {
        serializedName: "election",
        type: {
          name: "String"
        }
      },
      rewards: {
        serializedName: "rewards",
        type: {
          name: "String"
        }
      }
    }
  }
};
const HashResponse = {
  type: {
    name: "Composite",
    className: "HashResponse",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const HeightResponse = {
  type: {
    name: "Composite",
    className: "HeightResponse",
    modelProperties: {
      height: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const MicroBlockHeader = {
  type: {
    name: "Composite",
    className: "MicroBlockHeader",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      pofHash: {
        serializedName: "pof_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      txsHash: {
        serializedName: "txs_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      signature: {
        serializedName: "signature",
        required: true,
        type: {
          name: "String"
        }
      },
      time: {
        serializedName: "time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      version: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "version",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const CountResponse = {
  type: {
    name: "Composite",
    className: "CountResponse",
    modelProperties: {
      count: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "count",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const NameEntry = {
  type: {
    name: "Composite",
    className: "NameEntry",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      owner: {
        serializedName: "owner",
        type: {
          name: "String"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        required: true,
        type: {
          name: "Number"
        }
      },
      pointers: {
        serializedName: "pointers",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NamePointerComplete"
            }
          }
        }
      }
    }
  }
};
const NamePointerComplete = {
  type: {
    name: "Composite",
    className: "NamePointerComplete",
    modelProperties: {
      key: {
        serializedName: "key",
        required: true,
        type: {
          name: "String"
        }
      },
      encodedKey: {
        serializedName: "encoded_key",
        required: true,
        type: {
          name: "String"
        }
      },
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const RegisteredOracle = {
  type: {
    name: "Composite",
    className: "RegisteredOracle",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFormat: {
        serializedName: "query_format",
        required: true,
        type: {
          name: "String"
        }
      },
      responseFormat: {
        serializedName: "response_format",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "query_fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        required: true,
        type: {
          name: "Number"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const OracleQueries = {
  type: {
    name: "Composite",
    className: "OracleQueries",
    modelProperties: {
      oracleQueries: {
        serializedName: "oracle_queries",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "OracleQuery"
            }
          }
        }
      }
    }
  }
};
const OracleQuery = {
  type: {
    name: "Composite",
    className: "OracleQuery",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      senderId: {
        serializedName: "sender_id",
        required: true,
        type: {
          name: "String"
        }
      },
      senderNonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "sender_nonce",
        required: true,
        type: {
          name: "Number"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        required: true,
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        required: true,
        type: {
          name: "Number"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      }
    }
  }
};
const PeerPubKey = {
  type: {
    name: "Composite",
    className: "PeerPubKey",
    modelProperties: {
      pubkey: {
        serializedName: "pubkey",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const GasPricesItem = {
  type: {
    name: "Composite",
    className: "GasPricesItem",
    modelProperties: {
      minGasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "min_gas_price",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      utilization: {
        constraints: {
          InclusiveMaximum: 100,
          InclusiveMinimum: 0
        },
        serializedName: "utilization",
        required: true,
        type: {
          name: "Number"
        }
      },
      minutes: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "minutes",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Status = {
  type: {
    name: "Composite",
    className: "Status",
    modelProperties: {
      genesisKeyBlockHash: {
        serializedName: "genesis_key_block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      solutions: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "solutions",
        required: true,
        type: {
          name: "Number"
        }
      },
      difficulty: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "difficulty",
        required: true,
        type: {
          name: "Number"
        }
      },
      hashrate: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "hashrate",
        required: true,
        type: {
          name: "Number"
        }
      },
      syncing: {
        serializedName: "syncing",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      syncProgress: {
        constraints: {
          InclusiveMaximum: 100,
          InclusiveMinimum: 0
        },
        serializedName: "sync_progress",
        type: {
          name: "Number"
        }
      },
      uptime: {
        serializedName: "uptime",
        required: true,
        type: {
          name: "String"
        }
      },
      listening: {
        serializedName: "listening",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      protocols: {
        serializedName: "protocols",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Protocol"
            }
          }
        }
      },
      nodeVersion: {
        serializedName: "node_version",
        required: true,
        type: {
          name: "String"
        }
      },
      nodeRevision: {
        serializedName: "node_revision",
        required: true,
        type: {
          name: "String"
        }
      },
      peerCount: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "peer_count",
        required: true,
        type: {
          name: "Number"
        }
      },
      peerConnections: {
        serializedName: "peer_connections",
        type: {
          name: "Composite",
          className: "PeerConnections"
        }
      },
      pendingTransactionsCount: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "pending_transactions_count",
        required: true,
        type: {
          name: "Number"
        }
      },
      networkId: {
        serializedName: "network_id",
        required: true,
        type: {
          name: "String"
        }
      },
      peerPubkey: {
        serializedName: "peer_pubkey",
        required: true,
        type: {
          name: "String"
        }
      },
      topKeyBlockHash: {
        serializedName: "top_key_block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      topBlockHeight: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "top_block_height",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Protocol = {
  type: {
    name: "Composite",
    className: "Protocol",
    modelProperties: {
      version: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "version",
        required: true,
        type: {
          name: "Number"
        }
      },
      effectiveAtHeight: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "effective_at_height",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PeerConnections = {
  type: {
    name: "Composite",
    className: "PeerConnections",
    modelProperties: {
      inbound: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "inbound",
        required: true,
        type: {
          name: "Number"
        }
      },
      outbound: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "outbound",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const SyncStatus = {
  type: {
    name: "Composite",
    className: "SyncStatus",
    modelProperties: {
      progress: {
        serializedName: "progress",
        required: true,
        type: {
          name: "Number"
        }
      },
      target: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "target",
        required: true,
        type: {
          name: "Number"
        }
      },
      speed: {
        serializedName: "speed",
        required: true,
        type: {
          name: "Number"
        }
      },
      estimate: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "estimate",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const EncodedTx = {
  type: {
    name: "Composite",
    className: "EncodedTx",
    modelProperties: {
      tx: {
        serializedName: "tx",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PostTxResponse = {
  type: {
    name: "Composite",
    className: "PostTxResponse",
    modelProperties: {
      txHash: {
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const TxInfoObject = {
  type: {
    name: "Composite",
    className: "TxInfoObject",
    modelProperties: {
      callInfo: {
        serializedName: "call_info",
        type: {
          name: "Composite",
          className: "ContractCallObject"
        }
      },
      gaInfo: {
        serializedName: "ga_info",
        type: {
          name: "Composite",
          className: "GAObject"
        }
      },
      txInfo: {
        serializedName: "tx_info",
        type: {
          name: "String"
        }
      }
    }
  }
};
const GAObject = {
  type: {
    name: "Composite",
    className: "GAObject",
    modelProperties: {
      callerId: {
        serializedName: "caller_id",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      gasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas_price",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      gasUsed: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "gas_used",
        required: true,
        type: {
          name: "Number"
        }
      },
      returnValue: {
        serializedName: "return_value",
        required: true,
        type: {
          name: "String"
        }
      },
      returnType: {
        serializedName: "return_type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["ok", "error"]
        }
      },
      innerObject: {
        serializedName: "inner_object",
        type: {
          name: "Composite",
          className: "TxInfoObject"
        }
      }
    }
  }
};
const ChannelCloseMutualTx = {
  type: {
    name: "Composite",
    className: "ChannelCloseMutualTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmountFinal: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "initiator_amount_final",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      responderAmountFinal: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "responder_amount_final",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const ChannelCloseSoloTx = {
  type: {
    name: "Composite",
    className: "ChannelCloseSoloTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      poi: {
        serializedName: "poi",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelCreateTx = {
  type: {
    name: "Composite",
    className: "ChannelCreateTx",
    modelProperties: {
      initiatorId: {
        serializedName: "initiator_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "initiator_amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      responderId: {
        serializedName: "responder_id",
        required: true,
        type: {
          name: "String"
        }
      },
      responderAmount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "responder_amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      channelReserve: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "channel_reserve",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      lockPeriod: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "lock_period",
        required: true,
        type: {
          name: "Number"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      delegateIds: {
        serializedName: "delegate_ids",
        type: {
          name: "Composite",
          className: "Delegates"
        }
      }
    }
  }
};
const ChannelDepositTx = {
  type: {
    name: "Composite",
    className: "ChannelDepositTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        required: true,
        type: {
          name: "Number"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "round",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const ChannelForceProgressTx = {
  type: {
    name: "Composite",
    className: "ChannelForceProgressTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "round",
        required: true,
        type: {
          name: "Number"
        }
      },
      update: {
        serializedName: "update",
        type: {
          name: "Composite",
          className: "OffChainUpdate"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      offchainTrees: {
        serializedName: "offchain_trees",
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelSetDelegatesTx = {
  type: {
    name: "Composite",
    className: "ChannelSetDelegatesTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorDelegateIds: {
        serializedName: "initiator_delegate_ids",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      responderDelegateIds: {
        serializedName: "responder_delegate_ids",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "round",
        required: true,
        type: {
          name: "Number"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const ChannelSettleTx = {
  type: {
    name: "Composite",
    className: "ChannelSettleTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmountFinal: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "initiator_amount_final",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      responderAmountFinal: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "responder_amount_final",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const ChannelSlashTx = {
  type: {
    name: "Composite",
    className: "ChannelSlashTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      poi: {
        serializedName: "poi",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelSnapshotSoloTx = {
  type: {
    name: "Composite",
    className: "ChannelSnapshotSoloTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const ChannelWithdrawTx = {
  type: {
    name: "Composite",
    className: "ChannelWithdrawTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      toId: {
        serializedName: "to_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        required: true,
        type: {
          name: "Number"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "round",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const CheckTxInPoolResponse = {
  type: {
    name: "Composite",
    className: "CheckTxInPoolResponse",
    modelProperties: {
      status: {
        serializedName: "status",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const CommitmentId = {
  type: {
    name: "Composite",
    className: "CommitmentId",
    modelProperties: {
      commitmentId: {
        serializedName: "commitment_id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ContractCallTx = {
  type: {
    name: "Composite",
    className: "ContractCallTx",
    modelProperties: {
      callerId: {
        serializedName: "caller_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      gas: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "gas",
        required: true,
        type: {
          name: "Number"
        }
      },
      gasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas_price",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ContractCreateTx = {
  type: {
    name: "Composite",
    className: "ContractCreateTx",
    modelProperties: {
      ownerId: {
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "vm_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      deposit: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "deposit",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      gas: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "gas",
        required: true,
        type: {
          name: "Number"
        }
      },
      gasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas_price",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const UnsignedTx = {
  type: {
    name: "Composite",
    className: "UnsignedTx",
    modelProperties: {
      tx: {
        serializedName: "tx",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const GAAttachTx = {
  type: {
    name: "Composite",
    className: "GAAttachTx",
    modelProperties: {
      ownerId: {
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "vm_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      gas: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "gas",
        required: true,
        type: {
          name: "Number"
        }
      },
      gasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas_price",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      },
      authFun: {
        constraints: {
          Pattern: new RegExp("^(0x|0X)?[a-fA-F0-9]+$")
        },
        serializedName: "auth_fun",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const GAMetaTx = {
  type: {
    name: "Composite",
    className: "GAMetaTx",
    modelProperties: {
      gaId: {
        serializedName: "ga_id",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      gas: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "gas",
        required: true,
        type: {
          name: "Number"
        }
      },
      gasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas_price",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      authData: {
        serializedName: "auth_data",
        required: true,
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "SignedTx"
        }
      }
    }
  }
};
const NameClaimTx = {
  type: {
    name: "Composite",
    className: "NameClaimTx",
    modelProperties: {
      name: {
        serializedName: "name",
        required: true,
        type: {
          name: "String"
        }
      },
      nameSalt: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "name_salt",
        required: true,
        type: {
          name: "Number"
        }
      },
      nameFee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "name_fee",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const NameHash = {
  type: {
    name: "Composite",
    className: "NameHash",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const NamePreclaimTx = {
  type: {
    name: "Composite",
    className: "NamePreclaimTx",
    modelProperties: {
      commitmentId: {
        serializedName: "commitment_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const NameRevokeTx = {
  type: {
    name: "Composite",
    className: "NameRevokeTx",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const NameTransferTx = {
  type: {
    name: "Composite",
    className: "NameTransferTx",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      },
      recipientId: {
        serializedName: "recipient_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const NameUpdateTx = {
  type: {
    name: "Composite",
    className: "NameUpdateTx",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nameTtl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "name_ttl",
        required: true,
        type: {
          name: "Number"
        }
      },
      pointers: {
        serializedName: "pointers",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NamePointer"
            }
          }
        }
      },
      clientTtl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "client_ttl",
        required: true,
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PeerDetails = {
  type: {
    name: "Composite",
    className: "PeerDetails",
    modelProperties: {
      host: {
        serializedName: "host",
        required: true,
        type: {
          name: "String"
        }
      },
      port: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "port",
        required: true,
        type: {
          name: "Number"
        }
      },
      firstSeen: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "first_seen",
        required: true,
        type: {
          name: "Number"
        }
      },
      lastSeen: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "last_seen",
        required: true,
        type: {
          name: "Number"
        }
      },
      genesisHash: {
        serializedName: "genesis_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      topHash: {
        serializedName: "top_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      topDifficulty: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "top_difficulty",
        required: true,
        type: {
          name: "Number"
        }
      },
      networkId: {
        serializedName: "network_id",
        type: {
          name: "String"
        }
      },
      nodeVersion: {
        serializedName: "node_version",
        type: {
          name: "String"
        }
      },
      nodeRevision: {
        serializedName: "node_revision",
        type: {
          name: "String"
        }
      },
      nodeVendor: {
        serializedName: "node_vendor",
        type: {
          name: "String"
        }
      },
      nodeOs: {
        serializedName: "node_os",
        type: {
          name: "String"
        }
      }
    }
  }
};
const OracleExtendTx = {
  type: {
    name: "Composite",
    className: "OracleExtendTx",
    modelProperties: {
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      oracleTtl: {
        serializedName: "oracle_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const OracleQueryTx = {
  type: {
    name: "Composite",
    className: "OracleQueryTx",
    modelProperties: {
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "query_fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      queryTtl: {
        serializedName: "query_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      senderId: {
        serializedName: "sender_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const OracleRegisterTx = {
  type: {
    name: "Composite",
    className: "OracleRegisterTx",
    modelProperties: {
      queryFormat: {
        serializedName: "query_format",
        required: true,
        type: {
          name: "String"
        }
      },
      responseFormat: {
        serializedName: "response_format",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "query_fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      oracleTtl: {
        serializedName: "oracle_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const OracleRespondTx = {
  type: {
    name: "Composite",
    className: "OracleRespondTx",
    modelProperties: {
      queryId: {
        serializedName: "query_id",
        required: true,
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        required: true,
        type: {
          name: "String"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PayingForTx = {
  type: {
    name: "Composite",
    className: "PayingForTx",
    modelProperties: {
      payerId: {
        serializedName: "payer_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "SignedTx"
        }
      }
    }
  }
};
const PeerCount = {
  type: {
    name: "Composite",
    className: "PeerCount",
    modelProperties: {
      connected: {
        serializedName: "connected",
        type: {
          name: "Composite",
          className: "PeerCountConnected"
        }
      },
      available: {
        serializedName: "available",
        type: {
          name: "Composite",
          className: "PeerCountAvailable"
        }
      },
      blocked: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "blocked",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PeerCountConnected = {
  type: {
    name: "Composite",
    className: "PeerCountConnected",
    modelProperties: {
      inbound: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "inbound",
        type: {
          name: "Number"
        }
      },
      outbound: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "outbound",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PeerCountAvailable = {
  type: {
    name: "Composite",
    className: "PeerCountAvailable",
    modelProperties: {
      verified: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "verified",
        type: {
          name: "Number"
        }
      },
      unverified: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "unverified",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Peers = {
  type: {
    name: "Composite",
    className: "Peers",
    modelProperties: {
      peers: {
        serializedName: "peers",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      blocked: {
        serializedName: "blocked",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const PubKey = {
  type: {
    name: "Composite",
    className: "PubKey",
    modelProperties: {
      pubKey: {
        serializedName: "pub_key",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const SpendTx = {
  type: {
    name: "Composite",
    className: "SpendTx",
    modelProperties: {
      recipientId: {
        serializedName: "recipient_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      senderId: {
        serializedName: "sender_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const TokenSupply = {
  type: {
    name: "Composite",
    className: "TokenSupply",
    modelProperties: {
      accounts: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "accounts",
        type: {
          name: "Number"
        }
      },
      contracts: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "contracts",
        type: {
          name: "Number"
        }
      },
      contractOracles: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "contract_oracles",
        type: {
          name: "Number"
        }
      },
      locked: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "locked",
        type: {
          name: "Number"
        }
      },
      oracles: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "oracles",
        type: {
          name: "Number"
        }
      },
      oracleQueries: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "oracle_queries",
        type: {
          name: "Number"
        }
      },
      pendingRewards: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "pending_rewards",
        type: {
          name: "Number"
        }
      },
      total: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "total",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const OffChainCallContract = {
  serializedName: "OffChainCallContract",
  type: {
    name: "Composite",
    className: "OffChainCallContract",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: {
      ...OffChainUpdate.type.modelProperties,
      caller: {
        serializedName: "caller",
        required: true,
        type: {
          name: "String"
        }
      },
      contract: {
        serializedName: "contract",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      gas: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "gas",
        required: true,
        type: {
          name: "Number"
        }
      },
      gasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas_price",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OffChainDeposit = {
  serializedName: "OffChainDeposit",
  type: {
    name: "Composite",
    className: "OffChainDeposit",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: {
      ...OffChainUpdate.type.modelProperties,
      from: {
        serializedName: "from",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      }
    }
  }
};
const OffChainNewContract = {
  serializedName: "OffChainNewContract",
  type: {
    name: "Composite",
    className: "OffChainNewContract",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: {
      ...OffChainUpdate.type.modelProperties,
      owner: {
        serializedName: "owner",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "vm_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      code: {
        serializedName: "code",
        type: {
          name: "Composite",
          className: "ByteCode"
        }
      },
      deposit: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "deposit",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OffChainTransfer = {
  serializedName: "OffChainTransfer",
  type: {
    name: "Composite",
    className: "OffChainTransfer",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: {
      ...OffChainUpdate.type.modelProperties,
      from: {
        serializedName: "from",
        required: true,
        type: {
          name: "String"
        }
      },
      to: {
        serializedName: "to",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      }
    }
  }
};
const OffChainWithdrawal = {
  serializedName: "OffChainWithdrawal",
  type: {
    name: "Composite",
    className: "OffChainWithdrawal",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: {
      ...OffChainUpdate.type.modelProperties,
      to: {
        serializedName: "to",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      }
    }
  }
};
const CreateContractUnsignedTx = {
  type: {
    name: "Composite",
    className: "CreateContractUnsignedTx",
    modelProperties: {
      ...UnsignedTx.type.modelProperties,
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
let discriminators = {
  OffChainUpdate: OffChainUpdate,
  "OffChainUpdate.OffChainCallContract": OffChainCallContract,
  "OffChainUpdate.OffChainDeposit": OffChainDeposit,
  "OffChainUpdate.OffChainNewContract": OffChainNewContract,
  "OffChainUpdate.OffChainTransfer": OffChainTransfer,
  "OffChainUpdate.OffChainWithdrawal": OffChainWithdrawal
};
;// ./src/apis/node/models/parameters.ts

const accept = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
};
const $host = {
  parameterPath: "$host",
  mapper: {
    serializedName: "$host",
    required: true,
    type: {
      name: "String"
    }
  },
  skipEncoding: true
};
const pubkey = {
  parameterPath: "pubkey",
  mapper: {
    serializedName: "pubkey",
    required: true,
    type: {
      name: "String"
    }
  }
};
const parameters_hash = {
  parameterPath: "hash",
  mapper: {
    serializedName: "hash",
    required: true,
    type: {
      name: "String"
    }
  }
};
const height = {
  parameterPath: "height",
  mapper: {
    constraints: {
      InclusiveMaximum: 18446744073709552000,
      InclusiveMinimum: 0
    },
    serializedName: "height",
    required: true,
    type: {
      name: "Number"
    }
  }
};
const strategy = {
  parameterPath: ["options", "strategy"],
  mapper: {
    defaultValue: "max",
    serializedName: "strategy",
    type: {
      name: "Enum",
      allowedValues: ["max", "continuity"]
    }
  }
};
const parameters_name = {
  parameterPath: "name",
  mapper: {
    serializedName: "name",
    required: true,
    type: {
      name: "String"
    }
  }
};
const contentType = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
};
const body = {
  parameterPath: "body",
  mapper: DryRunInput
};
const index = {
  parameterPath: "index",
  mapper: {
    constraints: {
      InclusiveMinimum: 1
    },
    serializedName: "index",
    required: true,
    type: {
      name: "Number"
    }
  }
};
const nameHash = {
  parameterPath: "nameHash",
  mapper: {
    serializedName: "name_hash",
    required: true,
    type: {
      name: "String"
    }
  }
};
const fromParam = {
  parameterPath: ["options", "from"],
  mapper: {
    serializedName: "from",
    type: {
      name: "String"
    }
  }
};
const limit = {
  parameterPath: ["options", "limit"],
  mapper: {
    defaultValue: 20,
    constraints: {
      InclusiveMaximum: 1000,
      InclusiveMinimum: 1
    },
    serializedName: "limit",
    type: {
      name: "Number"
    }
  }
};
const typeParam = {
  parameterPath: ["options", "type"],
  mapper: {
    defaultValue: "all",
    serializedName: "type",
    type: {
      name: "Enum",
      allowedValues: ["open", "closed", "all"]
    }
  }
};
const queryId = {
  parameterPath: "queryId",
  mapper: {
    serializedName: "query-id",
    required: true,
    type: {
      name: "String"
    }
  }
};
const body1 = {
  parameterPath: "body",
  mapper: EncodedTx
};
;// ./src/apis/node/node.ts




class node_Node extends core_client_.ServiceClient {
  /**
   * Initializes a new instance of the Node class.
   * @param $host server parameter
   * @param options The parameter options
   */
  constructor($host, options) {
    var _ref, _options$endpoint;
    if ($host === undefined) {
      throw new Error("'$host' cannot be null");
    }

    // Initializing default values for options
    if (!options) {
      options = {};
    }
    const defaults = {
      requestContentType: "application/json; charset=utf-8"
    };
    const packageDetails = `azsdk-js-node/1.0.0-beta.1`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
    const optionsWithDefaults = {
      ...defaults,
      ...options,
      userAgentOptions: {
        userAgentPrefix
      },
      endpoint: (_ref = (_options$endpoint = options.endpoint) !== null && _options$endpoint !== void 0 ? _options$endpoint : options.baseUri) !== null && _ref !== void 0 ? _ref : "{$host}"
    };
    super(optionsWithDefaults);
    // Parameter assignments
    this.$host = $host;
  }

  /**
   * Get an account by public key
   * @param pubkey The public key of the account
   * @param options The options parameters.
   */
  getAccountByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getAccountByPubkeyOperationSpec);
  }

  /**
   * Get an account by public key after the block indicated by hash. Can be either a micro block or a
   * keyblock hash
   * @param pubkey The public key of the account
   * @param hash The hash of the block - either a keyblock or a microblock
   * @param options The options parameters.
   */
  getAccountByPubkeyAndHash(pubkey, hash, options) {
    return this.sendOperationRequest({
      pubkey,
      hash,
      options
    }, getAccountByPubkeyAndHashOperationSpec);
  }

  /**
   * Get an account by public key after the opening key block of the generation at height
   * @param pubkey The public key of the account
   * @param height The height
   * @param options The options parameters.
   */
  getAccountByPubkeyAndHeight(pubkey, height, options) {
    return this.sendOperationRequest({
      pubkey,
      height,
      options
    }, getAccountByPubkeyAndHeightOperationSpec);
  }

  /**
   * Get an account's next nonce; This is computed according to whatever is the current account nonce and
   * what transactions are currently present in the transaction pool
   * @param pubkey The public key of the account
   * @param options The options parameters.
   */
  getAccountNextNonce(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getAccountNextNonceOperationSpec);
  }

  /**
   * Get pending account transactions by public key
   * @param pubkey The public key of the account
   * @param options The options parameters.
   */
  getPendingAccountTransactionsByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getPendingAccountTransactionsByPubkeyOperationSpec);
  }

  /**
   * Get auction entry from naming system
   * @param name The name key of the name entry
   * @param options The options parameters.
   */
  getAuctionEntryByName(name, options) {
    return this.sendOperationRequest({
      name,
      options
    }, getAuctionEntryByNameOperationSpec);
  }

  /**
   * Get channel by public key
   * @param pubkey The pubkey of the channel
   * @param options The options parameters.
   */
  getChannelByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getChannelByPubkeyOperationSpec);
  }

  /**
   * Get a contract by pubkey
   * @param pubkey Contract pubkey to get proof for
   * @param options The options parameters.
   */
  getContract(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getContractOperationSpec);
  }

  /**
   * Get contract code by pubkey
   * @param pubkey Contract pubkey to get proof for
   * @param options The options parameters.
   */
  getContractCode(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getContractCodeOperationSpec);
  }

  /**
   * Get a proof of inclusion for a contract
   * @param pubkey Contract pubkey to get proof for
   * @param options The options parameters.
   */
  getContractPoI(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getContractPoIOperationSpec);
  }

  /**
   * Get the currency metadata of a node
   * @param options The options parameters.
   */
  getCurrency(options) {
    return this.sendOperationRequest({
      options
    }, getCurrencyOperationSpec);
  }

  /**
   * Dry-run unsigned transactions on top of a given block. Supports all TXs except GAMetaTx, PayingForTx
   * and OffchainTx. The maximum gas limit of all calls is capped. The maximum gas limit per request is a
   * global node setting. Since DryRunCallReq object do not have a mandatory gas field, if not set a
   * default value of 1000000 is being used instead.
   * @param body transactions
   * @param options The options parameters.
   */
  protectedDryRunTxs(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, protectedDryRunTxsOperationSpec);
  }

  /**
   * Get the current generation
   * @param options The options parameters.
   */
  getCurrentGeneration(options) {
    return this.sendOperationRequest({
      options
    }, getCurrentGenerationOperationSpec);
  }

  /**
   * Get a generation by hash
   * @param hash The hash of the key block
   * @param options The options parameters.
   */
  getGenerationByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getGenerationByHashOperationSpec);
  }

  /**
   * Get a generation by height
   * @param height The height
   * @param options The options parameters.
   */
  getGenerationByHeight(height, options) {
    return this.sendOperationRequest({
      height,
      options
    }, getGenerationByHeightOperationSpec);
  }

  /**
   * Get the top header (either key or micro block)
   * @param options The options parameters.
   */
  getTopHeader(options) {
    return this.sendOperationRequest({
      options
    }, getTopHeaderOperationSpec);
  }

  /**
   * Get the pinning transaction for the current epoch. Returns both the individual parameters as well as
   * the parent chain type (aeternity, btc etc.), network id and a packaged 80 byte readymade payload for
   * that chain type.
   * @param options The options parameters.
   */
  getPinningTx(options) {
    return this.sendOperationRequest({
      options
    }, getPinningTxOperationSpec);
  }

  /**
   * Get the pubkeys for the configured hyperchain contracts for staking, election and rewards
   * @param options The options parameters.
   */
  getHyperchainContractPubkeys(options) {
    return this.sendOperationRequest({
      options
    }, getHyperchainContractPubkeysOperationSpec);
  }

  /**
   * Get the current key block
   * @param options The options parameters.
   */
  getCurrentKeyBlock(options) {
    return this.sendOperationRequest({
      options
    }, getCurrentKeyBlockOperationSpec);
  }

  /**
   * Get the hash of the current key block
   * @param options The options parameters.
   */
  getCurrentKeyBlockHash(options) {
    return this.sendOperationRequest({
      options
    }, getCurrentKeyBlockHashOperationSpec);
  }

  /**
   * Get the height of the current key block
   * @param options The options parameters.
   */
  getCurrentKeyBlockHeight(options) {
    return this.sendOperationRequest({
      options
    }, getCurrentKeyBlockHeightOperationSpec);
  }

  /**
   * Get a key block by hash
   * @param hash The hash of the block - either a keyblock or a microblock
   * @param options The options parameters.
   */
  getKeyBlockByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getKeyBlockByHashOperationSpec);
  }

  /**
   * Get a key block by height
   * @param height The height
   * @param options The options parameters.
   */
  getKeyBlockByHeight(height, options) {
    return this.sendOperationRequest({
      height,
      options
    }, getKeyBlockByHeightOperationSpec);
  }

  /**
   * Get the pending key block
   * @param options The options parameters.
   */
  getPendingKeyBlock(options) {
    return this.sendOperationRequest({
      options
    }, getPendingKeyBlockOperationSpec);
  }

  /**
   * Get a micro block header by hash
   * @param hash The hash of the block - either a keyblock or a microblock
   * @param options The options parameters.
   */
  getMicroBlockHeaderByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getMicroBlockHeaderByHashOperationSpec);
  }

  /**
   * Get micro block transactions by hash
   * @param hash The hash of the micro block
   * @param options The options parameters.
   */
  getMicroBlockTransactionsByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getMicroBlockTransactionsByHashOperationSpec);
  }

  /**
   * Get micro block transaction count by hash
   * @param hash The hash of the micro block
   * @param options The options parameters.
   */
  getMicroBlockTransactionsCountByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getMicroBlockTransactionsCountByHashOperationSpec);
  }

  /**
   * Get a micro block transaction by hash and index
   * @param hash The hash of the micro block
   * @param index The index of the transaction in a block
   * @param options The options parameters.
   */
  getMicroBlockTransactionByHashAndIndex(hash, index, options) {
    return this.sendOperationRequest({
      hash,
      index,
      options
    }, getMicroBlockTransactionByHashAndIndexOperationSpec);
  }

  /**
   * Get name entry from naming system
   * @param name The name key of the name entry
   * @param options The options parameters.
   */
  getNameEntryByName(name, options) {
    return this.sendOperationRequest({
      name,
      options
    }, getNameEntryByNameOperationSpec);
  }

  /**
   * Get name entry from naming system
   * @param nameHash The name hash of the name entry
   * @param options The options parameters.
   */
  getNameEntryByNameHash(nameHash, options) {
    return this.sendOperationRequest({
      nameHash,
      options
    }, getNameEntryByNameHashOperationSpec);
  }

  /**
   * Get an oracle by public key
   * @param pubkey The public key of the oracle
   * @param options The options parameters.
   */
  getOracleByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getOracleByPubkeyOperationSpec);
  }

  /**
   * Get oracle queries by public key
   * @param pubkey The public key of the oracle
   * @param options The options parameters.
   */
  getOracleQueriesByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getOracleQueriesByPubkeyOperationSpec);
  }

  /**
   * Get an oracle query by public key and query ID
   * @param pubkey The public key of the oracle
   * @param queryId The ID of the query
   * @param options The options parameters.
   */
  getOracleQueryByPubkeyAndQueryId(pubkey, queryId, options) {
    return this.sendOperationRequest({
      pubkey,
      queryId,
      options
    }, getOracleQueryByPubkeyAndQueryIdOperationSpec);
  }

  /**
   * Get peer public key
   * @param options The options parameters.
   */
  getPeerPubkey(options) {
    return this.sendOperationRequest({
      options
    }, getPeerPubkeyOperationSpec);
  }

  /**
   * Get minimum gas prices in recent blocks
   * @param options The options parameters.
   */
  getRecentGasPrices(options) {
    return this.sendOperationRequest({
      options
    }, getRecentGasPricesOperationSpec);
  }

  /**
   * Get the status of a node
   * @param options The options parameters.
   */
  getStatus(options) {
    return this.sendOperationRequest({
      options
    }, getStatusOperationSpec);
  }

  /**
   * Get oldest keyblock hashes counting from genesis including orphans
   * @param options The options parameters.
   */
  getChainEnds(options) {
    return this.sendOperationRequest({
      options
    }, getChainEndsOperationSpec);
  }

  /**
   * Get the sync status of a node
   * @param options The options parameters.
   */
  getSyncStatus(options) {
    return this.sendOperationRequest({
      options
    }, getSyncStatusOperationSpec);
  }

  /**
   * Post a new transaction
   * @param body The new transaction
   * @param options The options parameters.
   */
  postTransaction(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, postTransactionOperationSpec);
  }

  /**
   * Get a transaction by hash
   * @param hash The hash of the transaction
   * @param options The options parameters.
   */
  getTransactionByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getTransactionByHashOperationSpec);
  }

  /**
   * @param hash The hash of the transaction
   * @param options The options parameters.
   */
  getTransactionInfoByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getTransactionInfoByHashOperationSpec);
  }
}
// Operation Specifications
const serializer = createSerializer(mappers_namespaceObject, /* isXml */false);
const getAccountByPubkeyOperationSpec = {
  path: "/v3/accounts/{pubkey}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Account
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getAccountByPubkeyAndHashOperationSpec = {
  path: "/v3/accounts/{pubkey}/hash/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Account
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, pubkey, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getAccountByPubkeyAndHeightOperationSpec = {
  path: "/v3/accounts/{pubkey}/height/{height}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Account
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    },
    410: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, pubkey, height],
  headerParameters: [accept],
  serializer
};
const getAccountNextNonceOperationSpec = {
  path: "/v3/accounts/{pubkey}/next-nonce",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: NextNonceResponse
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [strategy],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getPendingAccountTransactionsByPubkeyOperationSpec = {
  path: "/v3/accounts/{pubkey}/transactions/pending",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: SignedTxs
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getAuctionEntryByNameOperationSpec = {
  path: "/v3/auctions/{name}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: AuctionEntry
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, parameters_name],
  headerParameters: [accept],
  serializer
};
const getChannelByPubkeyOperationSpec = {
  path: "/v3/channels/{pubkey}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Channel
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getContractOperationSpec = {
  path: "/v3/contracts/{pubkey}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ContractObject
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getContractCodeOperationSpec = {
  path: "/v3/contracts/{pubkey}/code",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ByteCode
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getContractPoIOperationSpec = {
  path: "/v3/contracts/{pubkey}/poi",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PoI
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getCurrencyOperationSpec = {
  path: "/v3/currency",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Currency
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const protectedDryRunTxsOperationSpec = {
  path: "/v3/dry-run",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: DryRunResults
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    403: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  requestBody: body,
  urlParameters: [$host],
  headerParameters: [accept, contentType],
  mediaType: "json",
  serializer
};
const getCurrentGenerationOperationSpec = {
  path: "/v3/generations/current",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Generation
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getGenerationByHashOperationSpec = {
  path: "/v3/generations/hash/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Generation
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getGenerationByHeightOperationSpec = {
  path: "/v3/generations/height/{height}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Generation
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, height],
  headerParameters: [accept],
  serializer
};
const getTopHeaderOperationSpec = {
  path: "/v3/headers/top",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Header
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getPinningTxOperationSpec = {
  path: "/v3/hyperchain/pin-tx",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PinningTx
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getHyperchainContractPubkeysOperationSpec = {
  path: "/v3/hyperchain/contracts",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: HCContractPubkeys
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getCurrentKeyBlockOperationSpec = {
  path: "/v3/key-blocks/current",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: KeyBlock
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getCurrentKeyBlockHashOperationSpec = {
  path: "/v3/key-blocks/current/hash",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: HashResponse
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getCurrentKeyBlockHeightOperationSpec = {
  path: "/v3/key-blocks/current/height",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: HeightResponse
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getKeyBlockByHashOperationSpec = {
  path: "/v3/key-blocks/hash/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: KeyBlock
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getKeyBlockByHeightOperationSpec = {
  path: "/v3/key-blocks/height/{height}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: KeyBlock
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, height],
  headerParameters: [accept],
  serializer
};
const getPendingKeyBlockOperationSpec = {
  path: "/v3/key-blocks/pending",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: KeyBlock
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getMicroBlockHeaderByHashOperationSpec = {
  path: "/v3/micro-blocks/hash/{hash}/header",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: MicroBlockHeader
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getMicroBlockTransactionsByHashOperationSpec = {
  path: "/v3/micro-blocks/hash/{hash}/transactions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: SignedTxs
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getMicroBlockTransactionsCountByHashOperationSpec = {
  path: "/v3/micro-blocks/hash/{hash}/transactions/count",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: CountResponse
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getMicroBlockTransactionByHashAndIndexOperationSpec = {
  path: "/v3/micro-blocks/hash/{hash}/transactions/index/{index}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: SignedTx
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, parameters_hash, index],
  headerParameters: [accept],
  serializer
};
const getNameEntryByNameOperationSpec = {
  path: "/v3/names/{name}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: NameEntry
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, parameters_name],
  headerParameters: [accept],
  serializer
};
const getNameEntryByNameHashOperationSpec = {
  path: "/v3/names/hash/{name_hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: NameEntry
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, nameHash],
  headerParameters: [accept],
  serializer
};
const getOracleByPubkeyOperationSpec = {
  path: "/v3/oracles/{pubkey}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: RegisteredOracle
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getOracleQueriesByPubkeyOperationSpec = {
  path: "/v3/oracles/{pubkey}/queries",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: OracleQueries
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [fromParam, limit, typeParam],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getOracleQueryByPubkeyAndQueryIdOperationSpec = {
  path: "/v3/oracles/{pubkey}/queries/{query-id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: OracleQuery
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, pubkey, queryId],
  headerParameters: [accept],
  serializer
};
const getPeerPubkeyOperationSpec = {
  path: "/v3/peers/pubkey",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PeerPubKey
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getRecentGasPricesOperationSpec = {
  path: "/v3/recent-gas-prices",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "GasPricesItem"
            }
          }
        }
      }
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getStatusOperationSpec = {
  path: "/v3/status",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Status
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getChainEndsOperationSpec = {
  path: "/v3/status/chain-ends",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getSyncStatusOperationSpec = {
  path: "/v3/sync-status",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: SyncStatus
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const postTransactionOperationSpec = {
  path: "/v3/transactions",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: PostTxResponse
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  requestBody: body1,
  urlParameters: [$host],
  headerParameters: [accept, contentType],
  mediaType: "json",
  serializer
};
const getTransactionByHashOperationSpec = {
  path: "/v3/transactions/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: SignedTx
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getTransactionInfoByHashOperationSpec = {
  path: "/v3/transactions/{hash}/info",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: TxInfoObject
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    },
    410: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
;// ./src/Node.ts
function Node_classPrivateFieldInitSpec(e, t, a) { Node_checkPrivateRedeclaration(e, t), t.set(e, a); }
function Node_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function Node_classPrivateFieldGet(s, a) { return s.get(Node_assertClassBrand(s, a)); }
function Node_classPrivateFieldSet(s, a, r) { return s.set(Node_assertClassBrand(s, a), r), r; }
function Node_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
// eslint-disable-next-line max-classes-per-file






var _ignoreVersion = /*#__PURE__*/new WeakMap();
var _cachedStatusPromise = /*#__PURE__*/new WeakMap();
var _isHyperchainPromise = /*#__PURE__*/new WeakMap();
/**
 * @category chain
 */
class Node extends node_Node {
  /**
   * @param url - Url for node API
   * @param options - Options
   * @param options.ignoreVersion - Print warning instead of throwing exception if node
   * or consensus protocol version is not supported, use with caution
   * @param options.retryCount - Amount of extra requests to do in case of failure
   * @param options.retryOverallDelay - Time in ms to wait between all retries
   */
  constructor(url, {
    ignoreVersion = false,
    retryCount = 3,
    retryOverallDelay = 800,
    ...options
  } = {}) {
    const getVersion = async opts => (await this._getCachedStatus(opts)).nodeVersion;
    // eslint-disable-next-line constructor-super
    super(url, {
      allowInsecureConnection: true,
      additionalPolicies: [genVersionCheckPolicy('node', getVersion, '7.1.0', '8.0.0', ignoreVersion), genRequestQueuesPolicy(), genCombineGetRequestsPolicy(), genRetryOnFailurePolicy(retryCount, retryOverallDelay), genErrorFormatterPolicy(body => [' ', body.reason, body.errorCode == null ? '' : ` (${body.errorCode})`].join(''))],
      ...options
    });
    Node_classPrivateFieldInitSpec(this, _ignoreVersion, void 0);
    Node_classPrivateFieldInitSpec(this, _cachedStatusPromise, void 0);
    Node_classPrivateFieldInitSpec(this, _isHyperchainPromise, void 0);
    Node_classPrivateFieldSet(_ignoreVersion, this, ignoreVersion);
    this.pipeline.addPolicy(parseBigIntPolicy, {
      phase: 'Deserialize'
    });
    this.pipeline.removePolicy({
      name: core_rest_pipeline_.userAgentPolicyName
    });
    this.pipeline.removePolicy({
      name: core_rest_pipeline_.setClientRequestIdPolicyName
    });
    // TODO: use instead our retry policy
    this.pipeline.removePolicy({
      name: 'defaultRetryPolicy'
    });
  }
  async _getCachedStatus(options) {
    if (Node_classPrivateFieldGet(_cachedStatusPromise, this) != null) return Node_classPrivateFieldGet(_cachedStatusPromise, this);
    return this.getStatus(options);
  }
  async getStatus(...args) {
    const promise = super.getStatus(...args);
    promise.then(() => {
      Node_classPrivateFieldSet(_cachedStatusPromise, this, promise);
    }, () => {});
    return promise;
  }
  async _isHyperchain() {
    if (Node_classPrivateFieldGet(_isHyperchainPromise, this) != null) return Node_classPrivateFieldGet(_isHyperchainPromise, this);
    Node_classPrivateFieldSet(_isHyperchainPromise, this, this.getHyperchainContractPubkeys({
      requestOptions: {
        customHeaders: {
          '__no-retry': 'true'
        }
      }
    }).then(() => true, error => {
      if (error.message !== 'v3/hyperchain/contracts error: 404 status code') throw error;
      return false;
    }));
    return Node_classPrivateFieldGet(_isHyperchainPromise, this);
  }

  /**
   * Returns network ID provided by node.
   * This method won't do extra requests on subsequent calls.
   */
  async getNetworkId() {
    return (await this._getCachedStatus()).networkId;
  }
  async getNodeInfo() {
    const {
      nodeVersion,
      networkId: nodeNetworkId,
      protocols,
      topBlockHeight
    } = await this.getStatus();
    const consensusProtocolVersion = protocols.filter(({
      effectiveAtHeight
    }) => topBlockHeight >= effectiveAtHeight).reduce((acc, p) => p.effectiveAtHeight > acc.effectiveAtHeight ? p : acc, {
      effectiveAtHeight: -1,
      version: 0
    }).version;
    if (ConsensusProtocolVersion[consensusProtocolVersion] == null) {
      const version = consensusProtocolVersion.toString();
      const versions = Object.values(ConsensusProtocolVersion).filter(el => typeof el === 'number').map(el => +el);
      const geVersion = Math.min(...versions).toString();
      const ltVersion = (Math.max(...versions) + 1).toString();
      const error = new UnsupportedVersionError('consensus protocol', version, geVersion, ltVersion);
      if (Node_classPrivateFieldGet(_ignoreVersion, this)) console.warn(error.message);else throw error;
    }
    return {
      url: this.$host,
      nodeNetworkId,
      version: nodeVersion,
      consensusProtocolVersion
    };
  }
}
;// ./src/tx/transaction-signer.ts




/**
 * Returns account address that signed a transaction
 * @param transaction - transaction to get a signer of
 * @category utils
 */
function getTransactionSignerAddress(transaction) {
  const params = unpackTx(transaction);
  switch (params.tag) {
    case Tag.SignedTx:
      return getTransactionSignerAddress(buildTx(params.encodedTx));
    case Tag.GaMetaTx:
      return params.gaId;
    default:
  }
  const nonce = builder_getSchema(params.tag, params.version).find(([name]) => name === 'nonce')?.[1];
  if (nonce == null) throw new TransactionError(`Transaction doesn't have nonce: ${Tag[params.tag]}`);
  if (!('senderKey' in nonce)) throw new UnexpectedTsError();
  const address = params[nonce.senderKey];
  return address.replace(/^ok_/, 'ak_');
}
;// ./src/account/Base.ts
/**
 * Account is one of the three basic building blocks of an
 * {@link AeSdk} and provides access to a signing key pair.
 * @category account
 */
class AccountBase {}
// EXTERNAL MODULE: external "@aeternity/aepp-calldata"
var aepp_calldata_ = __webpack_require__(2853);
// EXTERNAL MODULE: external "canonicalize"
var external_canonicalize_ = __webpack_require__(6016);
var external_canonicalize_default = /*#__PURE__*/__webpack_require__.n(external_canonicalize_);
;// ./src/utils/typed-data.ts






/**
 * Hashes arbitrary object, can be used to inline the aci hash to contract source code
 * @category typed data signing
 */
function hashJson(data) {
  var _canonicalize;
  return hash((_canonicalize = external_canonicalize_default()(data)) !== null && _canonicalize !== void 0 ? _canonicalize : '');
}

// TODO: move this type to calldata library https://github.com/aeternity/aepp-calldata-js/issues/215
// based on https://github.com/aeternity/aepp-calldata-js/blob/82b5a98f9b308482627da8d7484d213e9cf87151/src/AciTypeResolver.js#L129

/**
 * Hashes domain object, can be used to inline domain hash to contract source code
 * @category typed data signing
 */
function hashDomain(domain) {
  const domainAci = {
    record: [{
      name: 'name',
      type: {
        option: ['string']
      }
    }, {
      name: 'version',
      type: {
        option: ['int']
      }
    }, {
      name: 'networkId',
      type: {
        option: ['string']
      }
    }, {
      name: 'contractAddress',
      type: {
        option: ['contract_pubkey']
      }
    }]
  };
  const domainType = new aepp_calldata_.TypeResolver().resolveType(domainAci, {});
  const fateValue = new aepp_calldata_.ContractByteArrayEncoder().encodeWithType(domain, domainType);
  return hash(decode(fateValue));
}

/**
 * @category typed data signing
 */
function hashTypedData(data, aci, domain) {
  return hash(concatBuffers([messagePrefixLength, new Uint8Array([0]), hashDomain(domain), hashJson(aci), hash(decode(data))]));
}
;// ./src/account/Memory.ts
function Memory_classPrivateFieldInitSpec(e, t, a) { Memory_checkPrivateRedeclaration(e, t), t.set(e, a); }
function Memory_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function Memory_classPrivateFieldGet(s, a) { return s.get(Memory_assertClassBrand(s, a)); }
function Memory_classPrivateFieldSet(s, a, r) { return s.set(Memory_assertClassBrand(s, a), r), r; }
function Memory_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }









function getBufferToSign(transaction, networkId, innerTx) {
  const prefixes = [networkId];
  if (innerTx) prefixes.push('inner_tx');
  const rlpBinaryTx = decode(transaction);
  return concatBuffers([Buffer.from(prefixes.join('-')), hash(rlpBinaryTx)]);
}

/**
 * In-memory account class
 * @category account
 */
var _secretKeyDecoded = /*#__PURE__*/new WeakMap();
class AccountMemory extends AccountBase {
  /**
   * @param secretKey - Secret key
   */
  constructor(secretKey) {
    super();
    Memory_classPrivateFieldInitSpec(this, _secretKeyDecoded, void 0);
    this.secretKey = secretKey;
    const keyPair = external_tweetnacl_default().sign.keyPair.fromSeed(decode(secretKey));
    Memory_classPrivateFieldSet(_secretKeyDecoded, this, keyPair.secretKey);
    this.address = encode(keyPair.publicKey, Encoding.AccountAddress);
  }

  /**
   * Generates a new AccountMemory using a random secret key
   */
  static generate() {
    const secretKey = encode(external_tweetnacl_default().randomBytes(32), Encoding.AccountSecretKey);
    return new AccountMemory(secretKey);
  }

  /**
   * @deprecated Use `unsafeSign` method instead
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async sign(data, options) {
    return this.unsafeSign(data, options);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async unsafeSign(data, options) {
    return external_tweetnacl_default().sign.detached(Buffer.from(data), Memory_classPrivateFieldGet(_secretKeyDecoded, this));
  }
  async signTransaction(transaction, {
    innerTx,
    networkId,
    ...options
  } = {}) {
    if (networkId == null) {
      throw new ArgumentError('networkId', 'provided', networkId);
    }
    const rlpBinaryTx = decode(transaction);
    const txWithNetworkId = getBufferToSign(transaction, networkId, innerTx === true);
    const signatures = [await this.unsafeSign(txWithNetworkId, options)];
    return buildTx({
      tag: Tag.SignedTx,
      encodedTx: rlpBinaryTx,
      signatures
    });
  }
  async signMessage(message, options) {
    return this.unsafeSign(hashMessage(message), options);
  }
  async signTypedData(data, aci, {
    name,
    version,
    networkId,
    contractAddress,
    ...options
  } = {}) {
    const dHash = hashTypedData(data, aci, {
      name,
      version,
      networkId,
      contractAddress
    });
    const signature = await this.unsafeSign(dHash, options);
    return encode(signature, Encoding.Signature);
  }
  async signDelegation(delegation, {
    networkId
  } = {}) {
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    const payload = concatBuffers([messagePrefixLength, new Uint8Array([1]), Buffer.from(networkId), decode(delegation)]);
    const signature = await this.unsafeSign(payload);
    return encode(signature, Encoding.Signature);
  }
}
;// ./src/tx/execution-cost.ts







/**
 * Calculates the cost of transaction execution
 * Provides an upper cost of contract-call-related transactions because of `gasLimit`.
 * Also assumes that oracle query fee is 0 unless it is provided in options.
 *
 * The idea is that if you need to show transaction details with some accuracy you can define
 * expense fields that you want to show separately. And to show `getExecutionCost` result as a fee,
 * subtracting all fields shown separately.
 *
 * @example
 * ```vue
 * <template>
 * Amount: {{ txUnpacked.amount }}
 * Name fee: {{ txUnpacked.nameFee }}
 * Other fees: {{ getExecutionCost(txEncoded) - txUnpacked.amount - txUnpacked.nameFee }}
 * </template>
 * ```
 *
 * Doing this way you won't worry to show wrong fee for a transaction you may not support. Because
 * the SDK calculates the overall price of any transaction on its side.
 *
 * @param transaction - Transaction to calculate the cost of
 * @param options - Options
 * @param options.innerTx - Should be provided if transaction wrapped with Tag.PayingForTx
 * @param options.gasUsed - Amount of gas actually used to make calculation more accurate
 * @param options.queryFee - Oracle query fee
 * @param options.isInitiator - Is transaction signer an initiator of state channel
 * @category utils
 */
function getExecutionCost(transaction, {
  innerTx,
  gasUsed,
  queryFee,
  isInitiator
} = {}) {
  const params = unpackTx(transaction);
  if (params.tag === Tag.SignedTx) {
    throw new IllegalArgumentError("Transaction shouldn't be a SignedTx, use `getExecutionCostBySignedTx` instead");
  }
  let res = 0n;
  if ('fee' in params && innerTx !== 'freeloader') {
    res += BigInt(params.fee);
  }
  if (params.tag === Tag.NameClaimTx) {
    res += BigInt(params.nameFee);
  }
  if (params.tag === Tag.OracleQueryTx) {
    res += BigInt(params.queryFee);
  }
  if (params.tag === Tag.OracleRespondTx) {
    res -= BigInt(queryFee !== null && queryFee !== void 0 ? queryFee : 0);
  }
  if (params.tag === Tag.ChannelSettleTx) {
    if (isInitiator === true) res -= BigInt(params.initiatorAmountFinal);
    if (isInitiator === false) res -= BigInt(params.responderAmountFinal);
  }
  if ((params.tag === Tag.SpendTx || params.tag === Tag.ContractCreateTx || params.tag === Tag.ContractCallTx || params.tag === Tag.ChannelDepositTx) && innerTx !== 'fee-payer') {
    res += BigInt(params.amount);
  }
  if (params.tag === Tag.ContractCreateTx) res += BigInt(params.deposit);
  if ((params.tag === Tag.ContractCreateTx || params.tag === Tag.ContractCallTx || params.tag === Tag.GaAttachTx || params.tag === Tag.GaMetaTx) && innerTx !== 'freeloader') {
    res += BigInt(params.gasPrice) * BigInt(gasUsed !== null && gasUsed !== void 0 ? gasUsed : params.gasLimit);
  }
  if (params.tag === Tag.GaMetaTx || params.tag === Tag.PayingForTx) {
    res += getExecutionCost(buildTx(params.tx.encodedTx), params.tag === Tag.PayingForTx ? {
      innerTx: 'fee-payer'
    } : {});
  }
  return res;
}

/**
 * Calculates the cost of signed transaction execution
 * @param transaction - Transaction to calculate the cost of
 * @param networkId - Network id used to sign the transaction
 * @param options - Options
 * @category utils
 */
function getExecutionCostBySignedTx(transaction, networkId, options) {
  const params = unpackTx(transaction, Tag.SignedTx);
  if (params.encodedTx.tag === Tag.GaMetaTx) {
    return getExecutionCost(buildTx(params.encodedTx), options);
  }
  const tx = buildTx(params.encodedTx);
  const address = getTransactionSignerAddress(tx);
  const [isInnerTx, isNotInnerTx] = [true, false].map(f => verifySignature(getBufferToSign(tx, networkId, f), params.signatures[0], address));
  if (!isInnerTx && !isNotInnerTx) throw new TransactionError("Can't verify signature");
  return getExecutionCost(buildTx(params.encodedTx), {
    ...(isInnerTx && {
      innerTx: 'freeloader'
    }),
    ...options
  });
}

/**
 * Calculates the cost of signed and not signed transaction execution using node
 * @param transaction - Transaction to calculate the cost of
 * @param node - Node to use
 * @param options - Options
 * @param options.isMined - Is transaction already mined or not
 * @category utils
 */
async function getExecutionCostUsingNode(transaction, node, {
  isMined,
  ...options
} = {}) {
  let params = unpackTx(transaction);
  const isSignedTx = params.tag === Tag.SignedTx;
  const txHash = isSignedTx && isMined === true && buildTxHash(transaction);
  if (params.tag === Tag.SignedTx) params = params.encodedTx;

  // TODO: set gasUsed for PayingForTx after solving https://github.com/aeternity/aeternity/issues/4087
  if (options.gasUsed == null && txHash !== false && [Tag.ContractCreateTx, Tag.ContractCallTx, Tag.GaAttachTx, Tag.GaMetaTx].includes(params.tag)) {
    const {
      callInfo,
      gaInfo
    } = await node.getTransactionInfoByHash(txHash);
    const combinedInfo = callInfo !== null && callInfo !== void 0 ? callInfo : gaInfo;
    if (combinedInfo == null) {
      throw new InternalError(`callInfo and gaInfo is not available for transaction ${txHash}`);
    }
    options.gasUsed = combinedInfo.gasUsed;
  }
  if (options.queryFee == null && Tag.OracleRespondTx === params.tag) {
    options.queryFee = (await node.getOracleByPubkey(params.oracleId)).queryFee.toString();
  }
  if (options.isInitiator == null && Tag.ChannelSettleTx === params.tag && isMined !== true) {
    const {
      initiatorId
    } = await node.getChannelByPubkey(params.channelId);
    options.isInitiator = params.fromId === initiatorId;
  }
  return isSignedTx ? getExecutionCostBySignedTx(transaction, await node.getNetworkId(), options) : getExecutionCost(transaction, options);
}
;// ./src/tx/validator.ts












const validators = [];
async function verifyTransactionInternal(tx, node, parentTxTypes) {
  const address = getTransactionSignerAddress(buildTx(tx));
  const [account, {
    height
  }, {
    consensusProtocolVersion,
    nodeNetworkId
  }] = await Promise.all([node.getAccountByPubkey(address).catch(error => {
    if (!isAccountNotFoundError(error)) throw error;
    return {
      id: address,
      balance: 0n,
      nonce: 0
    };
  })
  // TODO: remove after fixing https://github.com/aeternity/aepp-sdk-js/issues/1537
  .then(acc => ({
    ...acc,
    id: acc.id
  })), node.getCurrentKeyBlockHeight(),
  // TODO: don't request height on each validation, use caching
  node.getNodeInfo()]);
  return (await Promise.all(validators.map(async v => v(tx, {
    node,
    account,
    height,
    consensusProtocolVersion,
    nodeNetworkId,
    parentTxTypes
  })))).flat();
}

/**
 * Transaction Validator
 * This function validates some transaction properties,
 * to make sure it can be posted it to the chain
 * @category transaction builder
 * @param transaction - Base64Check-encoded transaction
 * @param nodeNotCached - Node to validate transaction against
 * @returns Array with verification errors
 * @example const errors = await verifyTransaction(transaction, node)
 */
async function verifyTransaction(transaction, nodeNotCached) {
  const pipeline = nodeNotCached.pipeline.clone();
  pipeline.removePolicy({
    name: 'parse-big-int'
  });
  const node = new Node(nodeNotCached.$host, {
    ignoreVersion: true,
    pipeline,
    additionalPolicies: [genAggressiveCacheGetResponsesPolicy()]
  });
  node._getCachedStatus = async () => nodeNotCached._getCachedStatus();
  return verifyTransactionInternal(unpackTx(transaction), node, []);
}
validators.push((tx, {
  account,
  nodeNetworkId,
  parentTxTypes
}) => {
  if (tx.tag !== Tag.SignedTx) return [];
  const {
    encodedTx,
    signatures
  } = tx;
  if ((encodedTx !== null && encodedTx !== void 0 ? encodedTx : signatures) == null) return [];
  if (signatures.length !== 1) return []; // TODO: Support multisignature like in state channels
  const prefix = Buffer.from([nodeNetworkId, ...(parentTxTypes.includes(Tag.PayingForTx) ? ['inner_tx'] : [])].join('-'));
  const txBinary = decode(buildTx(encodedTx));
  const txWithNetworkId = concatBuffers([prefix, txBinary]);
  const txHashWithNetworkId = concatBuffers([prefix, hash(txBinary)]);
  if (verifySignature(txWithNetworkId, signatures[0], account.id) || verifySignature(txHashWithNetworkId, signatures[0], account.id)) return [];
  return [{
    message: 'Signature cannot be verified, please ensure that you transaction have' + ' the correct prefix and the correct private key for the sender address',
    key: 'InvalidSignature',
    checkedKeys: ['encodedTx', 'signatures']
  }];
}, async (tx, {
  node,
  parentTxTypes
}) => {
  let nestedTx;
  if ('encodedTx' in tx) nestedTx = tx.encodedTx;
  if ('tx' in tx) nestedTx = tx.tx;
  if (nestedTx == null) return [];
  return verifyTransactionInternal(nestedTx, node, [...parentTxTypes, tx.tag]);
}, (tx, {
  height
}) => {
  if (!('ttl' in tx)) return [];
  if (tx.ttl === 0 || tx.ttl > height) return [];
  return [{
    message: `TTL ${tx.ttl} is already expired, current height is ${height}`,
    key: 'ExpiredTTL',
    checkedKeys: ['ttl']
  }];
}, async (tx, {
  account,
  parentTxTypes,
  node
}) => {
  if (parentTxTypes.length !== 0) return [];
  const cost = await getExecutionCostUsingNode(buildTx(tx), node).catch(() => 0n);
  if (cost <= account.balance) return [];
  return [{
    message: `Account balance ${account.balance} is not enough to execute the transaction that costs ${cost}`,
    key: 'InsufficientBalance',
    checkedKeys: ['amount', 'fee', 'nameFee', 'gasLimit', 'gasPrice']
  }];
}, async (tx, {
  node
}) => {
  if (tx.tag !== Tag.SpendTx || isEncoded(tx.recipientId, Encoding.Name)) return [];
  const recipient = await node.getAccountByPubkey(tx.recipientId).catch(error => {
    if (!isAccountNotFoundError(error)) throw error;
    return null;
  });
  if (recipient == null || recipient.payable === true) return [];
  return [{
    message: 'Recipient account is not payable',
    key: 'RecipientAccountNotPayable',
    checkedKeys: ['recipientId']
  }];
}, (tx, {
  account
}) => {
  let message;
  if (tx.tag === Tag.SignedTx && account.kind === 'generalized' && tx.signatures.length !== 0) {
    message = "Generalized account can't be used to generate SignedTx with signatures";
  }
  if (tx.tag === Tag.GaMetaTx && account.kind === 'basic') {
    message = "Basic account can't be used to generate GaMetaTx";
  }
  if (message == null) return [];
  return [{
    message,
    key: 'InvalidAccountType',
    checkedKeys: ['tag']
  }];
},
// TODO: revert nonce check
// TODO: ensure nonce valid when paying for own tx
(tx, {
  consensusProtocolVersion
}) => {
  var _ref, _ref2;
  const oracleCall = Tag.OracleRegisterTx === tx.tag;
  const contractCreate = Tag.ContractCreateTx === tx.tag || Tag.GaAttachTx === tx.tag;
  const contractCall = Tag.ContractCallTx === tx.tag || Tag.GaMetaTx === tx.tag;
  const type = (_ref = (_ref2 = oracleCall ? 'oracle-call' : null) !== null && _ref2 !== void 0 ? _ref2 : contractCreate ? 'contract-create' : null) !== null && _ref !== void 0 ? _ref : contractCall ? 'contract-call' : null;
  if (type == null) return [];
  const protocol = ProtocolToVmAbi[consensusProtocolVersion][type];
  let ctVersion;
  if ('abiVersion' in tx) ctVersion = {
    abiVersion: tx.abiVersion
  };
  if ('ctVersion' in tx) ctVersion = tx.ctVersion;
  if (ctVersion == null) throw new UnexpectedTsError();
  if (!protocol.abiVersion.includes(ctVersion.abiVersion) || contractCreate && !protocol.vmVersion.includes(ctVersion.vmVersion)) {
    return [{
      message: `ABI/VM version ${JSON.stringify(ctVersion)} is wrong, supported is: ${JSON.stringify(protocol)}`,
      key: 'VmAndAbiVersionMismatch',
      checkedKeys: ['ctVersion', 'abiVersion']
    }];
  }
  return [];
}, async (tx, {
  node
}) => {
  if (Tag.ContractCallTx !== tx.tag) return [];
  // TODO: remove after solving https://github.com/aeternity/aeternity/issues/3669
  if (tx.contractId.startsWith('nm_')) return [];
  try {
    const {
      active
    } = await node.getContract(tx.contractId);
    if (active) return [];
    return [{
      message: `Contract ${tx.contractId} is not active`,
      key: 'ContractNotActive',
      checkedKeys: ['contractId']
    }];
  } catch (error) {
    if (!(error instanceof core_rest_pipeline_.RestError) || error.response?.bodyAsText == null) throw error;
    return [{
      message: JSON.parse(error.response.bodyAsText).reason,
      // TODO: use parsedBody instead
      key: 'ContractNotFound',
      checkedKeys: ['contractId']
    }];
  }
});
;// ./src/send-transaction.ts






/**
 * @category exception
 */
class InvalidTxError extends TransactionError {
  constructor(message, validation, transaction) {
    super(message);
    this.name = 'InvalidTxError';
    this.validation = validation;
    this.transaction = transaction;
  }
}

/**
 * Signs and submits transaction for mining
 * @category chain
 * @param txUnsigned - Transaction to sign and submit
 * @param options - Options
 * @returns Transaction details
 */
async function sendTransaction(txUnsigned, {
  onNode,
  onAccount,
  verify = true,
  waitMined = true,
  confirm,
  innerTx,
  ...options
}) {
  const tx = await onAccount.signTransaction(txUnsigned, {
    ...options,
    onNode,
    innerTx,
    networkId: await onNode.getNetworkId()
  });
  if (innerTx === true) return {
    hash: buildTxHash(tx),
    rawTx: tx
  };
  if (verify) {
    const validation = await verifyTransaction(tx, onNode);
    if (validation.length > 0) {
      const message = `Transaction verification errors: ${validation.map(v => v.message).join(', ')}`;
      throw new InvalidTxError(message, validation, tx);
    }
  }
  try {
    let __queue;
    try {
      __queue = onAccount != null ? `tx-${onAccount.address}` : null;
    } catch (error) {
      __queue = null;
    }
    const {
      txHash
    } = await onNode.postTransaction({
      tx
    }, {
      requestOptions: {
        customHeaders: {
          // TODO: remove __retry-code after fixing https://github.com/aeternity/aeternity/issues/3803
          '__retry-code': '400',
          ...(__queue != null ? {
            __queue
          } : {})
        }
      }
    });
    if (waitMined) {
      const pollResult = await poll(txHash, {
        onNode,
        ...options
      });
      const txData = {
        ...pollResult,
        hash: pollResult.hash,
        rawTx: tx
      };
      // wait for transaction confirmation
      if (confirm != null && +confirm > 0) {
        const c = typeof confirm === 'boolean' ? undefined : confirm;
        return {
          ...txData,
          confirmationHeight: await waitForTxConfirm(txHash, {
            onNode,
            confirm: c,
            ...options
          })
        };
      }
      return txData;
    }
    return {
      hash: txHash,
      rawTx: tx
    };
  } catch (error) {
    ensureError(error);
    throw Object.assign(error, {
      rawTx: tx,
      verifyTx: async () => verifyTransaction(tx, onNode)
    });
  }
}
;// ./src/utils/jwt.ts





// TODO: use Buffer.from(data, 'base64url') after solving https://github.com/feross/buffer/issues/309
const toBase64Url = data => Buffer.from(data).toString('base64').replaceAll('/', '_').replaceAll('+', '-').replace(/=+$/, '');
const fromBase64Url = data => Buffer.from(data.replaceAll('_', '/').replaceAll('-', '+'), 'base64');
const objectToBase64Url = data => {
  var _canonicalize;
  return toBase64Url((_canonicalize = external_canonicalize_default()(data)) !== null && _canonicalize !== void 0 ? _canonicalize : '');
};
const header = 'eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9'; // objectToBase64Url({ alg: 'EdDSA', typ: 'JWT' })

/**
 * JWT including specific header
 * @category JWT
 */

/**
 * Generate a signed JWT
 * Provide `"sub_jwk": undefined` in payload to omit signer public key added by default.
 * @param originalPayload - Payload to sign
 * @param account - Account to sign by
 * @category JWT
 */
async function signJwt(originalPayload, account) {
  const payload = {
    ...originalPayload
  };
  if (!('sub_jwk' in payload)) {
    payload.sub_jwk = {
      kty: 'OKP',
      crv: 'Ed25519',
      x: toBase64Url(decode(account.address))
    };
  }
  if (payload.sub_jwk === undefined) delete payload.sub_jwk;
  const body = `${header}.${objectToBase64Url(payload)}`;
  const signature = await account.unsafeSign(body);
  return `${body}.${toBase64Url(signature)}`;
}

/**
 * Unpack JWT. It will check signature if address or "sub_jwk" provided.
 * @param jwt - JWT to unpack
 * @param address - Address to check signature
 * @category JWT
 */
function unpackJwt(jwt, address) {
  var _payload$sub_jwk;
  const components = jwt.split('.');
  if (components.length !== 3) throw new ArgumentError('JWT components count', 3, components.length);
  const [h, payloadEncoded, signature] = components;
  if (h !== header) throw new ArgumentError('JWT header', header, h);
  const payload = JSON.parse(fromBase64Url(payloadEncoded).toString());
  const jwk = (_payload$sub_jwk = payload.sub_jwk) !== null && _payload$sub_jwk !== void 0 ? _payload$sub_jwk : {};
  const signer = jwk.x == null || jwk.kty !== 'OKP' || jwk.crv !== 'Ed25519' ? address : encode(fromBase64Url(jwk.x), Encoding.AccountAddress);
  if (address != null && signer !== address) {
    throw new ArgumentError('address', `${signer} ("sub_jwk")`, address);
  }
  if (signer != null && !verifySignature(Buffer.from(`${h}.${payloadEncoded}`), fromBase64Url(signature), signer)) {
    throw new InvalidSignatureError(`JWT is not signed by ${signer}`);
  }
  return {
    payload,
    signer
  };
}

/**
 * Check is string a JWT or not. Use to validate the user input.
 * @param maybeJwt - A string to check
 * @returns True if argument is a JWT
 * @category JWT
 */
function isJwt(maybeJwt) {
  try {
    unpackJwt(maybeJwt);
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Throws an error if argument is not JWT. Use to ensure that a value is JWT.
 * @param maybeJwt - A string to check
 * @category JWT
 */
function ensureJwt(maybeJwt) {
  unpackJwt(maybeJwt);
}

/**
 * Check is JWT signed by address from arguments or "sub_jwk"
 * @param jwt - JWT to check
 * @param address - Address to check signature
 * @category JWT
 */
function verifyJwt(jwt, address) {
  try {
    const {
      signer
    } = unpackJwt(jwt, address);
    return signer != null;
  } catch (error) {
    return false;
  }
}
;// ./src/tx/builder/delegation/schema.ts





/**
 * @category delegation signature
 */
let DelegationTag = /*#__PURE__*/function (DelegationTag) {
  /**
   * Delegation of all AENS names to a contract
   */
  DelegationTag[DelegationTag["AensWildcard"] = 1] = "AensWildcard";
  /**
   * Delegation of an AENS name to a contract
   */
  DelegationTag[DelegationTag["AensName"] = 2] = "AensName";
  /**
   * Delegation of AENS preclaim to a contract
   */
  DelegationTag[DelegationTag["AensPreclaim"] = 3] = "AensPreclaim";
  /**
   * Delegation of oracle operations to a contract
   */
  DelegationTag[DelegationTag["Oracle"] = 4] = "Oracle";
  /**
   * Delegation of oracle query to a contract
   */
  DelegationTag[DelegationTag["OracleResponse"] = 5] = "OracleResponse";
  return DelegationTag;
}({});
const oracleAddressField = genAddressField(Encoding.OracleAddress);
/**
 * Oracle query ID to reply by a contract
 */
const queryIdField = {
  serialize(value) {
    return oracleAddressField.serialize(encode(decode(value), Encoding.OracleAddress));
  },
  deserialize(value) {
    return encode(decode(oracleAddressField.deserialize(value)), Encoding.OracleQueryId);
  }
};

/**
 * Address of a contract to delegate permissions to
 */
const contractAddress = genAddressField(Encoding.ContractAddress);

/**
 * @see {@link https://github.com/aeternity/protocol/blob/8a9d1d1206174627f6aaef86159dc9c643080653/contracts/fate.md#from-ceres-serialized-signature-data}
 */
const schema_schemas = [{
  tag: genShortUIntConstField(DelegationTag.AensWildcard),
  version: genShortUIntConstField(1, true),
  accountAddress: genAddressField(Encoding.AccountAddress),
  contractAddress
}, {
  tag: genShortUIntConstField(DelegationTag.AensName),
  version: genShortUIntConstField(1, true),
  accountAddress: genAddressField(Encoding.AccountAddress),
  /**
   * AENS name to manage by a contract
   */
  nameId: name_id,
  contractAddress
}, {
  tag: genShortUIntConstField(DelegationTag.AensPreclaim),
  version: genShortUIntConstField(1, true),
  accountAddress: genAddressField(Encoding.AccountAddress),
  contractAddress
}, {
  tag: genShortUIntConstField(DelegationTag.Oracle),
  version: genShortUIntConstField(1, true),
  accountAddress: genAddressField(Encoding.AccountAddress),
  contractAddress
}, {
  tag: genShortUIntConstField(DelegationTag.OracleResponse),
  version: genShortUIntConstField(1, true),
  queryId: queryIdField,
  contractAddress
}];
;// ./src/tx/builder/delegation/index.ts



/**
 * Pack delegation
 * @category delegation signature
 * @param params - Params of delegation
 * @returns Encoded delegation
 */
function packDelegation(params) {
  return packRecord(schema_schemas, DelegationTag, params, {}, Encoding.Bytearray);
}

/**
 * Unpack delegation
 * @category delegation signature
 * @param encoded - Encoded delegation
 * @param expectedTag - Expected delegation signature type
 * @returns Params of delegation
 */
function unpackDelegation(encoded, expectedTag) {
  return unpackRecord(schema_schemas, DelegationTag, encoded, expectedTag, {});
}
;// ./src/aens.ts
function aens_classPrivateFieldInitSpec(e, t, a) { aens_checkPrivateRedeclaration(e, t), t.set(e, a); }
function aens_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function aens_classPrivateFieldSet(s, a, r) { return s.set(aens_assertClassBrand(s, a), r), r; }
function aens_classPrivateFieldGet(s, a) { return s.get(aens_assertClassBrand(s, a)); }
function aens_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Aens methods - routines to interact with the ternity naming system
 *
 * The high-level description of the naming system is
 * https://github.com/aeternity/protocol/blob/master/AENS.md in the protocol
 * repository.
 */








class NotAuctionNameError extends LogicError {
  constructor(name, action) {
    super(`Can't ${action} because ${name} is not an auction name`);
    this.name = 'NotAuctionNameError';
  }
}

/**
 * @category AENS
 * @example
 * ```js
 * const name = new Name('test.chain', aeSdk.getContext())
 * ```
 */
var _salt = /*#__PURE__*/new WeakMap();
class Name {
  /**
   * @param value - AENS name
   * @param options - Options
   * @param options.onNode - Node to use
   * @param options.onAccount - Account to use
   */
  constructor(value, options) {
    aens_classPrivateFieldInitSpec(this, _salt, void 0);
    this.value = value;
    this.options = options;
    this.options = options;
  }

  /**
   * Name ID encoded as nm_-prefixed string
   */
  get id() {
    return produceNameId(this.value);
  }

  /**
   * Revoke a name
   * @param options - Options
   * @returns mined transaction details
   * @example
   * ```js
   * await name.revoke({ fee, ttl, nonce })
   * ```
   */
  async revoke(options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.NameRevokeTx,
      nameId: this.value,
      accountId: opt.onAccount.address
    });
    return sendTransaction(tx, opt);
  }

  /**
   * Update a name
   * @param pointers - Map of pointer keys to corresponding addresses
   * @param options - Options
   * @example
   * ```js
   * const name = 'test.chain'
   * const channel = 'ch_2519mBs...'
   * const pointers = {
   *   account_pubkey: 'ak_asd23dasdas...,',
   *   contract_pubkey: 'ct_asdf34fasdasd...',
   *   [getDefaultPointerKey(channel)]: channel,
   * }
   * await name.update(pointers, { nameTtl, ttl, fee, nonce, clientTtl })
   * ```
   */
  async update(pointers, options = {}) {
    const {
      extendPointers,
      ...opt
    } = {
      ...this.options,
      ...options
    };
    const allPointers = {
      ...(extendPointers === true && Object.fromEntries((await opt.onNode.getNameEntryByName(this.value)).pointers.map(({
        key,
        id
      }) => [key, id]))),
      ...pointers
    };
    const hasRawPointers = Object.values(allPointers).some(v => isEncoded(v, Encoding.Bytearray));
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.NameUpdateTx,
      version: hasRawPointers ? 2 : 1,
      nameId: this.value,
      accountId: opt.onAccount.address,
      pointers: Object.entries(allPointers).map(([key, id]) => ({
        key,
        id
      }))
    });
    return sendTransaction(tx, opt);
  }

  /**
   * Transfer a name to another account
   * @param address - Recipient account public key
   * @param options - Options
   * @returns mined transaction details
   * @example
   * ```js
   * await name.transfer('ak_asd23dasdas...', { ttl, fee, nonce })
   * ```
   */
  async transfer(address, options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.NameTransferTx,
      nameId: this.value,
      accountId: opt.onAccount.address,
      recipientId: address
    });
    return sendTransaction(tx, opt);
  }

  /**
   * Query the AENS name info from the node and return the object with info
   * @param options - Options
   * @example
   * ```js
   * const nameEntry = await name.getState()
   * console.log(nameEntry.owner)
   * ```
   */
  async getState(options = {}) {
    var _options$onNode;
    const onNode = (_options$onNode = options.onNode) !== null && _options$onNode !== void 0 ? _options$onNode : this.options.onNode;
    const nameEntry = await onNode.getNameEntryByName(this.value);
    return {
      ...nameEntry,
      id: nameEntry.id,
      owner: nameEntry.owner
    };
  }

  /**
   * Query the AENS auction info from the node and return the object with info
   * @param options - Options
   * @example
   * ```js
   * const auctionEntry = await name.getAuctionState()
   * console.log(auctionEntry.highestBidder)
   * ```
   */
  async getAuctionState(options = {}) {
    var _options$onNode2;
    if (!isAuctionName(this.value)) throw new NotAuctionNameError(this.value, 'get auction state');
    const onNode = (_options$onNode2 = options.onNode) !== null && _options$onNode2 !== void 0 ? _options$onNode2 : this.options.onNode;
    const nameEntry = await onNode.getAuctionEntryByName(this.value);
    return {
      ...nameEntry,
      id: nameEntry.id,
      highestBidder: nameEntry.highestBidder
    };
  }

  /**
   *
   * @param nameTtl - represents in number of blocks (max and default is 180000)
   * @param options - Options
   * @returns mined transaction details
   */
  async extendTtl(nameTtl, options = {}) {
    return this.update({}, {
      ...options,
      nameTtl,
      extendPointers: true
    });
  }

  /**
   * Claim a previously preclaimed registration. This can only be done after the preclaim step
   * @param options - options
   * @returns mined transaction details
   * @example
   * ```js
   * await name.claim({ ttl, fee, nonce, nameFee })
   * ```
   */
  async claim(options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      nameSalt: aens_classPrivateFieldGet(_salt, this),
      ...opt,
      tag: Tag.NameClaimTx,
      accountId: opt.onAccount.address,
      name: this.value
    });
    return sendTransaction(tx, opt);
  }

  /**
   * Preclaim a name. Sends a hash of the name and a random salt to the node
   * @param options - Options
   * @example
   * ```js
   * await name.preclaim({ ttl, fee, nonce })
   * ```
   */
  async preclaim(options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    const nameSalt = genSalt();
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.NamePreclaimTx,
      accountId: opt.onAccount.address,
      commitmentId: commitmentHash(this.value, nameSalt)
    });
    const result = await sendTransaction(tx, opt);
    aens_classPrivateFieldSet(_salt, this, nameSalt);
    return {
      ...result,
      nameSalt
    };
  }

  /**
   * Bid to name auction
   * @param nameFee - Name fee (bid fee)
   * @param options - Options
   * @returns mined transaction details
   * @example
   * ```js
   * const bidFee = computeBidFee(name.value, { startFee, increment: 0.42 })
   * await name.bid(213109412839123, { ttl, fee, nonce })
   * ```
   */
  async bid(nameFee, options = {}) {
    if (!isAuctionName(this.value)) throw new NotAuctionNameError(this.value, 'make a bid');
    const opt = {
      ...this.options,
      ...options
    };
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.NameClaimTx,
      accountId: opt.onAccount.address,
      nameSalt: 0,
      name: this.value,
      nameFee
    });
    return sendTransaction(tx, opt);
  }
}
;// ./src/contract/Contract.ts
var _Contract;
function Contract_classPrivateFieldInitSpec(e, t, a) { Contract_checkPrivateRedeclaration(e, t), t.set(e, a); }
function Contract_classPrivateMethodInitSpec(e, a) { Contract_checkPrivateRedeclaration(e, a), a.add(e); }
function Contract_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function Contract_classPrivateFieldSet(s, a, r) { return s.set(Contract_assertClassBrand(s, a), r), r; }
function Contract_classPrivateFieldGet(s, a) { return s.get(Contract_assertClassBrand(s, a)); }
function Contract_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/**
 * Contract module - routines to interact with the ternity contract
 *
 * High level documentation of the contracts are available at
 * https://github.com/aeternity/protocol/tree/master/contracts and
 */












/**
 * @category contract
 */

/**
 * @category contract
 */
var _Contract_brand = /*#__PURE__*/new WeakSet();
var _aciContract = /*#__PURE__*/new WeakMap();
/**
 * Generate contract ACI object with predefined js methods for contract usage - can be used for
 * creating a reference to already deployed contracts
 * @category contract
 * @param options - Options object
 * @returns JS Contract API
 * @example
 * ```js
 * const contractIns = await Contract.initialize({ ...aeSdk.getContext(), sourceCode })
 * await contractIns.$deploy([321]) or await contractIns.init(321)
 * const callResult = await contractIns.$call('setState', [123])
 * const staticCallResult = await contractIns.$call('setState', [123], { callStatic: true })
 * ```
 * Also you can call contract like: `await contractIns.setState(123, options)`
 * Then sdk decide to make on-chain or static call (dry-run API) transaction based on function is
 * stateful or not
 */
class Contract {
  /**
   * Compile contract
   * @returns bytecode
   */
  async $compile() {
    if (this.$options.bytecode != null) return this.$options.bytecode;
    if (this.$options.onCompiler == null) throw new IllegalArgumentError("Can't compile without compiler");
    if (this.$options.sourceCode != null) {
      const {
        bytecode
      } = await this.$options.onCompiler.compileBySourceCode(this.$options.sourceCode, this.$options.fileSystem);
      this.$options.bytecode = bytecode;
    }
    if (this.$options.sourceCodePath != null) {
      const {
        bytecode
      } = await this.$options.onCompiler.compile(this.$options.sourceCodePath);
      this.$options.bytecode = bytecode;
    }
    if (this.$options.bytecode == null) {
      throw new IllegalArgumentError("Can't compile without sourceCode and sourceCodePath");
    }
    return this.$options.bytecode;
  }
  async $getCallResultByTxHash(hash, fnName, options) {
    const {
      callInfo
    } = await this.$options.onNode.getTransactionInfoByHash(hash);
    if (callInfo == null) {
      throw new ContractError(`callInfo is not available for transaction ${hash}`);
    }
    const callInfoTyped = callInfo;
    return {
      ...Contract_assertClassBrand(_Contract_brand, this, _getCallResult).call(this, callInfoTyped, fnName, undefined, options),
      result: callInfoTyped
    };
  }
  async _estimateGas(name, params, options = {}) {
    const {
      result
    } = await this.$call(name, params, {
      ...options,
      callStatic: true
    });
    if (result == null) throw new UnexpectedTsError();
    const {
      gasUsed
    } = result;
    // taken from https://github.com/aeternity/aepp-sdk-js/issues/1286#issuecomment-977814771
    return Math.floor(gasUsed * 1.25);
  }

  /**
   * Deploy contract
   * @param params - Contract init function arguments array
   * @param options - Options
   * @returns deploy info
   */
  async $deploy(params, options) {
    var _opt$gasLimit;
    const {
      callStatic,
      ...opt
    } = {
      ...this.$options,
      ...options
    };
    if (this.$options.bytecode == null) await this.$compile();
    if (callStatic === true) return this.$call('init', params, {
      ...opt,
      callStatic
    });
    if (this.$options.address != null) throw new DuplicateContractError();
    if (opt.onAccount == null) throw new IllegalArgumentError("Can't deploy without account");
    const ownerId = opt.onAccount.address;
    if (this.$options.bytecode == null) throw new IllegalArgumentError("Can't deploy without bytecode");
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.ContractCreateTx,
      gasLimit: (_opt$gasLimit = opt.gasLimit) !== null && _opt$gasLimit !== void 0 ? _opt$gasLimit : await this._estimateGas('init', params, opt),
      callData: this._calldata.encode(this._name, 'init', params),
      code: this.$options.bytecode,
      ownerId
    });
    const {
      hash,
      ...other
    } = await Contract_assertClassBrand(_Contract_brand, this, _sendAndProcess).call(this, tx, 'init', {
      ...opt,
      onAccount: opt.onAccount
    });
    this.$options.address = buildContractIdByContractTx(other.rawTx);
    return {
      ...other,
      ...(other.result?.log != null && {
        decodedEvents: this.$decodeEvents(other.result.log, opt)
      }),
      owner: ownerId,
      transaction: hash,
      address: this.$options.address
    };
  }

  /**
   * Get function schema from contract ACI object
   * @param name - Function name
   * @returns function ACI
   */

  /**
   * Call contract function
   * @param fn - Function name
   * @param params - Array of function arguments
   * @param options - Array of function arguments
   * @returns CallResult
   */
  async $call(fn, params, options = {}) {
    var _opt$gasLimit2;
    const {
      callStatic,
      top,
      ...opt
    } = {
      ...this.$options,
      ...options
    };
    const fnAci = Contract_assertClassBrand(_Contract_brand, this, _getFunctionAci).call(this, fn);
    const {
      address,
      name
    } = this.$options;
    // TODO: call `produceNameId` on buildTx side
    const contractId = name != null ? produceNameId(name) : address;
    const {
      onNode
    } = opt;
    if (fn == null) throw new MissingFunctionNameError();
    if (fn === 'init' && callStatic !== true) throw new InvalidMethodInvocationError('"init" can be called only via dryRun');
    if (fn !== 'init' && opt.amount != null && Number(opt.amount) > 0 && !fnAci.payable) {
      throw new NotPayableFunctionError(opt.amount, fn);
    }
    let callerId;
    try {
      if (opt.onAccount == null) throw new InternalError('Use fallback account');
      callerId = opt.onAccount.address;
    } catch (error) {
      const useFallbackAccount = callStatic === true && (error instanceof errors_TypeError && error.message === 'Account should be an address (ak-prefixed string), or instance of AccountBase, got undefined instead' || error instanceof NoWalletConnectedError || error instanceof InternalError && error.message === 'Use fallback account');
      if (!useFallbackAccount) throw error;
      callerId = DRY_RUN_ACCOUNT.pub;
    }
    const callData = this._calldata.encode(this._name, fn, params);
    if (callStatic === true) {
      if (opt.nonce == null) {
        const topOption = top != null && {
          [typeof top === 'number' ? 'height' : 'hash']: top
        };
        const account = await getAccount(callerId, {
          ...topOption,
          onNode
        }).catch(error => {
          if (!isAccountNotFoundError(error)) throw error;
          return {
            kind: 'basic',
            nonce: 0
          };
        });
        opt.nonce = account.kind === 'generalized' ? 0 : account.nonce + 1;
      }
      const txOpt = {
        ...opt,
        onNode,
        callData
      };
      let tx;
      if (fn === 'init') {
        if (this.$options.bytecode == null) throw new IllegalArgumentError('Can\'t dry-run "init" without bytecode');
        tx = await buildTxAsync({
          ...txOpt,
          tag: Tag.ContractCreateTx,
          code: this.$options.bytecode,
          ownerId: callerId
        });
      } else {
        if (contractId == null) throw new MissingContractAddressError("Can't dry-run contract without address");
        tx = await buildTxAsync({
          ...txOpt,
          tag: Tag.ContractCallTx,
          callerId,
          contractId
        });
      }
      const {
        callObj,
        ...dryRunOther
      } = await txDryRun(tx, callerId, {
        ...opt,
        top
      });
      if (callObj == null) {
        throw new InternalError(`callObj is not available for transaction ${tx}`);
      }
      const callInfoTyped = callObj;
      return {
        ...dryRunOther,
        ...Contract_assertClassBrand(_Contract_brand, this, _getCallResult).call(this, callInfoTyped, fn, tx, opt),
        tx: unpackTx(tx),
        result: callInfoTyped,
        rawTx: tx,
        hash: buildTxHash(tx),
        txData: undefined
      };
    }
    if (top != null) throw new IllegalArgumentError("Can't handle `top` option in on-chain contract call");
    if (contractId == null) throw new MissingContractAddressError("Can't call contract without address");
    const tx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.ContractCallTx,
      gasLimit: (_opt$gasLimit2 = opt.gasLimit) !== null && _opt$gasLimit2 !== void 0 ? _opt$gasLimit2 : await this._estimateGas(fn, params, opt),
      callerId,
      contractId,
      callData
    });
    if (opt.onAccount == null) throw new IllegalArgumentError("Can't call contract on chain without account");
    return Contract_assertClassBrand(_Contract_brand, this, _sendAndProcess).call(this, tx, fn, {
      ...opt,
      onAccount: opt.onAccount
    });
  }

  /**
   * @param ctAddress - Contract address that emitted event
   * @param nameHash - Hash of emitted event name
   * @param options - Options
   * @returns Contract name
   * @throws {@link MissingEventDefinitionError}
   * @throws {@link AmbiguousEventDefinitionError}
   */

  /**
   * Decode Events
   * @param events - Array of encoded events (callRes.result.log)
   * @param options - Options
   * @returns DecodedEvents
   */
  $decodeEvents(events, {
    omitUnknown,
    ...opt
  } = {}) {
    return events.map(event => {
      let contractName;
      try {
        contractName = Contract_assertClassBrand(_Contract_brand, this, _getContractNameByEvent).call(this, event.address, event.topics[0], opt);
      } catch (error) {
        if ((omitUnknown !== null && omitUnknown !== void 0 ? omitUnknown : false) && error instanceof MissingEventDefinitionError) return null;
        throw error;
      }
      const decoded = this._calldata.decodeEvent(contractName, event.data, event.topics);
      const [name, args] = Object.entries(decoded)[0];
      return {
        name,
        args,
        contract: {
          name: contractName,
          address: event.address
        }
      };
    }).filter(e => e != null);
  }
  static async initialize({
    onCompiler,
    onNode,
    bytecode,
    aci,
    address,
    sourceCodePath,
    sourceCode,
    fileSystem,
    validateBytecode,
    ...otherOptions
  }) {
    if (aci == null && onCompiler != null) {
      let res;
      if (sourceCodePath != null) res = await onCompiler.compile(sourceCodePath);
      if (sourceCode != null) res = await onCompiler.compileBySourceCode(sourceCode, fileSystem);
      if (res != null) {
        aci = res.aci;
        bytecode !== null && bytecode !== void 0 ? bytecode : bytecode = res.bytecode;
      }
    }
    if (aci == null) throw new MissingContractDefError();
    let name;
    if (address != null) {
      address = await resolveName(address, 'contract_pubkey', {
        resolveByNode: true,
        onNode
      });
      if (isName(address)) name = address;
    }
    if (address == null && sourceCode == null && sourceCodePath == null && bytecode == null) {
      throw new MissingContractAddressError("Can't create instance by ACI without address");
    }
    if (address != null) {
      const contract = await onNode.getContract(address);
      if (contract.active == null) throw new InactiveContractError(address);
    }
    if (validateBytecode === true) {
      if (address == null) throw new MissingContractAddressError("Can't validate bytecode without contract address");
      const onChanBytecode = (await onNode.getContractCode(address)).bytecode;
      let isValid = false;
      if (bytecode != null) isValid = bytecode === onChanBytecode;else if (sourceCode != null) {
        if (onCompiler == null) throw new IllegalArgumentError("Can't validate bytecode without compiler");
        isValid = await onCompiler.validateBySourceCode(onChanBytecode, sourceCode, fileSystem);
      } else if (sourceCodePath != null) {
        if (onCompiler == null) throw new IllegalArgumentError("Can't validate bytecode without compiler");
        isValid = await onCompiler.validate(onChanBytecode, sourceCodePath);
      }
      if (!isValid) {
        throw new BytecodeMismatchError((sourceCode !== null && sourceCode !== void 0 ? sourceCode : sourceCodePath) != null ? 'source code' : 'bytecode');
      }
    }
    return new ContractWithMethods({
      onCompiler,
      onNode,
      sourceCode,
      sourceCodePath,
      bytecode,
      aci,
      address,
      name,
      fileSystem,
      ...otherOptions
    });
  }
  /**
   * @param options - Options
   */
  constructor({
    aci,
    ...otherOptions
  }) {
    Contract_classPrivateMethodInitSpec(this, _Contract_brand);
    Contract_classPrivateFieldInitSpec(this, _aciContract, void 0);
    this._aci = aci;
    const aciLast = aci[aci.length - 1];
    if (aciLast.contract == null) {
      throw new IllegalArgumentError(`The last 'aci' item should have 'contract' key, got ${Object.keys(aciLast)} keys instead`);
    }
    Contract_classPrivateFieldSet(_aciContract, this, aciLast.contract);
    this._name = Contract_classPrivateFieldGet(_aciContract, this).name;
    this._calldata = new aepp_calldata_.Encoder(aci);
    this.$options = otherOptions;

    /**
     * Generate proto function based on contract function using Contract ACI schema
     * All function can be called like:
     * ```js
     * await contract.testFunction()
     * ```
     * then sdk will decide to use dry-run or send tx
     * on-chain base on if function stateful or not.
     * Also, you can manually do that:
     * ```js
     * await contract.testFunction({ callStatic: true }) // use call-static (dry-run)
     * await contract.testFunction({ callStatic: false }) // send tx on-chain
     * ```
     */
    Object.assign(this, Object.fromEntries(Contract_classPrivateFieldGet(_aciContract, this).functions.map(({
      name,
      arguments: aciArgs,
      stateful
    }) => {
      const callStatic = name !== 'init' && !stateful;
      return [name, async (...args) => {
        const options = args.length === aciArgs.length + 1 ? args.pop() : {};
        if (typeof options !== 'object') throw new errors_TypeError(`Options should be an object: ${options}`);
        if (name === 'init') return this.$deploy(args, {
          callStatic,
          ...options
        });
        return this.$call(name, args, {
          callStatic,
          ...options
        });
      }];
    })));
  }
}
_Contract = Contract;
function _getCallResult({
  returnType,
  returnValue,
  log
}, fnName, transaction, options) {
  let message;
  switch (returnType) {
    case 'ok':
      {
        const fnAci = Contract_assertClassBrand(_Contract_brand, this, _getFunctionAci).call(this, fnName);
        return {
          decodedResult: this._calldata.decode(this._name, fnAci.name, returnValue),
          decodedEvents: this.$decodeEvents(log, options)
        };
      }
    case 'revert':
      message = this._calldata.decodeFateString(returnValue);
      break;
    case 'error':
      message = decode(returnValue).toString();
      if (/Expected \d+ arguments, got \d+/.test(message)) {
        throw new BytecodeMismatchError('ACI', `. Error provided by node: "${message}".`);
      }
      if (/Trying to call undefined function: <<\d+,\d+,\d+,\d+>>/.test(message)) {
        throw new BytecodeMismatchError('ACI', `. Error provided by node: "${message}", function name: ${fnName}.`);
      }
      break;
    default:
      throw new InternalError(`Unknown return type: ${returnType}`);
  }
  throw new NodeInvocationError(message, transaction);
}
async function _sendAndProcess(tx, fnName, options) {
  const txData = await sendTransaction(tx, {
    ...this.$options,
    ...options
  });
  return {
    hash: txData.hash,
    tx: unpackTx(txData.rawTx),
    txData,
    rawTx: txData.rawTx,
    // TODO: disallow `waitMined: false` to make `decodedResult` required
    ...(txData.blockHeight != null && (await this.$getCallResultByTxHash(txData.hash, fnName, options)))
  };
}
function _getFunctionAci(name) {
  const fn = Contract_classPrivateFieldGet(_aciContract, this).functions.find(f => f.name === name);
  if (fn != null) {
    return fn;
  }
  if (name === 'init') {
    return {
      arguments: [],
      name: 'init',
      payable: false,
      returns: 'unit',
      stateful: true
    };
  }
  throw new NoSuchContractFunctionError(name);
}
function _getContractNameByEvent(ctAddress, nameHash, {
  contractAddressToName
}) {
  const addressToName = {
    ...this.$options.contractAddressToName,
    ...contractAddressToName
  };
  if (addressToName[ctAddress] != null) return addressToName[ctAddress];

  // TODO: consider using a third-party library
  const isEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);
  const contracts = this._aci.map(({
    contract
  }) => contract).filter(contract => contract?.event);
  const matchedEvents = contracts.map(contract => [contract.name, contract.event.variant]).map(([name, events]) => events.map(event => [name, Object.keys(event)[0], Object.values(event)[0]])).flat().filter(([, eventName]) => BigInt(`0x${hash(eventName).toString('hex')}`) === nameHash).filter(([,, type], idx, arr) => !arr.slice(0, idx).some(el => isEqual(el[2], type)));
  switch (matchedEvents.length) {
    case 0:
      throw new MissingEventDefinitionError(nameHash.toString(), ctAddress);
    case 1:
      return matchedEvents[0][0];
    default:
      throw new AmbiguousEventDefinitionError(ctAddress, matchedEvents);
  }
}
/**
 * @category contract
 */
// eslint-disable-next-line @typescript-eslint/no-redeclare
const ContractWithMethods = Contract;
/* harmony default export */ const contract_Contract = (ContractWithMethods);
;// ./src/oracle/OracleBase.ts


/**
 * @category oracle
 */

/**
 * @category oracle
 */

function decodeQuery(queryEntry) {
  return {
    ...queryEntry,
    id: queryEntry.id,
    decodedQuery: decode(queryEntry.query).toString(),
    decodedResponse: decode(queryEntry.response).toString()
  };
}

/**
 * This class is needed because `getOracleQuery` would return different values depending on the
 * oracle type.
 * @category oracle
 */
class OracleBase {
  /**
   * @param address - Oracle public key
   */
  constructor(address, options) {
    this.address = address;
    this.options = options;
  }

  /**
   * Get oracle entry from the node
   * @param options - Options object
   */
  async getState(options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    return opt.onNode.getOracleByPubkey(this.address);
  }

  /**
   * Get oracle queries from the node
   * @param options - Options object
   */
  async getQueries(options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    return (await opt.onNode.getOracleQueriesByPubkey(this.address)).oracleQueries.map(decodeQuery);
  }

  /**
   * Get oracle query entry from the node
   * @param queryId - Oracle query ID
   * @param options - Options object
   */
  async getQuery(queryId, options = {}) {
    const {
      onNode
    } = {
      ...this.options,
      ...options
    };
    const queryEntry = await onNode.getOracleQueryByPubkeyAndQueryId(this.address, queryId);
    return decodeQuery(queryEntry);
  }
}
;// ./src/oracle/Oracle.ts
function Oracle_classPrivateFieldInitSpec(e, t, a) { Oracle_checkPrivateRedeclaration(e, t), t.set(e, a); }
function Oracle_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function Oracle_classPrivateFieldSet(s, a, r) { return s.set(Oracle_assertClassBrand(s, a), r), r; }
function Oracle_classPrivateFieldGet(s, a) { return s.get(Oracle_assertClassBrand(s, a)); }
function Oracle_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }








/**
 * @category oracle
 */

/**
 * @category oracle
 */

/**
 * @category oracle
 */
var _handleQueriesPromise = /*#__PURE__*/new WeakMap();
/**
 * @category oracle
 */
class Oracle extends OracleBase {
  /**
   * @param account - Account to use as oracle
   * @param options - Options object
   */
  constructor(account, options) {
    super(encode(decode(account.address), Encoding.OracleAddress), options);
    Oracle_classPrivateFieldInitSpec(this, _handleQueriesPromise, void 0);
    this.account = account;
    this.options = options;
  }

  // TODO: support abiVersion other than 0
  /**
   * Register oracle
   * @param queryFormat - Format of query
   * @param responseFormat - Format of query response
   * @param options - Options object
   */
  async register(queryFormat, responseFormat, options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    const oracleRegisterTx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.OracleRegisterTx,
      accountId: this.account.address,
      queryFormat,
      responseFormat
    });
    return sendTransaction(oracleRegisterTx, {
      ...opt,
      onAccount: this.account
    });
  }

  /**
   * Extend oracle ttl
   * @param options - Options object
   */
  async extendTtl(options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    const oracleExtendTx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.OracleExtendTx,
      oracleId: this.address
    });
    return sendTransaction(oracleExtendTx, {
      ...opt,
      onAccount: this.account
    });
  }

  /**
   * Poll for oracle queries
   * @param onQuery - OnQuery callback
   * @param options - Options object
   * @param options.interval - Poll interval (default: 5000)
   * @returns Callback to stop polling function
   */
  pollQueries(onQuery, options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    const knownQueryIds = new Set();
    let isChecking = false;
    const checkNewQueries = async () => {
      if (isChecking) return;
      isChecking = true;
      const filtered = (await this.getQueries(opt)).filter(({
        id
      }) => !knownQueryIds.has(id)).filter(query => options.includeResponded === true || query.decodedResponse === '');
      filtered.forEach(query => knownQueryIds.add(query.id));
      isChecking = false;
      await Promise.all(filtered.map(query => onQuery(query)));
    };
    checkNewQueries();
    const idPromise = (async _opt$interval => {
      const interval = (_opt$interval = opt.interval) !== null && _opt$interval !== void 0 ? _opt$interval : await _getPollInterval('micro-block', opt);
      return setInterval(async () => checkNewQueries(), interval);
    })();
    return async () => {
      const id = await idPromise;
      clearInterval(id);
    };
  }

  /**
   * Respond to a query
   * @param queryId - Oracle query id
   * @param response - The response to query
   * @param options - Options object
   */
  async respondToQuery(queryId, response, options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    const oracleRespondTx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.OracleRespondTx,
      oracleId: this.address,
      queryId,
      response
    });
    return sendTransaction(oracleRespondTx, {
      ...opt,
      onAccount: this.account
    });
  }
  /**
   * Respond to queries to oracle based on callback value
   * @param getResponse - Callback to respond on query
   * @param options - Options object
   * @param options.interval - Poll interval (default: 5000)
   * @returns Callback to stop polling function
   */
  handleQueries(getResponse, options = {}) {
    if (Oracle_classPrivateFieldGet(_handleQueriesPromise, this) != null) {
      throw new LogicError('Another query handler already running, it needs to be stopped to run a new one');
    }
    const opt = {
      ...this.options,
      ...options
    };
    let queuePromise = Promise.resolve();
    const handler = async q => {
      const response = await getResponse(q);
      const respondPromise = queuePromise.then(async () => this.respondToQuery(q.id, response, opt));
      queuePromise = respondPromise.then(() => {}, () => {});
      await respondPromise;
    };
    Oracle_classPrivateFieldSet(_handleQueriesPromise, this, Promise.resolve());
    const stopPoll = this.pollQueries(async query => {
      const promise = handler(query);
      if (Oracle_classPrivateFieldGet(_handleQueriesPromise, this) == null) throw new UnexpectedTsError();
      Oracle_classPrivateFieldSet(_handleQueriesPromise, this, Oracle_classPrivateFieldGet(_handleQueriesPromise, this).then(async () => promise).then(() => {}, () => {}));
      return promise;
    }, opt);
    return async () => {
      stopPoll();
      await Oracle_classPrivateFieldGet(_handleQueriesPromise, this);
      Oracle_classPrivateFieldSet(_handleQueriesPromise, this, undefined);
    };
  }
}
;// ./src/oracle/OracleClient.ts










/**
 * @category oracle
 */

/**
 * @category oracle
 */
class OracleClient extends OracleBase {
  /**
   * @param address - Oracle public key
   * @param options - Options object
   * @param options.onAccount - Account to use
   * @param options.onNode - Node to use
   */
  constructor(address, options) {
    super(address, options);
    this.options = options;
  }

  /**
   * Post query to oracle
   * @param query - Query to oracle
   * @param options - Options object
   * @returns Transaction details and query ID
   */
  async postQuery(query, options = {}) {
    const opt = {
      ...this.options,
      ...options
    };
    const senderId = opt.onAccount.address;
    const oracleQueryTx = await buildTxAsync({
      _isInternalBuild: true,
      ...opt,
      tag: Tag.OracleQueryTx,
      oracleId: this.address,
      senderId,
      query
    });
    const {
      nonce
    } = unpackTx(oracleQueryTx, Tag.OracleQueryTx);
    return {
      ...(await sendTransaction(oracleQueryTx, opt)),
      queryId: oracleQueryId(senderId, nonce, this.address)
    };
  }

  /**
   * Poll for oracle response to query
   * @param queryId - Oracle Query id
   * @param options - Options object
   * @param options.interval - Poll interval
   * @returns Oracle response
   */
  async pollForResponse(queryId, options = {}) {
    var _opt$interval;
    const opt = {
      ...this.options,
      ...options
    };
    const interval = (_opt$interval = opt.interval) !== null && _opt$interval !== void 0 ? _opt$interval : await _getPollInterval('micro-block', opt);
    let height;
    let ttl;
    let response;
    do {
      ({
        response,
        ttl
      } = await this.getQuery(queryId, opt));
      const responseBuffer = decode(response);
      if (responseBuffer.length > 0) return responseBuffer.toString();
      await pause(interval);
      height = await getHeight({
        ...opt,
        cached: true
      });
    } while (ttl >= height);
    throw new RequestTimedOutError(height);
  }

  /**
   * Post query to oracle and wait for response
   * @param query - Query to oracle
   * @param options - Options object
   * @returns Oracle response
   */
  async query(query, options = {}) {
    const {
      queryId
    } = await this.postQuery(query, options);
    return this.pollForResponse(queryId, options);
  }
}
;// ./src/spend.ts







// TODO: name verify should not overlap with transaction verify

/**
 * Send coins to another account
 * @category chain
 * @param amount - Amount to spend
 * @param recipientIdOrName - Address or name of recipient account
 * @param options - Options
 * @returns Transaction
 */
async function spend(amount, recipientIdOrName, options) {
  return sendTransaction(await buildTxAsync({
    _isInternalBuild: true,
    ...options,
    tag: Tag.SpendTx,
    senderId: options.onAccount.address,
    recipientId: await resolveName(recipientIdOrName, 'account_pubkey', options),
    amount
  }), options);
}
// TODO: Rename to spendFraction
/**
 * Spend a fraction of coin balance to another account. Useful if needed to drain account balance
 * completely, sending funds to another account (with fraction set to 1).
 * @category chain
 * @param fraction - Fraction of balance to spend (between 0 and 1)
 * @param recipientIdOrName - Address or name of recipient account
 * @param options - Options
 * @example
 * ```js
 * // `fraction` * 100 = % of AE to be transferred (e.g. `0.42` for 42% or `1` for 100%)
 * const { blockHeight } = await aeSdk.transferFunds(
 *   0.42,
 *   'ak_21A27UVVt3hDkBE5J7rhhqnH5YNb4Y1dqo4PnSybrH85pnWo7E',
 * );
 * console.log('Transaction mined at', blockHeight);
 * ```
 */
async function transferFunds(fraction,
// TODO: accept only number
recipientIdOrName, options) {
  if (+fraction < 0 || +fraction > 1) {
    throw new ArgumentError('fraction', 'a number between 0 and 1', fraction);
  }
  const recipientId = await resolveName(recipientIdOrName, 'account_pubkey', options);
  const senderId = options.onAccount.address;
  const balance = new (external_bignumber_js_default())(await getBalance.bind(options.onAccount)(senderId, options));
  const desiredAmount = balance.times(fraction).integerValue((external_bignumber_js_default()).ROUND_HALF_UP);
  const {
    fee
  } = unpackTx(await buildTxAsync({
    _isInternalBuild: true,
    ...options,
    tag: Tag.SpendTx,
    senderId,
    recipientId,
    amount: desiredAmount
  }), Tag.SpendTx);
  // Reducing of the amount may reduce transaction fee, so this is not completely accurate
  const amount = desiredAmount.plus(fee).gt(balance) ? balance.minus(fee) : desiredAmount;
  return sendTransaction(await buildTxAsync({
    _isInternalBuild: true,
    ...options,
    tag: Tag.SpendTx,
    senderId,
    recipientId,
    amount
  }), options);
}
/**
 * Submit transaction of another account paying for it (fee and gas)
 * @category chain
 * @param transaction - tx_<base64>-encoded transaction
 * @param options - Options
 * @returns Object Transaction
 */
async function payForTransaction(transaction, options) {
  return sendTransaction(await buildTxAsync({
    _isInternalBuild: true,
    ...options,
    tag: Tag.PayingForTx,
    payerId: options.onAccount.address,
    tx: transaction
  }), options);
}
;// ./src/contract/ga.ts
/**
 * Generalized Account module - routines to use generalized account
 */













/**
 * Convert current account to GA
 * @category account generalized
 * @param authFnName - Authorization function name
 * @param args - init arguments
 * @param options - Options
 * @returns General Account Object
 */
async function createGeneralizedAccount(authFnName, args, {
  onAccount,
  onCompiler,
  onNode,
  bytecode,
  aci,
  sourceCodePath,
  sourceCode,
  fileSystem,
  ...options
}) {
  var _options$gasLimit;
  const ownerId = onAccount.address;
  if ((await getAccount(ownerId, {
    onNode
  })).kind === 'generalized') {
    throw new IllegalArgumentError(`Account ${ownerId} is already GA`);
  }
  const contract = await contract_Contract.initialize({
    onAccount,
    onCompiler,
    onNode,
    bytecode,
    aci,
    sourceCodePath,
    sourceCode,
    fileSystem
  });
  const tx = await buildTxAsync({
    _isInternalBuild: true,
    ...options,
    tag: Tag.GaAttachTx,
    onNode,
    code: await contract.$compile(),
    gasLimit: (_options$gasLimit = options.gasLimit) !== null && _options$gasLimit !== void 0 ? _options$gasLimit : await contract._estimateGas('init', args, options),
    ownerId,
    callData: contract._calldata.encode(contract._name, 'init', args),
    authFun: hash(authFnName)
  });
  const {
    hash: transaction,
    rawTx
  } = await sendTransaction(tx, {
    onNode,
    onAccount,
    onCompiler,
    ...options
  });
  const contractId = buildContractIdByContractTx(rawTx);
  return Object.freeze({
    owner: ownerId,
    transaction,
    rawTx,
    gaContractId: contractId
  });
}
/**
 * Build a transaction hash the same as `Auth.tx_hash` by GaMetaTx payload
 * @category account generalized
 * @param transaction - tx-encoded transaction
 * @param options - Options
 * @param options.fee - GaMetaTx fee, required in Ceres
 * @param options.gasPrice - GaMetaTx gasPrice, required in Ceres
 * @param options.onNode - Node to use
 * @returns Transaction hash
 */
async function buildAuthTxHash(transaction, {
  fee,
  gasPrice,
  onNode
}) {
  const {
    nodeNetworkId,
    consensusProtocolVersion
  } = await onNode.getNodeInfo();
  let payload = hash(concatBuffers([Buffer.from(nodeNetworkId), decode(transaction)]));
  if (consensusProtocolVersion === ConsensusProtocolVersion.Ceres) {
    if (fee == null) throw new ArgumentError('fee', 'provided (in Ceres)', fee);
    if (gasPrice == null) throw new ArgumentError('gasPrice', 'provided (in Ceres)', gasPrice);
    payload = hash(decode(packEntry({
      tag: EntryTag.GaMetaTxAuthData,
      fee,
      gasPrice,
      txHash: encode(payload, Encoding.TxHash)
    })));
  }
  return payload;
}

/**
 * Build a transaction hash the same as `Auth.tx_hash` by GaMetaTx
 * @category account generalized
 * @param transaction - tx-encoded signed GaMeta transaction
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Transaction hash
 */
async function buildAuthTxHashByGaMetaTx(transaction, {
  onNode
}) {
  const txParams = unpackTx(transaction, Tag.SignedTx);
  if (txParams.encodedTx.tag !== Tag.GaMetaTx) {
    throw new ArgumentError('transaction', 'to include GaMetaTx', Tag[txParams.encodedTx.tag]);
  }
  return buildAuthTxHash(buildTx(txParams.encodedTx.tx.encodedTx), {
    fee: txParams.encodedTx.fee,
    gasPrice: txParams.encodedTx.gasPrice,
    onNode
  });
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs3/helpers/defineProperty.js
var defineProperty = __webpack_require__(533);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);
;// ./src/AeSdkMethods.ts

function AeSdkMethods_classPrivateFieldInitSpec(e, t, a) { AeSdkMethods_checkPrivateRedeclaration(e, t), t.set(e, a); }
function AeSdkMethods_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function AeSdkMethods_classPrivateFieldGet(s, a) { return s.get(AeSdkMethods_assertClassBrand(s, a)); }
function AeSdkMethods_classPrivateFieldSet(s, a, r) { return s.set(AeSdkMethods_assertClassBrand(s, a), r), r; }
function AeSdkMethods_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }







const methods = {
  ...chain_namespaceObject,
  sendTransaction: sendTransaction,
  ...spend_namespaceObject,
  ...ga_namespaceObject
};
var _wrappedOptions = /*#__PURE__*/new WeakMap();
/**
 * AeSdkMethods is the composition of:
 * - chain methods
 * - tx methods
 * - aens methods
 * - spend methods
 * - oracle methods
 * - contract methods
 * - contract ga methods
 *
 * While these methods can be used separately, this class provides a handy way to store
 * their context (current account, network, and compiler to use).
 */
class AeSdkMethods {
  /**
   * @param options - Options
   */
  constructor(options = {}) {
    defineProperty_default()(this, "_options", {});
    AeSdkMethods_classPrivateFieldInitSpec(this, _wrappedOptions, void 0);
    Object.assign(this._options, options);
    AeSdkMethods_classPrivateFieldSet(_wrappedOptions, this, {
      onAccount: wrapWithProxy(() => this._options.onAccount),
      onNode: wrapWithProxy(() => this._options.onNode),
      onCompiler: wrapWithProxy(() => this._options.onCompiler)
    });
  }

  /**
   * Returns sdk instance options with references to current account, node, compiler.
   * Used to create an instance (Contract, Oracle) bound to AeSdk state.
   * @param mergeWith - Merge context with these extra options
   * @returns Context object
   */
  getContext(mergeWith = {}) {
    return {
      ...this._options,
      ...AeSdkMethods_classPrivateFieldGet(_wrappedOptions, this),
      ...mergeWith
    };
  }

  // TODO: omit onNode from options, because it is already in context
  async buildTx(options) {
    // TODO: remove `any` at the same time as AeSdk class
    return buildTxAsync({
      ...this.getContext(),
      ...options
    });
  }
}
Object.assign(AeSdkMethods.prototype, mapObject(methods, ([name, handler]) => [name, function methodWrapper(...args) {
  args.length = handler.length;
  const options = args[args.length - 1];
  args[args.length - 1] = this.getContext(options);
  return handler(...args);
}]));
// eslint-disable-next-line @typescript-eslint/no-redeclare
const AeSdkMethodsTyped = AeSdkMethods;
/* harmony default export */ const src_AeSdkMethods = (AeSdkMethodsTyped);
;// ./src/AeSdkBase.ts

function AeSdkBase_classPrivateFieldInitSpec(e, t, a) { AeSdkBase_checkPrivateRedeclaration(e, t), t.set(e, a); }
function AeSdkBase_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function AeSdkBase_classPrivateFieldGet(s, a) { return s.get(AeSdkBase_assertClassBrand(s, a)); }
function AeSdkBase_classPrivateFieldSet(s, a, r) { return s.set(AeSdkBase_assertClassBrand(s, a), r), r; }
function AeSdkBase_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }



var AeSdkBase_wrappedOptions = /*#__PURE__*/new WeakMap();
/**
 * Basic AeSdk class implements:
 * - node selector,
 * - integrated compiler support,
 * - wrappers of account methods mapped to the current account.
 */
class AeSdkBase extends src_AeSdkMethods {
  /**
   * @param options - Options
   * @param options.nodes - Array of nodes
   */
  constructor({
    nodes = [],
    ...options
  } = {}) {
    super(options);
    defineProperty_default()(this, "pool", new Map());
    AeSdkBase_classPrivateFieldInitSpec(this, AeSdkBase_wrappedOptions, void 0);
    nodes.forEach(({
      name,
      instance
    }, i) => this.addNode(name, instance, i === 0));
    AeSdkBase_classPrivateFieldSet(AeSdkBase_wrappedOptions, this, {
      onNode: wrapWithProxy(() => this.api),
      onCompiler: wrapWithProxy(() => this.compilerApi),
      onAccount: wrapWithProxy(() => this._resolveAccount())
    });
  }

  // TODO: consider dropping this getter, because:
  // compiler is not intended to be used separately any more (functionality limited to sdk needs)
  // and user creates its instance by himself
  get compilerApi() {
    if (this._options.onCompiler == null) {
      throw new CompilerError("You can't use Compiler API. Compiler is not ready!");
    }
    return this._options.onCompiler;
  }
  get api() {
    this.ensureNodeConnected();
    return this.pool.get(this.selectedNodeName);
  }

  /**
   * Add Node
   * @param name - Node name
   * @param node - Node instance
   * @param select - Select this node as current
   * @example
   * ```js
   * // add and select new node with name 'testNode'
   * aeSdkBase.addNode('testNode', new Node({ url }), true)
   * ```
   */
  addNode(name, node, select = false) {
    if (this.pool.has(name)) throw new DuplicateNodeError(name);
    this.pool.set(name, node);
    if (select || this.selectedNodeName == null) {
      this.selectNode(name);
    }
  }

  /**
   * Select Node
   * @param name - Node name
   * @example
   * nodePool.selectNode('testNode')
   */
  selectNode(name) {
    if (!this.pool.has(name)) throw new NodeNotFoundError(`Node with name ${name} not in pool`);
    this.selectedNodeName = name;
  }

  /**
   * Check if you have selected node
   * @example
   * nodePool.isNodeConnected()
   */
  isNodeConnected() {
    return this.selectedNodeName != null;
  }
  ensureNodeConnected() {
    if (!this.isNodeConnected()) {
      throw new NodeNotFoundError("You can't use Node API. Node is not connected or not defined!");
    }
  }

  /**
   * Get information about node
   * @example
   * ```js
   * nodePool.getNodeInfo() // { name, version, networkId, protocol, ... }
   * ```
   */
  async getNodeInfo() {
    this.ensureNodeConnected();
    return {
      name: this.selectedNodeName,
      ...(await this.api.getNodeInfo())
    };
  }

  /**
   * Get array of available nodes
   * @example
   * nodePool.getNodesInPool()
   */
  async getNodesInPool() {
    return Promise.all(Array.from(this.pool.entries()).map(async ([name, node]) => ({
      name,
      ...(await node.getNodeInfo())
    })));
  }

  // eslint-disable-next-line class-methods-use-this
  addresses() {
    return [];
  }

  /**
   * Resolves an account
   * @param account - ak-address, instance of AccountBase, or keypair
   */
  _resolveAccount(account = this._options.onAccount) {
    if (typeof account === 'string') throw new NotImplementedError('Address in AccountResolver');
    if (typeof account === 'object') return account;
    throw new errors_TypeError('Account should be an address (ak-prefixed string), ' + `or instance of AccountBase, got ${String(account)} instead`);
  }
  get address() {
    return this._resolveAccount().address;
  }

  /**
   * Sign data blob
   * @param data - Data to sign
   * @param options - Options
   * @deprecated Use `unsafeSign` method instead
   */
  async sign(data, options = {}) {
    return this.unsafeSign(data, options);
  }

  /**
   * Sign data blob
   * @param data - Data to sign
   * @param options - Options
   */
  async unsafeSign(data, {
    onAccount,
    ...options
  } = {}) {
    return this._resolveAccount(onAccount).unsafeSign(data, options);
  }

  /**
   * Sign encoded transaction
   * @param tx - Transaction to sign
   * @param options - Options
   */
  async signTransaction(tx, {
    onAccount,
    ...options
  } = {}) {
    const networkId = this.selectedNodeName !== null ? await this.api.getNetworkId() : undefined;
    return this._resolveAccount(onAccount).signTransaction(tx, {
      networkId,
      ...options
    });
  }

  /**
   * Sign message
   * @param message - Message to sign
   * @param options - Options
   */
  async signMessage(message, {
    onAccount,
    ...options
  } = {}) {
    return this._resolveAccount(onAccount).signMessage(message, options);
  }

  /**
   * Sign typed data
   * @param data - Encoded data to sign
   * @param aci - Type of data to sign
   * @param options - Options
   */
  async signTypedData(data, aci, {
    onAccount,
    ...options
  } = {}) {
    return this._resolveAccount(onAccount).signTypedData(data, aci, options);
  }

  /**
   * Sign delegation, works only in Ceres
   * @param delegation - Delegation to sign
   * @param options - Options
   */
  async signDelegation(delegation, {
    onAccount,
    ...options
  } = {}) {
    var _options$networkId;
    (_options$networkId = options.networkId) !== null && _options$networkId !== void 0 ? _options$networkId : options.networkId = this.selectedNodeName !== null ? await this.api.getNetworkId() : undefined;
    return this._resolveAccount(onAccount).signDelegation(delegation, options);
  }

  /**
   * The same as AeSdkMethods:getContext, but it would resolve ak_-prefixed address in
   * `mergeWith.onAccount` to AccountBase.
   */
  getContext(mergeWith = {}) {
    return {
      ...this._options,
      ...AeSdkBase_classPrivateFieldGet(AeSdkBase_wrappedOptions, this),
      ...mergeWith,
      ...(mergeWith.onAccount != null && {
        onAccount: this._resolveAccount(mergeWith.onAccount)
      })
    };
  }
}
;// ./src/AeSdk.ts




class AeSdk extends AeSdkBase {
  /**
   * @param options - Options
   */
  constructor({
    accounts,
    ...options
  } = {}) {
    super(options);
    defineProperty_default()(this, "accounts", {});
    accounts?.forEach((account, idx) => this.addAccount(account, {
      select: idx === 0
    }));
  }
  _resolveAccount(account = this.selectedAddress) {
    if (typeof account === 'string') {
      const address = account;
      decode(address);
      if (this.accounts[address] == null) throw new UnavailableAccountError(account);
      account = this.accounts[address];
    }
    return super._resolveAccount(account);
  }

  /**
   * Get accounts addresses
   * @example addresses()
   */
  addresses() {
    return Object.keys(this.accounts);
  }

  /**
   * Add specific account
   * @param account - Account instance
   * @param options - Options
   * @param options.select - Select account
   * @example addAccount(account)
   */
  addAccount(account, {
    select
  } = {}) {
    const {
      address
    } = account;
    this.accounts[address] = account;
    if (select === true) this.selectAccount(address);
  }

  /**
   * Remove specific account
   * @param address - Address of account to remove
   * @example removeAccount(address)
   */
  removeAccount(address) {
    if (this.accounts[address] == null) throw new UnavailableAccountError(address);
    delete this.accounts[address]; // eslint-disable-line @typescript-eslint/no-dynamic-delete
    if (this.selectedAddress === address) delete this.selectedAddress;
  }

  /**
   * Select specific account
   * @param address - Address of account to select
   * @example selectAccount('ak_xxxxxxxx')
   */
  selectAccount(address) {
    decode(address);
    if (this.accounts[address] == null) throw new UnavailableAccountError(address);
    this.selectedAddress = address;
  }
}
;// ./src/aepp-wallet-communication/schema.ts

// eslint-disable-next-line max-classes-per-file



/**
 * @category aepp wallet communication
 */
let MESSAGE_DIRECTION = /*#__PURE__*/function (MESSAGE_DIRECTION) {
  MESSAGE_DIRECTION["to_waellet"] = "to_waellet";
  MESSAGE_DIRECTION["to_aepp"] = "to_aepp";
  return MESSAGE_DIRECTION;
}({});

/**
 * @category aepp wallet communication
 */
let WALLET_TYPE = /*#__PURE__*/function (WALLET_TYPE) {
  WALLET_TYPE["window"] = "window";
  WALLET_TYPE["extension"] = "extension";
  return WALLET_TYPE;
}({});

/**
 * @category aepp wallet communication
 */
let SUBSCRIPTION_TYPES = /*#__PURE__*/function (SUBSCRIPTION_TYPES) {
  SUBSCRIPTION_TYPES["subscribe"] = "subscribe";
  SUBSCRIPTION_TYPES["unsubscribe"] = "unsubscribe";
  return SUBSCRIPTION_TYPES;
}({});

/**
 * @category aepp wallet communication
 */
let METHODS = /*#__PURE__*/function (METHODS) {
  METHODS["readyToConnect"] = "connection.announcePresence";
  METHODS["updateAddress"] = "address.update";
  METHODS["address"] = "address.get";
  METHODS["connect"] = "connection.open";
  METHODS["unsafeSign"] = "data.unsafeSign";
  METHODS["sign"] = "transaction.sign";
  METHODS["signMessage"] = "message.sign";
  METHODS["signTypedData"] = "typedData.sign";
  METHODS["signDelegation"] = "delegation.sign";
  METHODS["subscribeAddress"] = "address.subscribe";
  METHODS["updateNetwork"] = "networkId.update";
  METHODS["closeConnection"] = "connection.close";
  return METHODS;
}({});

/**
 * @category aepp wallet communication
 */
let RPC_STATUS = /*#__PURE__*/function (RPC_STATUS) {
  RPC_STATUS["CONNECTED"] = "CONNECTED";
  RPC_STATUS["DISCONNECTED"] = "DISCONNECTED";
  RPC_STATUS["WAITING_FOR_CONNECTION_REQUEST"] = "WAITING_FOR_CONNECTION_REQUEST";
  return RPC_STATUS;
}({});
const rpcErrors = [];

/**
 * @category exception
 */
class RpcError extends BaseError {
  toJSON() {
    return {
      code: this.code,
      message: this.message,
      data: this.data
    };
  }
  static deserialize(json) {
    const RpcErr = rpcErrors.find(cl => cl.code === json.code);
    if (RpcErr == null) throw new InternalError(`Can't find RpcError with code: ${json.code}`);
    return new RpcErr(json.data);
  }
}

/**
 * @category exception
 */
class RpcInvalidTransactionError extends RpcError {
  constructor(data) {
    super('Invalid transaction');
    defineProperty_default()(this, "code", 2);
    this.data = data;
    this.name = 'RpcInvalidTransactionError';
  }
}
defineProperty_default()(RpcInvalidTransactionError, "code", 2);
rpcErrors.push(RpcInvalidTransactionError);

/**
 * @category exception
 */
class RpcRejectedByUserError extends RpcError {
  constructor(data) {
    super('Operation rejected by user');
    defineProperty_default()(this, "code", 4);
    this.data = data;
    this.name = 'RpcRejectedByUserError';
  }
}
defineProperty_default()(RpcRejectedByUserError, "code", 4);
rpcErrors.push(RpcRejectedByUserError);

/**
 * @category exception
 */
class RpcUnsupportedProtocolError extends RpcError {
  constructor() {
    super('Unsupported Protocol Version');
    defineProperty_default()(this, "code", 5);
    this.name = 'RpcUnsupportedProtocolError';
  }
}
defineProperty_default()(RpcUnsupportedProtocolError, "code", 5);
rpcErrors.push(RpcUnsupportedProtocolError);

/**
 * @category exception
 */
class RpcConnectionDenyError extends RpcError {
  constructor(data) {
    super('Wallet deny your connection request');
    defineProperty_default()(this, "code", 9);
    this.data = data;
    this.name = 'RpcConnectionDenyError';
  }
}
defineProperty_default()(RpcConnectionDenyError, "code", 9);
rpcErrors.push(RpcConnectionDenyError);

/**
 * @category exception
 */
class RpcNotAuthorizeError extends RpcError {
  constructor() {
    super('You are not connected to the wallet');
    defineProperty_default()(this, "code", 10);
    this.name = 'RpcNotAuthorizeError';
  }
}
defineProperty_default()(RpcNotAuthorizeError, "code", 10);
rpcErrors.push(RpcNotAuthorizeError);

/**
 * @category exception
 */
class RpcPermissionDenyError extends RpcError {
  constructor(address) {
    super(`You are not subscribed for account ${address}`);
    defineProperty_default()(this, "code", 11);
    this.data = address;
    this.name = 'RpcPermissionDenyError';
  }
}
defineProperty_default()(RpcPermissionDenyError, "code", 11);
rpcErrors.push(RpcPermissionDenyError);

/**
 * @category exception
 */
class RpcInternalError extends RpcError {
  constructor() {
    super('The peer failed to execute your request due to unknown error');
    defineProperty_default()(this, "code", 12);
    this.name = 'RpcInternalError';
  }
}
defineProperty_default()(RpcInternalError, "code", 12);
rpcErrors.push(RpcInternalError);

/**
 * @category exception
 */
class RpcNoNetworkById extends RpcError {
  constructor(networkId) {
    super(`Wallet can't find a network by id "${networkId}"`);
    defineProperty_default()(this, "code", 13);
    this.data = networkId;
    this.name = 'RpcNoNetworkById';
  }
}
defineProperty_default()(RpcNoNetworkById, "code", 13);
rpcErrors.push(RpcNoNetworkById);

/**
 * @category exception
 */
class RpcMethodNotFoundError extends RpcError {
  constructor() {
    super('Method not found');
    defineProperty_default()(this, "code", -32601);
    this.name = 'RpcMethodNotFoundError';
  }
}
defineProperty_default()(RpcMethodNotFoundError, "code", -32601);
rpcErrors.push(RpcMethodNotFoundError);
;// ./src/account/Rpc.ts




/**
 * Account provided by wallet
 * @param params - Params
 * @param params.rpcClient - RpcClient instance
 * @param params.address - RPC account address
 * @returns AccountRpc instance
 * @category account
 */
class AccountRpc extends AccountBase {
  constructor(rpcClient, address) {
    super();
    this._rpcClient = rpcClient;
    this.address = address;
  }

  /**
   * @deprecated Use `unsafeSign` method instead
   */
  async sign(dataRaw) {
    return this.unsafeSign(dataRaw);
  }
  async unsafeSign(dataRaw) {
    const data = encode(Buffer.from(dataRaw), Encoding.Bytearray);
    const {
      signature
    } = await this._rpcClient.request(METHODS.unsafeSign, {
      onAccount: this.address,
      data
    });
    return decode(signature);
  }
  async signTransaction(tx, {
    innerTx,
    networkId
  } = {}) {
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    const res = await this._rpcClient.request(METHODS.sign, {
      onAccount: this.address,
      tx,
      returnSigned: true,
      networkId,
      innerTx
    });
    if (res.signedTransaction == null) {
      throw new UnsupportedProtocolError('signedTransaction is missed in wallet response');
    }
    return res.signedTransaction;
  }
  async signMessage(message) {
    const {
      signature
    } = await this._rpcClient.request(METHODS.signMessage, {
      onAccount: this.address,
      message
    });
    return Buffer.from(signature, 'hex');
  }
  async signTypedData(data, aci, {
    name,
    version,
    contractAddress,
    networkId
  } = {}) {
    const {
      signature
    } = await this._rpcClient.request(METHODS.signTypedData, {
      onAccount: this.address,
      domain: {
        name,
        version,
        networkId,
        contractAddress
      },
      aci,
      data
    });
    return signature;
  }
  async signDelegation(delegation) {
    const {
      signature
    } = await this._rpcClient.request(METHODS.signDelegation, {
      delegation,
      onAccount: this.address
    });
    return signature;
  }
}
;// ./src/aepp-wallet-communication/rpc/types.ts

const RPC_VERSION = 1;
;// ./src/aepp-wallet-communication/rpc/RpcClient.ts
function RpcClient_classPrivateMethodInitSpec(e, a) { RpcClient_checkPrivateRedeclaration(e, a), a.add(e); }
function RpcClient_classPrivateFieldInitSpec(e, t, a) { RpcClient_checkPrivateRedeclaration(e, t), t.set(e, a); }
function RpcClient_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function RpcClient_classPrivateFieldGet(s, a) { return s.get(RpcClient_assertClassBrand(s, a)); }
function RpcClient_classPrivateFieldSet(s, a, r) { return s.set(RpcClient_assertClassBrand(s, a), r), r; }
function RpcClient_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }



var _callbacks = /*#__PURE__*/new WeakMap();
var _messageId = /*#__PURE__*/new WeakMap();
var _methods = /*#__PURE__*/new WeakMap();
var _RpcClient_brand = /*#__PURE__*/new WeakSet();
/**
 * Contain functionality for using RPC conection
 * @category aepp wallet communication
 * @param connection - Connection object
 * @param onDisconnect - Disconnect callback
 * @param methods - Object containing handlers for each request by name
 */
class RpcClient {
  constructor(connection, onDisconnect, methods) {
    RpcClient_classPrivateMethodInitSpec(this, _RpcClient_brand);
    RpcClient_classPrivateFieldInitSpec(this, _callbacks, new Map());
    RpcClient_classPrivateFieldInitSpec(this, _messageId, 0);
    RpcClient_classPrivateFieldInitSpec(this, _methods, void 0);
    this.connection = connection;
    RpcClient_classPrivateFieldSet(_methods, this, methods);
    connection.connect(RpcClient_assertClassBrand(_RpcClient_brand, this, _handleMessage).bind(this), onDisconnect);
  }
  /**
   * Make a request
   * @param name - Method name
   * @param params - Method params
   * @returns Promise which will be resolved after receiving response message
   */
  async request(name, params) {
    RpcClient_assertClassBrand(_RpcClient_brand, this, _sendRequest).call(this, RpcClient_classPrivateFieldSet(_messageId, this, RpcClient_classPrivateFieldGet(_messageId, this) + 1), name, params);
    return new Promise((resolve, reject) => {
      RpcClient_classPrivateFieldGet(_callbacks, this).set(RpcClient_classPrivateFieldGet(_messageId, this), {
        resolve,
        reject
      });
    });
  }

  /**
   * Make a notification
   * @param name - Method name
   * @param params - Method params
   */
  notify(name, params) {
    RpcClient_assertClassBrand(_RpcClient_brand, this, _sendRequest).call(this, undefined, name, params);
  }

  /**
   * Process response message
   * @param msg - Message object
   */
}
async function _handleMessage(msg, origin) {
  if (msg?.jsonrpc !== '2.0') throw new InvalidRpcMessageError(JSON.stringify(msg));
  if ('result' in msg || 'error' in msg) {
    RpcClient_assertClassBrand(_RpcClient_brand, this, _processResponse).call(this, msg);
    return;
  }
  const request = msg;
  let result;
  let error;
  try {
    if (!(request.method in RpcClient_classPrivateFieldGet(_methods, this))) throw new RpcMethodNotFoundError();
    const methodName = request.method;
    result = await RpcClient_classPrivateFieldGet(_methods, this)[methodName](request.params, origin);
  } catch (e) {
    ensureError(e);
    error = e;
  }
  if (request.id != null) {
    RpcClient_assertClassBrand(_RpcClient_brand, this, _sendResponse).call(this, request.id, request.method, result, error == null || error instanceof RpcError ? error : new RpcInternalError());
  }
  if (error != null && !(error instanceof RpcError)) throw error;
}
function _sendRequest(id, method, params) {
  this.connection.sendMessage({
    jsonrpc: '2.0',
    ...(id != null ? {
      id
    } : {}),
    method,
    ...(params != null ? {
      params
    } : {})
  });
}
function _sendResponse(id, method,
// TODO: remove as far it is not required in JSON RPC
result, error) {
  this.connection.sendMessage({
    jsonrpc: '2.0',
    id,
    method,
    ...(error != null ? {
      error: error.toJSON()
    } : {
      result
    })
  });
}
function _processResponse({
  id,
  error,
  result
}) {
  const callbacks = RpcClient_classPrivateFieldGet(_callbacks, this).get(id);
  if (callbacks == null) throw new MissingCallbackError(id);
  if (error != null) callbacks.reject(RpcError.deserialize(error));else callbacks.resolve(result);
  RpcClient_classPrivateFieldGet(_callbacks, this).delete(id);
}
;// ./src/AeSdkAepp.ts








/**
 * RPC handler for AEPP side
 * Contain functionality for wallet interaction and connect it to sdk
 * @deprecated use WalletConnectorFrame instead
 * @category aepp wallet communication
 */
class AeSdkAepp extends AeSdkBase {
  /**
   * @param options - Options
   * @param options.name - Aepp name
   * @param options.onAddressChange - Call-back function for update address event
   * @param options.onDisconnect - Call-back function for disconnect event
   * @param options.onNetworkChange - Call-back function for update network event
   */
  constructor({
    name,
    onAddressChange = () => {},
    onDisconnect = () => {},
    onNetworkChange = () => {},
    ...other
  }) {
    super(other);
    this.onAddressChange = onAddressChange;
    this.onDisconnect = onDisconnect;
    this.onNetworkChange = onNetworkChange;
    this.name = name;
  }
  _resolveAccount(account = this.addresses()[0]) {
    if (typeof account === 'string') {
      const address = account;
      decode(address);
      if (!this.addresses().includes(address)) throw new UnAuthorizedAccountError(address);
      this._ensureConnected();
      account = new AccountRpc(this.rpcClient, address);
    }
    if (account == null) this._ensureAccountAccess();
    return super._resolveAccount(account);
  }
  addresses() {
    if (this._accounts == null) return [];
    const current = Object.keys(this._accounts.current)[0];
    return [...(current != null ? [current] : []), ...Object.keys(this._accounts.connected)];
  }

  /**
   * Connect to wallet
   * @param connection - Wallet connection object
   * @param options - Options
   * @param options.connectNode - Request wallet to bind node
   * @param options.name - Node name
   */
  async connectToWallet(connection, {
    connectNode = false,
    name = 'wallet-node'
  } = {}) {
    if (this.rpcClient != null) throw new AlreadyConnectedError('You are already connected to wallet');
    let disconnectParams;
    const updateNetwork = params => {
      if (connectNode) {
        if (params.node?.url == null) throw new RpcConnectionError('Missing URLs of the Node');
        this.pool.delete(name);
        this.addNode(name, new Node(params.node.url), true);
      }
      this.onNetworkChange(params);
    };
    const client = new RpcClient(connection, () => {
      delete this.rpcClient;
      delete this._accounts;
      this.onDisconnect(disconnectParams);
    }, {
      [METHODS.updateAddress]: params => {
        this._accounts = params;
        this.onAddressChange(params);
      },
      [METHODS.updateNetwork]: updateNetwork,
      [METHODS.closeConnection]: params => {
        disconnectParams = params;
        client.connection.disconnect();
      },
      [METHODS.readyToConnect]: () => {}
    });
    const walletInfo = await client.request(METHODS.connect, {
      name: this.name,
      version: RPC_VERSION,
      connectNode
    });
    updateNetwork(walletInfo);
    this.rpcClient = client;
    return walletInfo;
  }

  /**
   * Disconnect from wallet
   */
  disconnectWallet() {
    this._ensureConnected();
    this.rpcClient.notify(METHODS.closeConnection, {
      reason: 'bye'
    });
    this.rpcClient.connection.disconnect();
  }

  /**
   * Ask addresses from wallet
   * @returns Addresses from wallet
   */
  async askAddresses() {
    this._ensureConnected();
    return this.rpcClient.request(METHODS.address, undefined);
  }

  /**
   * Subscribe for addresses from wallet
   * @param type - Subscription type
   * @param value - Should be one of 'current' (the selected account), 'connected' (all)
   * @returns Accounts from wallet
   */
  async subscribeAddress(type, value) {
    this._ensureConnected();
    const result = await this.rpcClient.request(METHODS.subscribeAddress, {
      type,
      value
    });
    this._accounts = result.address;
    return result;
  }

  /**
   * Ask wallet to select a network
   */
  async askToSelectNetwork(network) {
    this._ensureConnected();
    await this.rpcClient.request(METHODS.updateNetwork, network);
  }
  _ensureConnected() {
    if (this.rpcClient != null) return;
    throw new NoWalletConnectedError('You are not connected to Wallet');
  }
  _ensureAccountAccess() {
    this._ensureConnected();
    if (this.addresses().length !== 0) return;
    throw new UnsubscribedAccountError();
  }
}
// EXTERNAL MODULE: external "eventemitter3"
var external_eventemitter3_ = __webpack_require__(1891);
;// ./src/aepp-wallet-communication/WalletConnectorFrameBase.ts
function WalletConnectorFrameBase_classPrivateMethodInitSpec(e, a) { WalletConnectorFrameBase_checkPrivateRedeclaration(e, a), a.add(e); }
function WalletConnectorFrameBase_classPrivateFieldInitSpec(e, t, a) { WalletConnectorFrameBase_checkPrivateRedeclaration(e, t), t.set(e, a); }
function WalletConnectorFrameBase_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function WalletConnectorFrameBase_classPrivateFieldSet(s, a, r) { return s.set(WalletConnectorFrameBase_assertClassBrand(s, a), r), r; }
function WalletConnectorFrameBase_classPrivateFieldGet(s, a) { return s.get(WalletConnectorFrameBase_assertClassBrand(s, a)); }
function WalletConnectorFrameBase_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }






var _rpcClient = /*#__PURE__*/new WeakMap();
var _WalletConnectorFrameBase_brand = /*#__PURE__*/new WeakSet();
var _accounts = /*#__PURE__*/new WeakMap();
class WalletConnectorFrameBase extends external_eventemitter3_.EventEmitter {
  /**
   * Is connected to wallet
   */
  get isConnected() {
    return WalletConnectorFrameBase_classPrivateFieldGet(_rpcClient, this) != null;
  }
  /**
   * Accounts provided by wallet over subscription
   */
  get accounts() {
    return WalletConnectorFrameBase_classPrivateFieldGet(_accounts, this);
  }
  constructor() {
    super();
    WalletConnectorFrameBase_classPrivateMethodInitSpec(this, _WalletConnectorFrameBase_brand);
    WalletConnectorFrameBase_classPrivateFieldInitSpec(this, _rpcClient, void 0);
    WalletConnectorFrameBase_classPrivateFieldInitSpec(this, _accounts, []);
  }
  static async _connect(name, connection, connector, connectNode) {
    let disconnectParams;
    const client = new RpcClient(connection, () => {
      WalletConnectorFrameBase_classPrivateFieldSet(_rpcClient, connector, undefined);
      WalletConnectorFrameBase_classPrivateFieldSet(_accounts, connector, []);
      connector.emit('disconnect', disconnectParams);
    }, {
      [METHODS.updateAddress]: WalletConnectorFrameBase_assertClassBrand(_WalletConnectorFrameBase_brand, connector, _updateAccounts).bind(connector),
      [METHODS.updateNetwork]: connector._updateNetwork.bind(connector),
      [METHODS.closeConnection]: params => {
        disconnectParams = params;
        client.connection.disconnect();
      },
      [METHODS.readyToConnect]: () => {}
    });
    WalletConnectorFrameBase_classPrivateFieldSet(_rpcClient, connector, client);
    const walletInfo = await WalletConnectorFrameBase_classPrivateFieldGet(_rpcClient, connector).request(METHODS.connect, {
      name,
      version: RPC_VERSION,
      connectNode
    });
    connector._updateNetwork(walletInfo);
  }

  /**
   * Disconnect from wallet
   */
  disconnect() {
    const client = WalletConnectorFrameBase_assertClassBrand(_WalletConnectorFrameBase_brand, this, _getRpcClient).call(this);
    client.notify(METHODS.closeConnection, {
      reason: 'bye'
    });
    client.connection.disconnect();
  }

  /**
   * Request accounts from wallet
   */
  async getAccounts() {
    const client = WalletConnectorFrameBase_assertClassBrand(_WalletConnectorFrameBase_brand, this, _getRpcClient).call(this);
    const addresses = await client.request(METHODS.address, undefined);
    return addresses.map(address => new AccountRpc(client, address));
  }

  /**
   * Subscribe for wallet accounts, get account updates adding handler to `accountsChange` event
   * @param type - Subscription type
   * @param value - Should be one of 'current' (the selected account), 'connected' (all)
   * @returns Accounts from wallet
   */
  async subscribeAccounts(type, value) {
    const result = await WalletConnectorFrameBase_assertClassBrand(_WalletConnectorFrameBase_brand, this, _getRpcClient).call(this).request(METHODS.subscribeAddress, {
      type,
      value
    });
    WalletConnectorFrameBase_assertClassBrand(_WalletConnectorFrameBase_brand, this, _updateAccounts).call(this, result.address);
    return WalletConnectorFrameBase_classPrivateFieldGet(_accounts, this);
  }

  /**
   * Ask wallet to select a network
   */
  async askToSelectNetwork(network) {
    await WalletConnectorFrameBase_assertClassBrand(_WalletConnectorFrameBase_brand, this, _getRpcClient).call(this).request(METHODS.updateNetwork, network);
  }
}
function _getRpcClient() {
  if (WalletConnectorFrameBase_classPrivateFieldGet(_rpcClient, this) == null) throw new NoWalletConnectedError('You are not connected to Wallet');
  return WalletConnectorFrameBase_classPrivateFieldGet(_rpcClient, this);
}
function _updateAccounts(params) {
  const addresses = [...new Set([...Object.keys(params.current), ...Object.keys(params.connected)])];
  WalletConnectorFrameBase_classPrivateFieldSet(_accounts, this, addresses.map(address => new AccountRpc(WalletConnectorFrameBase_assertClassBrand(_WalletConnectorFrameBase_brand, this, _getRpcClient).call(this), address)));
  this.emit('accountsChange', WalletConnectorFrameBase_classPrivateFieldGet(_accounts, this));
}
;// ./src/aepp-wallet-communication/WalletConnectorFrame.ts
function WalletConnectorFrame_classPrivateFieldInitSpec(e, t, a) { WalletConnectorFrame_checkPrivateRedeclaration(e, t), t.set(e, a); }
function WalletConnectorFrame_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function WalletConnectorFrame_classPrivateFieldSet(s, a, r) { return s.set(WalletConnectorFrame_assertClassBrand(s, a), r), r; }
function WalletConnectorFrame_classPrivateFieldGet(s, a) { return s.get(WalletConnectorFrame_assertClassBrand(s, a)); }
function WalletConnectorFrame_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }

var _networkId = /*#__PURE__*/new WeakMap();
/**
 * Connect to wallet as iframe/web-extension
 * @category aepp wallet communication
 */
class WalletConnectorFrame extends WalletConnectorFrameBase {
  constructor(...args) {
    super(...args);
    WalletConnectorFrame_classPrivateFieldInitSpec(this, _networkId, '');
  }
  /**
   * The last network id reported by wallet
   */
  get networkId() {
    return WalletConnectorFrame_classPrivateFieldGet(_networkId, this);
  }
  _updateNetwork(params) {
    WalletConnectorFrame_classPrivateFieldSet(_networkId, this, params.networkId);
    this.emit('networkIdChange', WalletConnectorFrame_classPrivateFieldGet(_networkId, this));
  }

  /**
   * Connect to wallet
   * @param name - Aepp name
   * @param connection - Wallet connection object
   */
  static async connect(name, connection) {
    const connector = new WalletConnectorFrame();
    await WalletConnectorFrame._connect(name, connection, connector, false);
    return connector;
  }
}
;// ./src/aepp-wallet-communication/WalletConnectorFrameWithNode.ts
function WalletConnectorFrameWithNode_classPrivateFieldInitSpec(e, t, a) { WalletConnectorFrameWithNode_checkPrivateRedeclaration(e, t), t.set(e, a); }
function WalletConnectorFrameWithNode_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function WalletConnectorFrameWithNode_classPrivateFieldSet(s, a, r) { return s.set(WalletConnectorFrameWithNode_assertClassBrand(s, a), r), r; }
function WalletConnectorFrameWithNode_classPrivateFieldGet(s, a) { return s.get(WalletConnectorFrameWithNode_assertClassBrand(s, a)); }
function WalletConnectorFrameWithNode_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }



var _node = /*#__PURE__*/new WeakMap();
/**
 * Connect to wallet as iframe/web-extension, asks wallet to provide node url
 * In comparison with WalletConnectorFrame, this would work better for decentralized applications
 * @category aepp wallet communication
 */
class WalletConnectorFrameWithNode extends WalletConnectorFrameBase {
  constructor(...args) {
    super(...args);
    WalletConnectorFrameWithNode_classPrivateFieldInitSpec(this, _node, null);
  }
  /**
   * The node instance provided by wallet
   */
  get node() {
    return WalletConnectorFrameWithNode_classPrivateFieldGet(_node, this);
  }
  _updateNetwork(params) {
    if (params.node?.url == null) throw new RpcConnectionError('Missing URLs of the Node');
    WalletConnectorFrameWithNode_classPrivateFieldSet(_node, this, new Node(params.node.url));
    this.emit('nodeChange', WalletConnectorFrameWithNode_classPrivateFieldGet(_node, this));
  }

  /**
   * Connect to wallet
   * @param name - Aepp name
   * @param connection - Wallet connection object
   */
  static async connect(name, connection) {
    const connector = new WalletConnectorFrameWithNode();
    await super._connect(name, connection, connector, true);
    return connector;
  }
}
// EXTERNAL MODULE: external "json-bigint"
var external_json_bigint_ = __webpack_require__(4146);
var external_json_bigint_default = /*#__PURE__*/__webpack_require__.n(external_json_bigint_);
;// ./src/utils/json-big.ts



const jsonBig = external_json_bigint_default()({
  storeAsString: true
});
const convertValuesToBigNumbers = value => {
  if (typeof value === 'object' && value !== null && value.constructor === Object) {
    return mapObject(value, ([k, v]) => [k, convertValuesToBigNumbers(v)]);
  }
  if (Array.isArray(value)) {
    return value.map(item => convertValuesToBigNumbers(item));
  }
  if (typeof value === 'string' && new (external_bignumber_js_default())(value).toString(10) === value) {
    const bn = new (external_bignumber_js_default())(value);
    bn.toJSON = () => bn.toString(10);
    return bn;
  }
  return value;
};
/* harmony default export */ const json_big = ({
  stringify: (...args) => jsonBig.stringify(convertValuesToBigNumbers(args[0]), ...args.slice(1)),
  parse: jsonBig.parse
});
;// ./src/AeSdkWallet.ts










/**
 * Contain functionality for aepp interaction and managing multiple aepps
 * @category aepp wallet communication
 */
class AeSdkWallet extends AeSdk {
  /**
   * @param options - Options
   * @param options.name - Wallet name
   * @param options.id - Wallet id
   * @param options.type - Wallet type
   * @param options.onConnection - Call-back function for incoming AEPP connection
   * @param options.onSubscription - Call-back function for incoming AEPP account subscription
   * @param options.onAskAccounts - Call-back function for incoming AEPP get address request
   * @param options.onAskToSelectNetwork - Call-back function for incoming AEPP select network
   * request. If the request is fine then this function should change the current network.
   * @param options.onDisconnect - Call-back function for disconnect event
   */
  constructor({
    name,
    id,
    type,
    onConnection,
    onSubscription,
    onDisconnect,
    onAskAccounts,
    onAskToSelectNetwork,
    ...options
  }) {
    super(options);
    defineProperty_default()(this, "_clients", new Map());
    this.onConnection = onConnection;
    this.onSubscription = onSubscription;
    this.onDisconnect = onDisconnect;
    this.onAskAccounts = onAskAccounts;
    this.onAskToSelectNetwork = onAskToSelectNetwork;
    this.name = name;
    this.id = id;
    this._type = type;
  }
  _getAccountsForClient({
    addressSubscription
  }) {
    const {
      current,
      connected
    } = this.getAccounts();
    return {
      current: addressSubscription.has('current') || addressSubscription.has('connected') ? current : {},
      connected: addressSubscription.has('connected') ? connected : {}
    };
  }
  _pushAccountsToApps() {
    if (this._clients == null) return;
    Array.from(this._clients.keys()).filter(clientId => this._isRpcClientConnected(clientId)).map(clientId => this._getClient(clientId)).filter(client => client.addressSubscription.size !== 0).forEach(client => client.rpc.notify(METHODS.updateAddress, this._getAccountsForClient(client)));
  }
  selectAccount(address) {
    super.selectAccount(address);
    this._pushAccountsToApps();
  }
  addAccount(account, options) {
    super.addAccount(account, options);
    this._pushAccountsToApps();
  }
  _getNode() {
    this.ensureNodeConnected();
    return {
      node: {
        url: this.api.$host,
        name: this.selectedNodeName
      }
    };
  }
  async selectNode(name) {
    super.selectNode(name);
    const networkId = await this.api.getNetworkId();
    Array.from(this._clients.keys()).filter(clientId => this._isRpcClientConnected(clientId)).map(clientId => this._getClient(clientId)).forEach(client => {
      client.rpc.notify(METHODS.updateNetwork, {
        networkId,
        ...(client.connectNode && this._getNode())
      });
    });
  }
  _getClient(clientId) {
    const client = this._clients.get(clientId);
    if (client == null) throw new UnknownRpcClientError(clientId);
    return client;
  }
  _isRpcClientConnected(clientId) {
    return RPC_STATUS.CONNECTED === this._getClient(clientId).status && this._getClient(clientId).rpc.connection.isConnected();
  }
  _disconnectRpcClient(clientId) {
    const client = this._getClient(clientId);
    client.rpc.connection.disconnect();
    client.status = RPC_STATUS.DISCONNECTED;
    client.addressSubscription = new Set();
  }

  /**
   * Remove specific RpcClient by ID
   * @param id - Client ID
   */
  removeRpcClient(id) {
    this._disconnectRpcClient(id);
    this._clients.delete(id);
  }

  /**
   * Add new client by AEPP connection
   * @param clientConnection - AEPP connection object
   * @returns Client ID
   */
  addRpcClient(clientConnection) {
    // @TODO  detect if aepp has some history based on origin????
    // if yes use this instance for connection
    const id = Buffer.from(external_tweetnacl_default().randomBytes(8)).toString('base64');
    let disconnectParams;
    const client = {
      id,
      status: RPC_STATUS.WAITING_FOR_CONNECTION_REQUEST,
      addressSubscription: new Set(),
      connectNode: false,
      rpc: new RpcClient(clientConnection, () => {
        this._clients.delete(id);
        this.onDisconnect(id, disconnectParams); // also related info
      }, {
        [METHODS.closeConnection]: params => {
          disconnectParams = params;
          this._disconnectRpcClient(id);
        },
        // Store client info and prepare two fn for each client `connect` and `denyConnection`
        // which automatically prepare and send response for that client
        [METHODS.connect]: async ({
          name,
          version,
          icons,
          connectNode
        }, origin) => {
          if (version !== RPC_VERSION) throw new RpcUnsupportedProtocolError();
          await this.onConnection(id, {
            name,
            icons,
            connectNode
          }, origin);
          client.status = RPC_STATUS.CONNECTED;
          client.connectNode = connectNode;
          return {
            ...(await this.getWalletInfo()),
            ...(connectNode && this._getNode())
          };
        },
        [METHODS.subscribeAddress]: async ({
          type,
          value
        }, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          switch (type) {
            case SUBSCRIPTION_TYPES.subscribe:
              // TODO: remove `type` as it always subscribe
              await this.onSubscription(id, {
                type,
                value
              }, origin);
              client.addressSubscription.add(value);
              break;
            case SUBSCRIPTION_TYPES.unsubscribe:
              client.addressSubscription.delete(value);
              break;
            default:
              throw new InternalError(`Unknown subscription type: ${type}`);
          }
          return {
            subscription: Array.from(client.addressSubscription),
            address: this._getAccountsForClient(client)
          };
        },
        [METHODS.address]: async (params, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          await this.onAskAccounts(id, params, origin);
          return this.addresses();
        },
        [METHODS.sign]: async ({
          tx,
          onAccount = this.address,
          returnSigned,
          innerTx
        }, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          if (!this.addresses().includes(onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }
          const parameters = {
            onAccount,
            aeppOrigin: origin,
            aeppRpcClientId: id,
            innerTx
          };
          if (returnSigned || innerTx === true) {
            return {
              signedTransaction: await this.signTransaction(tx, parameters)
            };
          }
          try {
            return json_big.parse(json_big.stringify({
              transactionHash: await this.sendTransaction(tx, {
                ...parameters,
                verify: false
              })
            }));
          } catch (error) {
            const validation = await verifyTransaction(tx, this.api);
            if (validation.length > 0) throw new RpcInvalidTransactionError(validation);
            throw error;
          }
        },
        [METHODS.signMessage]: async ({
          message,
          onAccount = this.address
        }, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          if (!this.addresses().includes(onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }
          const parameters = {
            onAccount,
            aeppOrigin: origin,
            aeppRpcClientId: id
          };
          return {
            signature: Buffer.from(await this.signMessage(message, parameters)).toString('hex')
          };
        },
        [METHODS.signTypedData]: async ({
          domain,
          aci,
          data,
          onAccount = this.address
        }, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          if (!this.addresses().includes(onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }
          const parameters = {
            ...domain,
            onAccount,
            aeppOrigin: origin,
            aeppRpcClientId: id
          };
          return {
            signature: await this.signTypedData(data, aci, parameters)
          };
        },
        [METHODS.unsafeSign]: async ({
          data,
          onAccount = this.address
        }, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          if (!this.addresses().includes(onAccount)) throw new RpcPermissionDenyError(onAccount);
          const parameters = {
            onAccount,
            aeppOrigin: origin,
            aeppRpcClientId: id
          };
          const signature = encode(await this.unsafeSign(decode(data), parameters), Encoding.Signature);
          return {
            signature
          };
        },
        [METHODS.signDelegation]: async ({
          delegation,
          onAccount = this.address
        }, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          if (!this.addresses().includes(onAccount)) throw new RpcPermissionDenyError(onAccount);
          const parameters = {
            onAccount,
            aeppOrigin: origin,
            aeppRpcClientId: id
          };
          const signature = await this.signDelegation(delegation, parameters);
          return {
            signature
          };
        },
        [METHODS.updateNetwork]: async (params, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          await this.onAskToSelectNetwork(id, params, origin);
          return null;
        }
      })
    };
    this._clients.set(id, client);
    return id;
  }

  /**
   * Send shareWalletInfo message to notify AEPP about wallet
   * @param clientId - ID of RPC client send message to
   */
  async shareWalletInfo(clientId) {
    this._getClient(clientId).rpc.notify(METHODS.readyToConnect, await this.getWalletInfo());
  }

  /**
   * Get Wallet info object
   * @returns Object with wallet information
   */
  async getWalletInfo() {
    const {
      origin
    } = window.location;
    return {
      id: this.id,
      name: this.name,
      networkId: await this.api.getNetworkId(),
      origin: origin === 'file://' ? '*' : origin,
      type: this._type
    };
  }

  /**
   * Get Wallet accounts
   * @returns Object with accounts information (\{ connected: Object, current: Object \})
   */
  getAccounts() {
    return {
      current: this.selectedAddress != null ? {
        [this.selectedAddress]: {}
      } : {},
      connected: this.addresses().filter(a => a !== this.selectedAddress).reduce((acc, a) => ({
        ...acc,
        [a]: {}
      }), {})
    };
  }
}
// EXTERNAL MODULE: external "@scure/bip39"
var bip39_ = __webpack_require__(8380);
// EXTERNAL MODULE: external "tweetnacl-auth"
var external_tweetnacl_auth_ = __webpack_require__(5196);
var external_tweetnacl_auth_default = /*#__PURE__*/__webpack_require__.n(external_tweetnacl_auth_);
;// ./src/account/BaseFactory.ts
/**
 * A factory class that generates instances of AccountBase by index.
 * @category account
 */
class AccountBaseFactory {
  /**
   * Get an instance of AccountBase for a given account index.
   * @param accountIndex - Index of account
   */

  /**
   * Discovers accounts in set that already have been used (has any on-chain transactions).
   * It returns an empty array if none of accounts been used.
   * If a used account is preceded by an unused account then it would be ignored.
   * @param node - Instance of Node to get account information from
   */
  async discover(node) {
    let index = 0;
    const result = [];
    let account;
    do {
      if (account != null) result.push(account);
      account = await this.initialize(index);
      index += 1;
    } while (await node.getAccountByPubkey(account.address).then(() => true, () => false));
    return result;
  }
}
;// ./src/account/MnemonicFactory.ts
function MnemonicFactory_classPrivateMethodInitSpec(e, a) { MnemonicFactory_checkPrivateRedeclaration(e, a), a.add(e); }
function MnemonicFactory_classPrivateFieldInitSpec(e, t, a) { MnemonicFactory_checkPrivateRedeclaration(e, t), t.set(e, a); }
function MnemonicFactory_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function MnemonicFactory_classPrivateFieldGet(s, a) { return s.get(MnemonicFactory_assertClassBrand(s, a)); }
function MnemonicFactory_classPrivateFieldSet(s, a, r) { return s.set(MnemonicFactory_assertClassBrand(s, a), r), r; }
function MnemonicFactory_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }







const ED25519_CURVE = Buffer.from('ed25519 seed');
const HARDENED_OFFSET = 0x80000000;
function deriveKey(message, key) {
  const I = external_tweetnacl_auth_default().full(message, key);
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    secretKey: IL,
    chainCode: IR
  };
}
function derivePathFromKey(key, segments) {
  return segments.reduce(({
    secretKey,
    chainCode
  }, segment) => {
    const indexBuffer = Buffer.allocUnsafe(4);
    indexBuffer.writeUInt32BE(segment + HARDENED_OFFSET, 0);
    const data = concatBuffers([Buffer.alloc(1, 0), secretKey, indexBuffer]);
    return deriveKey(data, chainCode);
  }, key);
}
var _mnemonicOrWalletOrSeed = /*#__PURE__*/new WeakMap();
var _AccountMnemonicFactory_brand = /*#__PURE__*/new WeakSet();
/**
 * A factory class that generates instances of AccountMemory based on provided mnemonic phrase.
 * @category account
 */
class AccountMnemonicFactory extends AccountBaseFactory {
  /**
   * @param mnemonicOrWalletOrSeed - BIP39-compatible mnemonic phrase or a wallet/seed derived from
   * mnemonic
   */
  constructor(mnemonicOrWalletOrSeed) {
    super();
    MnemonicFactory_classPrivateMethodInitSpec(this, _AccountMnemonicFactory_brand);
    MnemonicFactory_classPrivateFieldInitSpec(this, _mnemonicOrWalletOrSeed, void 0);
    MnemonicFactory_classPrivateFieldSet(_mnemonicOrWalletOrSeed, this, mnemonicOrWalletOrSeed);
  }
  /**
   * Get a wallet to initialize AccountMnemonicFactory instead mnemonic phrase.
   * In comparison with mnemonic, the wallet can be used to derive aeternity accounts only.
   */
  async getWallet() {
    return MnemonicFactory_assertClassBrand(_AccountMnemonicFactory_brand, this, _getWallet).call(this, false);
  }

  /**
   * The same as `getWallet` but synchronous.
   */
  getWalletSync() {
    return MnemonicFactory_assertClassBrand(_AccountMnemonicFactory_brand, this, _getWallet).call(this, true);
  }
  /**
   * Get an instance of AccountMemory for a given account index.
   * @param accountIndex - Index of account
   */
  async initialize(accountIndex) {
    const wallet = await this.getWallet();
    return MnemonicFactory_assertClassBrand(_AccountMnemonicFactory_brand, this, _getAccountByWallet).call(this, accountIndex, wallet);
  }

  /**
   * The same as `initialize` but synchronous.
   */
  initializeSync(accountIndex) {
    const wallet = this.getWalletSync();
    return MnemonicFactory_assertClassBrand(_AccountMnemonicFactory_brand, this, _getAccountByWallet).call(this, accountIndex, wallet);
  }
}
function _getWallet(sync) {
  const setWalletBySeed = seed => {
    const masterKey = deriveKey(seed, ED25519_CURVE);
    const walletKey = derivePathFromKey(masterKey, [44, 457]);
    MnemonicFactory_classPrivateFieldSet(_mnemonicOrWalletOrSeed, this, {
      secretKey: encode(walletKey.secretKey, Encoding.Bytearray),
      chainCode: encode(walletKey.chainCode, Encoding.Bytearray)
    });
    return MnemonicFactory_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this);
  };
  if (ArrayBuffer.isView(MnemonicFactory_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this))) {
    if (MnemonicFactory_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this).length !== 64) {
      throw new ArgumentError('seed length', 64, MnemonicFactory_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this).length);
    }
    return setWalletBySeed(MnemonicFactory_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this));
  }
  if (typeof MnemonicFactory_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this) === 'object') return MnemonicFactory_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this);
  return sync ? setWalletBySeed((0,bip39_.mnemonicToSeedSync)(MnemonicFactory_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this))) : (0,bip39_.mnemonicToSeed)(MnemonicFactory_classPrivateFieldGet(_mnemonicOrWalletOrSeed, this)).then(setWalletBySeed);
}
function _getAccountByWallet(accountIndex, wallet) {
  const walletKey = {
    secretKey: decode(wallet.secretKey),
    chainCode: decode(wallet.chainCode)
  };
  const raw = derivePathFromKey(walletKey, [accountIndex, 0, 0]).secretKey;
  return new AccountMemory(encode(raw, Encoding.AccountSecretKey));
}
;// ./src/account/Generalized.ts
function Generalized_classPrivateFieldInitSpec(e, t, a) { Generalized_checkPrivateRedeclaration(e, t), t.set(e, a); }
function Generalized_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function Generalized_classPrivateFieldSet(s, a, r) { return s.set(Generalized_assertClassBrand(s, a), r), r; }
function Generalized_classPrivateFieldGet(s, a) { return s.get(Generalized_assertClassBrand(s, a)); }
function Generalized_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }








/**
 * Generalized account class
 * @category account generalized
 */
var _authFun = /*#__PURE__*/new WeakMap();
class AccountGeneralized extends AccountBase {
  /**
   * @param address - Address of generalized account
   */
  constructor(address) {
    super();
    Generalized_classPrivateFieldInitSpec(this, _authFun, void 0);
    decode(address);
    this.address = address;
  }

  /**
   * @deprecated Use `unsafeSign` method instead
   */
  // eslint-disable-next-line class-methods-use-this
  async sign() {
    return this.unsafeSign();
  }

  // eslint-disable-next-line class-methods-use-this
  async unsafeSign() {
    throw new NotImplementedError("Can't sign using generalized account");
  }

  // eslint-disable-next-line class-methods-use-this
  async signMessage() {
    throw new NotImplementedError("Can't sign using generalized account");
  }

  // eslint-disable-next-line class-methods-use-this
  async signTypedData() {
    throw new NotImplementedError("Can't sign using generalized account");
  }

  // eslint-disable-next-line class-methods-use-this
  async signDelegation() {
    throw new NotImplementedError('signing delegation using generalized account');
  }
  async signTransaction(tx, {
    authData,
    onCompiler,
    onNode
  }) {
    if (authData == null || onCompiler == null || onNode == null) {
      throw new ArgumentError('authData, onCompiler, onNode', 'provided', null);
    }
    const {
      callData,
      sourceCode,
      args,
      fee,
      gasLimit,
      gasPrice
    } = typeof authData === 'function' ? await authData(tx) : authData;
    const authCallData = callData !== null && callData !== void 0 ? callData : await (async () => {
      if (Generalized_classPrivateFieldGet(_authFun, this) == null) {
        const account = await getAccount(this.address, {
          onNode
        });
        if (account.kind !== 'generalized') {
          throw new ArgumentError('account kind', 'generalized', account.kind);
        }
        Generalized_classPrivateFieldSet(_authFun, this, account.authFun);
      }
      if (Generalized_classPrivateFieldGet(_authFun, this) == null) {
        throw new InternalError('Account in generalised, but authFun not provided');
      }
      if (sourceCode == null || args == null) {
        throw new InvalidAuthDataError('Auth data must contain sourceCode and args or callData.');
      }
      const contract = await contract_Contract.initialize({
        onCompiler,
        onNode,
        sourceCode
      });
      return contract._calldata.encode(contract._name, Generalized_classPrivateFieldGet(_authFun, this), args);
    })();
    const gaMetaTx = await buildTxAsync({
      tag: Tag.GaMetaTx,
      tx: {
        tag: Tag.SignedTx,
        encodedTx: decode(tx),
        signatures: []
      },
      gaId: this.address,
      authData: authCallData,
      fee,
      gasLimit,
      gasPrice,
      onNode
    });
    return buildTx({
      tag: Tag.SignedTx,
      encodedTx: decode(gaMetaTx),
      signatures: []
    });
  }
}
;// ./src/account/Ledger.ts





const CLA = 0xe0;
const GET_ADDRESS = 0x02;
const SIGN_TRANSACTION = 0x04;
const GET_APP_CONFIGURATION = 0x06;
const SIGN_PERSONAL_MESSAGE = 0x08;

/**
 * Ledger wallet account class
 * @category account
 */
class AccountLedger extends AccountBase {
  /**
   * @param transport - Connection to Ledger to use
   * @param index - Index of account
   * @param address - Address of account
   */
  constructor(transport, index, address) {
    super();
    this.transport = transport;
    this.index = index;
    this.address = address;
    transport.decorateAppAPIMethods(this, ['signTransaction', 'signMessage'], 'w0w');
  }

  /**
   * @deprecated Use `unsafeSign` method instead
   */
  // eslint-disable-next-line class-methods-use-this
  async sign() {
    return this.unsafeSign();
  }

  // eslint-disable-next-line class-methods-use-this
  async unsafeSign() {
    throw new NotImplementedError('RAW signing using Ledger HW');
  }

  // eslint-disable-next-line class-methods-use-this
  async signTypedData() {
    throw new NotImplementedError('Typed data signing using Ledger HW');
  }

  // eslint-disable-next-line class-methods-use-this
  async signDelegation() {
    throw new NotImplementedError('signing delegation using Ledger HW');
  }
  async signTransaction(tx, {
    innerTx,
    networkId
  } = {}) {
    if (innerTx != null) throw new NotImplementedError('innerTx option in AccountLedger');
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    const rawTx = decode(tx);
    let offset = 0;
    const headerLength = 4 + 1 + 4;
    const networkIdBuffer = Buffer.from(networkId);
    const toSend = [];
    while (offset !== rawTx.length) {
      const maxChunkSize = offset === 0 ? 150 - headerLength - networkIdBuffer.length : 150;
      const chunkSize = offset + maxChunkSize > rawTx.length ? rawTx.length - offset : maxChunkSize;
      const buffer = Buffer.alloc(offset === 0 ? headerLength + networkIdBuffer.length + chunkSize : chunkSize);
      if (offset === 0) {
        let bufferOffset = buffer.writeUInt32BE(this.index, 0);
        bufferOffset = buffer.writeUInt32BE(rawTx.length, bufferOffset);
        bufferOffset = buffer.writeUInt8(networkIdBuffer.length, bufferOffset);
        bufferOffset += networkIdBuffer.copy(buffer, bufferOffset, 0, networkIdBuffer.length);
        rawTx.copy(buffer, bufferOffset, 0, 150 - bufferOffset);
      } else {
        rawTx.copy(buffer, 0, offset, offset + chunkSize);
      }
      toSend.push(buffer);
      offset += chunkSize;
    }
    const response = await toSend.reduce(async (previous, data, i) => {
      await previous;
      return this.transport.send(CLA, SIGN_TRANSACTION, i === 0 ? 0x00 : 0x80, 0x00, data);
    }, Promise.resolve(Buffer.alloc(0)));
    const signatures = [response.subarray(0, 64)];
    return buildTx({
      tag: Tag.SignedTx,
      encodedTx: rawTx,
      signatures
    });
  }
  async signMessage(messageStr) {
    let offset = 0;
    const message = Buffer.from(messageStr);
    const toSend = [];
    while (offset !== message.length) {
      const maxChunkSize = offset === 0 ? 150 - 4 - 4 : 150;
      const chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;
      const buffer = Buffer.alloc(offset === 0 ? 4 + 4 + chunkSize : chunkSize);
      if (offset === 0) {
        buffer.writeUInt32BE(this.index, 0);
        buffer.writeUInt32BE(message.length, 4);
        message.copy(buffer, 4 + 4, offset, offset + chunkSize);
      } else {
        message.copy(buffer, 0, offset, offset + chunkSize);
      }
      toSend.push(buffer);
      offset += chunkSize;
    }
    const response = await toSend.reduce(async (previous, data, i) => {
      await previous;
      return this.transport.send(CLA, SIGN_PERSONAL_MESSAGE, i === 0 ? 0x00 : 0x80, 0x00, data);
    }, Promise.resolve(Buffer.alloc(0)));
    return response.subarray(0, 64);
  }
}
;// ./src/account/LedgerFactory.ts

function LedgerFactory_classPrivateMethodInitSpec(e, a) { LedgerFactory_checkPrivateRedeclaration(e, a), a.add(e); }
function LedgerFactory_classPrivateFieldInitSpec(e, t, a) { LedgerFactory_checkPrivateRedeclaration(e, t), t.set(e, a); }
function LedgerFactory_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function LedgerFactory_classPrivateFieldGet(s, a) { return s.get(LedgerFactory_assertClassBrand(s, a)); }
function LedgerFactory_classPrivateFieldSet(s, a, r) { return s.set(LedgerFactory_assertClassBrand(s, a), r), r; }
function LedgerFactory_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }




var _ensureReadyPromise = /*#__PURE__*/new WeakMap();
var _AccountLedgerFactory_brand = /*#__PURE__*/new WeakSet();
/**
 * A factory class that generates instances of AccountLedger based on provided transport.
 * @category account
 */
class AccountLedgerFactory extends AccountBaseFactory {
  /**
   * @param transport - Connection to Ledger to use
   */
  constructor(transport) {
    super();
    LedgerFactory_classPrivateMethodInitSpec(this, _AccountLedgerFactory_brand);
    LedgerFactory_classPrivateFieldInitSpec(this, _ensureReadyPromise, void 0);
    // TODO: remove after release Ledger app v1.0.0
    defineProperty_default()(this, "_enableExperimentalLedgerAppSupport", false);
    this.transport = transport;
    transport.decorateAppAPIMethods(this, ['getAddress', 'getAppConfiguration'], 'w0w');
  }
  /**
   * It throws an exception if Aeternity app on Ledger has an incompatible version, not opened or
   * not installed.
   */
  async ensureReady() {
    const {
      version
    } = await LedgerFactory_assertClassBrand(_AccountLedgerFactory_brand, this, _getAppConfiguration).call(this);
    const oldApp = [version, '0.4.4', '0.5.0'];
    const newApp = [version, '1.0.0', '2.0.0'];
    if (!semverSatisfies(...oldApp) && (!this._enableExperimentalLedgerAppSupport || !semverSatisfies(...newApp))) throw new UnsupportedVersionError('Aeternity app on Ledger', ...oldApp);
    LedgerFactory_classPrivateFieldSet(_ensureReadyPromise, this, Promise.resolve());
  }
  /**
   * @returns the version of Aeternity app installed on Ledger wallet
   */
  async getAppConfiguration() {
    return LedgerFactory_assertClassBrand(_AccountLedgerFactory_brand, this, _getAppConfiguration).call(this);
  }

  /**
   * Get `ak_`-prefixed address for a given account index.
   * @param accountIndex - Index of account
   * @param verify - Ask user to confirm address by showing it on the device screen
   */
  async getAddress(accountIndex, verify = false) {
    await LedgerFactory_assertClassBrand(_AccountLedgerFactory_brand, this, _ensureReady).call(this);
    const buffer = Buffer.alloc(4);
    buffer.writeUInt32BE(accountIndex, 0);
    const response = await this.transport.send(CLA, GET_ADDRESS, verify ? 0x01 : 0x00, 0x00, buffer);
    const addressLength = response[0];
    return response.subarray(1, 1 + addressLength).toString('ascii');
  }

  /**
   * Get an instance of AccountLedger for a given account index.
   * @param accountIndex - Index of account
   */
  async initialize(accountIndex) {
    return new AccountLedger(this.transport, accountIndex, await this.getAddress(accountIndex));
  }
}
async function _ensureReady() {
  var _classPrivateFieldGet2;
  (_classPrivateFieldGet2 = LedgerFactory_classPrivateFieldGet(_ensureReadyPromise, this)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : LedgerFactory_classPrivateFieldSet(_ensureReadyPromise, this, this.ensureReady());
  return LedgerFactory_classPrivateFieldGet(_ensureReadyPromise, this);
}
async function _getAppConfiguration() {
  let response = await this.transport.send(CLA, GET_APP_CONFIGURATION, 0x00, 0x00);
  if (response.length === 6) response = response.subarray(1);
  return {
    version: [response[0], response[1], response[2]].join('.')
  };
}
;// ./src/account/Metamask.ts


const snapId = 'npm:@aeternity-snap/plugin';
async function invokeSnap(provider, method, params, key) {
  const response = await provider.request({
    method: 'wallet_invokeSnap',
    params: {
      snapId,
      request: {
        method,
        params
      }
    }
  });
  if (response == null) throw new InternalError('Empty MetaMask response');
  if (!(key in response)) {
    throw new InternalError(`Key ${key} missed in response ${JSON.stringify(response)}`);
  }
  return response[key];
}

/**
 * Account connected to Aeternity Snap for MetaMask
 * https://www.npmjs.com/package/\@aeternity-snap/plugin
 * @category account
 */
class AccountMetamask extends AccountBase {
  /**
   * @deprecated this class is not intended to provide raw access to the provider
   */

  /**
   * @param address - Address of account
   */
  constructor(provider, index, address) {
    super();
    this.provider = provider;
    this.index = index;
    this.address = address;
  }

  /**
   * @deprecated Use `unsafeSign` method instead
   */
  // eslint-disable-next-line class-methods-use-this
  async sign() {
    return this.unsafeSign();
  }

  // eslint-disable-next-line class-methods-use-this
  async unsafeSign() {
    throw new NotImplementedError('RAW signing using MetaMask');
  }

  // eslint-disable-next-line class-methods-use-this
  async signTypedData() {
    throw new NotImplementedError('Typed data signing using MetaMask');
  }

  // eslint-disable-next-line class-methods-use-this
  async signDelegation() {
    throw new NotImplementedError('signing delegation using MetaMask');
  }

  // eslint-disable-next-line class-methods-use-this
  async signTransaction(tx, {
    innerTx,
    networkId
  } = {}) {
    if (innerTx != null) throw new NotImplementedError('innerTx option in AccountMetamask');
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    return invokeSnap(this.provider, 'signTransaction', {
      derivationPath: [`${this.index}'`, "0'", "0'"],
      tx,
      networkId
    }, 'signedTx');
  }

  // eslint-disable-next-line class-methods-use-this
  async signMessage(message) {
    const signature = await invokeSnap(this.provider, 'signMessage', {
      derivationPath: [`${this.index}'`, "0'", "0'"],
      message: Buffer.from(message).toString('base64')
    }, 'signature');
    return Buffer.from(signature, 'base64');
  }
}
;// ./src/account/MetamaskFactory.ts
function MetamaskFactory_classPrivateMethodInitSpec(e, a) { MetamaskFactory_checkPrivateRedeclaration(e, a), a.add(e); }
function MetamaskFactory_classPrivateFieldInitSpec(e, t, a) { MetamaskFactory_checkPrivateRedeclaration(e, t), t.set(e, a); }
function MetamaskFactory_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function MetamaskFactory_classPrivateFieldSet(s, a, r) { return s.set(MetamaskFactory_assertClassBrand(s, a), r), r; }
function MetamaskFactory_classPrivateFieldGet(s, a) { return s.get(MetamaskFactory_assertClassBrand(s, a)); }
function MetamaskFactory_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }




const snapMinVersion = '0.0.9';
const snapMaxVersion = '0.1.0';
const metamaskVersionPrefix = 'MetaMask/v';
var _provider = /*#__PURE__*/new WeakMap();
var _AccountMetamaskFactory_brand = /*#__PURE__*/new WeakSet();
var _providerPromise = /*#__PURE__*/new WeakMap();
/**
 * A factory class that generates instances of AccountMetamask.
 * @see {@link https://www.npmjs.com/package/@aeternity-snap/plugin | Aeternity snap}
 * @category account
 */
class AccountMetamaskFactory extends AccountBaseFactory {
  /**
   * @deprecated this class is not intended to provide raw access to the provider
   */
  get provider() {
    if (MetamaskFactory_classPrivateFieldGet(_provider, this) == null) throw new UnsupportedPlatformError('Metamask is not detected yet');
    return MetamaskFactory_classPrivateFieldGet(_provider, this);
  }
  /**
   * @param provider - Connection to MetaMask to use
   */
  constructor(_provider2) {
    super();
    MetamaskFactory_classPrivateMethodInitSpec(this, _AccountMetamaskFactory_brand);
    // TODO: remove after removing `provider`
    MetamaskFactory_classPrivateFieldInitSpec(this, _provider, void 0);
    MetamaskFactory_classPrivateFieldInitSpec(this, _providerPromise, void 0);
    MetamaskFactory_classPrivateFieldSet(_provider, this, _provider2);
    if (MetamaskFactory_classPrivateFieldGet(_provider, this) == null && window == null) {
      throw new UnsupportedPlatformError('Window object not found, you can run AccountMetamaskFactory only in browser or setup a provider');
    }
  }

  /**
   * Request MetaMask to install Aeternity snap.
   * @deprecated use `requestSnap` instead
   */
  async installSnap() {
    const provider = await MetamaskFactory_assertClassBrand(_AccountMetamaskFactory_brand, this, _getProvider).call(this);
    const details = await provider.request({
      method: 'wallet_requestSnaps',
      params: {
        [snapId]: {
          version: snapMinVersion
        }
      }
    });
    return details[snapId];
  }

  /**
   * Request MetaMask to install Aeternity snap or connect it to the current aepp.
   * MetaMask can have only one Aeternity snap version installed at a time.
   * This method is intended to upgrade the snap to a specified version if needed by the aepp.
   * If Aeternity snap is installed but wasn't used by the aepp, then the user still needs to approve the connection.
   * If the currently installed version corresponds to the version range, then the snap won't be upgraded.
   * To downgrade the snap, the user must manually uninstall the current version.
   * @param version - Snap version range (e.g. `1`, `0.1.*`, `^0.0.9`, `~0.0.9`; `>=0.0.9 <0.1.0`)
   * (default: a version range supported by sdk)
   */
  async requestSnap(version = `>=${snapMinVersion} <${snapMaxVersion}`) {
    const provider = await MetamaskFactory_assertClassBrand(_AccountMetamaskFactory_brand, this, _getProvider).call(this);
    const details = await provider.request({
      method: 'wallet_requestSnaps',
      params: {
        [snapId]: {
          version
        }
      }
    });
    return details[snapId];
  }

  /**
   * It throws an exception if MetaMask or Aeternity snap has an incompatible version or is not
   * installed or is not connected to the aepp.
   * @deprecated use `requestSnap` instead
   */
  async ensureReady() {
    const snapVersion = await this.getSnapVersion();
    const args = [snapVersion, snapMinVersion, snapMaxVersion];
    if (!semverSatisfies(...args)) throw new UnsupportedVersionError('Aeternity snap in MetaMask', ...args);
  }

  /**
   * @returns the version of snap installed in MetaMask
   */
  async getSnapVersion() {
    const provider = await MetamaskFactory_assertClassBrand(_AccountMetamaskFactory_brand, this, _getProvider).call(this);
    const snaps = await provider.request({
      method: 'wallet_getSnaps'
    });
    const version = snaps[snapId]?.version;
    if (version == null) throw new UnsupportedPlatformError('Aeternity snap is not installed to MetaMask or not connected to this aepp');
    return version;
  }

  /**
   * Get an instance of AccountMetaMask for a given account index.
   * @param accountIndex - Index of account
   */
  async initialize(accountIndex) {
    await this.requestSnap();
    const provider = await MetamaskFactory_assertClassBrand(_AccountMetamaskFactory_brand, this, _getProvider).call(this);
    const address = await invokeSnap(provider, 'getPublicKey', {
      derivationPath: [`${accountIndex}'`, "0'", "0'"]
    }, 'publicKey');
    return new AccountMetamask(provider, accountIndex, address);
  }
}
async function _getMetamaskAsInjected() {
  if (!('ethereum' in window) || window.ethereum == null) return;
  const provider = window.ethereum;
  const version = await provider.request({
    method: 'web3_clientVersion'
  });
  if (version == null) throw new InternalError("Can't get Ethereum Provider version");
  if (!version.startsWith(metamaskVersionPrefix)) return;
  return provider;
}
async function _getMetamaskOverEip() {
  setTimeout(() => window.dispatchEvent(new Event('eip6963:requestProvider')));
  return new Promise(resolve => {
    const handler = event => {
      if (event.detail.info.rdns !== 'io.metamask') return;
      window.removeEventListener('eip6963:announceProvider', handler);
      resolve(event.detail.provider);
    };
    window.addEventListener('eip6963:announceProvider', handler);
    setTimeout(() => {
      window.removeEventListener('eip6963:announceProvider', handler);
      resolve(undefined);
    }, 500);
  });
}
async function _getProvider() {
  var _classPrivateFieldGet2;
  (_classPrivateFieldGet2 = MetamaskFactory_classPrivateFieldGet(_providerPromise, this)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : MetamaskFactory_classPrivateFieldSet(_providerPromise, this, (async (_classPrivateFieldGet3, _await$_assertClassBr) => {
    (_classPrivateFieldGet3 = MetamaskFactory_classPrivateFieldGet(_provider, this)) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : MetamaskFactory_classPrivateFieldSet(_provider, this, (_await$_assertClassBr = await MetamaskFactory_assertClassBrand(_AccountMetamaskFactory_brand, this, _getMetamaskAsInjected).call(this)) !== null && _await$_assertClassBr !== void 0 ? _await$_assertClassBr : await MetamaskFactory_assertClassBrand(_AccountMetamaskFactory_brand, this, _getMetamaskOverEip).call(this));
    if (MetamaskFactory_classPrivateFieldGet(_provider, this) == null) {
      throw new UnsupportedPlatformError("Can't find a Metamask extension as an injected provider and over EIP-6963. Ensure that Metamask is installed or setup a provider.");
    }
    const version = await MetamaskFactory_classPrivateFieldGet(_provider, this).request({
      method: 'web3_clientVersion'
    });
    if (version == null) throw new InternalError("Can't get Ethereum Provider version");
    const args = [version.slice(metamaskVersionPrefix.length), '12.2.4'];
    if (!semverSatisfies(...args)) throw new UnsupportedVersionError('Metamask', ...args);
    return MetamaskFactory_classPrivateFieldGet(_provider, this);
  })());
  return MetamaskFactory_classPrivateFieldGet(_providerPromise, this);
}
;// ./src/contract/compiler/Base.ts
/**
 * A base class for all compiler implementations
 * @category contract
 */
class CompilerBase {}
;// ./src/apis/compiler/models/mappers.ts
const mappers_Contract = {
  type: {
    name: "Composite",
    className: "Contract",
    modelProperties: {
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      }
    }
  }
};
const CompileOpts = {
  type: {
    name: "Composite",
    className: "CompileOpts",
    modelProperties: {
      fileSystem: {
        serializedName: "file_system",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      srcFile: {
        serializedName: "src_file",
        type: {
          name: "String"
        }
      }
    }
  }
};
const mappers_CompilerError = {
  type: {
    name: "Composite",
    className: "CompilerError",
    modelProperties: {
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "String"
        }
      },
      pos: {
        serializedName: "pos",
        type: {
          name: "Composite",
          className: "ErrorPos"
        }
      },
      message: {
        serializedName: "message",
        required: true,
        type: {
          name: "String"
        }
      },
      context: {
        serializedName: "context",
        type: {
          name: "String"
        }
      }
    }
  }
};
const ErrorPos = {
  type: {
    name: "Composite",
    className: "ErrorPos",
    modelProperties: {
      file: {
        serializedName: "file",
        type: {
          name: "String"
        }
      },
      line: {
        serializedName: "line",
        required: true,
        type: {
          name: "Number"
        }
      },
      col: {
        serializedName: "col",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const CompileResult = {
  type: {
    name: "Composite",
    className: "CompileResult",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      },
      aci: {
        serializedName: "aci",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Dictionary",
              value: {
                type: {
                  name: "any"
                }
              }
            }
          }
        }
      },
      warnings: {
        serializedName: "warnings",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      }
    }
  }
};
const SophiaCallResultInput = {
  type: {
    name: "Composite",
    className: "SophiaCallResultInput",
    modelProperties: {
      source: {
        serializedName: "source",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      callResult: {
        serializedName: "call-result",
        required: true,
        type: {
          name: "String"
        }
      },
      callValue: {
        serializedName: "call-value",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const BytecodeCallResultInput = {
  type: {
    name: "Composite",
    className: "BytecodeCallResultInput",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      callResult: {
        serializedName: "call-result",
        required: true,
        type: {
          name: "String"
        }
      },
      callValue: {
        serializedName: "call-value",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DecodedCallresult = {
  type: {
    name: "Composite",
    className: "DecodedCallresult",
    modelProperties: {
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      result: {
        serializedName: "result",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
const FunctionCallInput = {
  type: {
    name: "Composite",
    className: "FunctionCallInput",
    modelProperties: {
      source: {
        serializedName: "source",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      arguments: {
        serializedName: "arguments",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const Calldata = {
  type: {
    name: "Composite",
    className: "Calldata",
    modelProperties: {
      calldata: {
        serializedName: "calldata",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DecodeCalldataBytecode = {
  type: {
    name: "Composite",
    className: "DecodeCalldataBytecode",
    modelProperties: {
      calldata: {
        serializedName: "calldata",
        required: true,
        type: {
          name: "String"
        }
      },
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DecodedCalldata = {
  type: {
    name: "Composite",
    className: "DecodedCalldata",
    modelProperties: {
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      arguments: {
        serializedName: "arguments",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Dictionary",
              value: {
                type: {
                  name: "any"
                }
              }
            }
          }
        }
      }
    }
  }
};
const mappers_ErrorModel = {
  type: {
    name: "Composite",
    className: "ErrorModel",
    modelProperties: {
      reason: {
        serializedName: "reason",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DecodeCalldataSource = {
  type: {
    name: "Composite",
    className: "DecodeCalldataSource",
    modelProperties: {
      source: {
        serializedName: "source",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      },
      calldata: {
        serializedName: "calldata",
        required: true,
        type: {
          name: "String"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ByteCodeInput = {
  type: {
    name: "Composite",
    className: "ByteCodeInput",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const FateAssembler = {
  type: {
    name: "Composite",
    className: "FateAssembler",
    modelProperties: {
      fateAssembler: {
        serializedName: "fate-assembler",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ValidateByteCodeInput = {
  type: {
    name: "Composite",
    className: "ValidateByteCodeInput",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      },
      source: {
        serializedName: "source",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      }
    }
  }
};
const CompilerVersion = {
  type: {
    name: "Composite",
    className: "CompilerVersion",
    modelProperties: {
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ApiVersion = {
  type: {
    name: "Composite",
    className: "ApiVersion",
    modelProperties: {
      apiVersion: {
        serializedName: "api-version",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const SophiaBinaryData = {
  type: {
    name: "Composite",
    className: "SophiaBinaryData",
    modelProperties: {
      sophiaType: {
        serializedName: "sophia-type",
        required: true,
        type: {
          name: "String"
        }
      },
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const SophiaJsonData = {
  type: {
    name: "Composite",
    className: "SophiaJsonData",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
;// ./src/apis/compiler/models/parameters.ts

const parameters_contentType = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
};
const parameters_body = {
  parameterPath: "body",
  mapper: mappers_Contract
};
const parameters_accept = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
};
const parameters_$host = {
  parameterPath: "$host",
  mapper: {
    serializedName: "$host",
    required: true,
    type: {
      name: "String"
    }
  },
  skipEncoding: true
};
const parameters_body1 = {
  parameterPath: "body",
  mapper: SophiaCallResultInput
};
const body2 = {
  parameterPath: "body",
  mapper: BytecodeCallResultInput
};
const body3 = {
  parameterPath: "body",
  mapper: FunctionCallInput
};
const body4 = {
  parameterPath: "body",
  mapper: DecodeCalldataBytecode
};
const body5 = {
  parameterPath: "body",
  mapper: DecodeCalldataSource
};
const body6 = {
  parameterPath: "body",
  mapper: ByteCodeInput
};
const body7 = {
  parameterPath: "body",
  mapper: ValidateByteCodeInput
};
;// ./src/apis/compiler/compiler.ts



class Compiler extends core_client_.ServiceClient {
  /**
   * Initializes a new instance of the Compiler class.
   * @param $host server parameter
   * @param options The parameter options
   */
  constructor($host, options) {
    var _ref, _options$endpoint;
    if ($host === undefined) {
      throw new Error("'$host' cannot be null");
    }

    // Initializing default values for options
    if (!options) {
      options = {};
    }
    const defaults = {
      requestContentType: "application/json; charset=utf-8"
    };
    const packageDetails = `azsdk-js-compiler/1.0.0-beta.1`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
    const optionsWithDefaults = {
      ...defaults,
      ...options,
      userAgentOptions: {
        userAgentPrefix
      },
      endpoint: (_ref = (_options$endpoint = options.endpoint) !== null && _options$endpoint !== void 0 ? _options$endpoint : options.baseUri) !== null && _ref !== void 0 ? _ref : "{$host}"
    };
    super(optionsWithDefaults);
    // Parameter assignments
    this.$host = $host;
  }

  /**
   * Generate an Aeternity Contract Interface (ACI) for contract
   * @param body contract code
   * @param options The options parameters.
   */
  generateACI(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, generateACIOperationSpec);
  }

  /**
   * Compile a sophia contract from source and return byte code and ACI
   * @param body contract code
   * @param options The options parameters.
   */
  compileContract(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, compileContractOperationSpec);
  }

  /**
   * Decode the result of contract call
   * @param body Binary data in Sophia ABI format
   * @param options The options parameters.
   */
  decodeCallResult(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCallResultOperationSpec);
  }

  /**
   * Decode the result of contract call from Bytecode
   * @param body Call result + compiled contract
   * @param options The options parameters.
   */
  decodeCallResultBytecode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCallResultBytecodeOperationSpec);
  }

  /**
   * Encode Sophia function call according to sophia ABI.
   * @param body Sophia function call - contract code + function name + arguments
   * @param options The options parameters.
   */
  encodeCalldata(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, encodeCalldataOperationSpec);
  }

  /**
   * Identify function name and arguments in Calldata for a compiled contract
   * @param body Calldata + compiled contract
   * @param options The options parameters.
   */
  decodeCalldataBytecode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCalldataBytecodeOperationSpec);
  }

  /**
   * Identify function name and arguments in Calldata for a (partial) contract
   * @param body Calldata + contract (stub) code
   * @param options The options parameters.
   */
  decodeCalldataSource(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCalldataSourceOperationSpec);
  }

  /**
   * Get FATE assembler code from bytecode
   * @param body contract byte array
   * @param options The options parameters.
   */
  getFateAssemblerCode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, getFateAssemblerCodeOperationSpec);
  }

  /**
   * Verify that an encoded byte array is the result of compiling a given contract
   * @param body contract byte array and source code
   * @param options The options parameters.
   */
  validateByteCode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, validateByteCodeOperationSpec);
  }

  /**
   * Extract compiler version from bytecode
   * @param body contract byte array
   * @param options The options parameters.
   */
  getCompilerVersion(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, getCompilerVersionOperationSpec);
  }

  /**
   * Get the version of the underlying Sophia compiler version
   * @param options The options parameters.
   */
  version(options) {
    return this.sendOperationRequest({
      options
    }, versionOperationSpec);
  }

  /**
   * Get the version of the API
   * @param options The options parameters.
   */
  apiVersion(options) {
    return this.sendOperationRequest({
      options
    }, apiVersionOperationSpec);
  }

  /**
   * Get the Api description
   * @param options The options parameters.
   */
  api(options) {
    return this.sendOperationRequest({
      options
    }, apiOperationSpec);
  }
}
// Operation Specifications
const compiler_serializer = core_client_.createSerializer(models_mappers_namespaceObject, /* isXml */false);
const generateACIOperationSpec = {
  path: "/aci",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Dictionary",
              value: {
                type: {
                  name: "any"
                }
              }
            }
          }
        }
      }
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: parameters_body,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const compileContractOperationSpec = {
  path: "/compile",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: CompileResult
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: parameters_body,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const decodeCallResultOperationSpec = {
  path: "/decode-call-result",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "any"
        }
      }
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: parameters_body1,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const decodeCallResultBytecodeOperationSpec = {
  path: "/decode-call-result/bytecode",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: DecodedCallresult
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body2,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const encodeCalldataOperationSpec = {
  path: "/encode-calldata",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Calldata
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body3,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const decodeCalldataBytecodeOperationSpec = {
  path: "/decode-calldata/bytecode",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: DecodedCalldata
    },
    400: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  requestBody: body4,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const decodeCalldataSourceOperationSpec = {
  path: "/decode-calldata/source",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: DecodedCalldata
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body5,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const getFateAssemblerCodeOperationSpec = {
  path: "/fate-assembler",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: FateAssembler
    },
    400: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  requestBody: body6,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const validateByteCodeOperationSpec = {
  path: "/validate-byte-code",
  httpMethod: "POST",
  responses: {
    200: {},
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body7,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const getCompilerVersionOperationSpec = {
  path: "/compiler-version",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: CompilerVersion
    },
    400: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  requestBody: body6,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const versionOperationSpec = {
  path: "/version",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: CompilerVersion
    },
    500: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  urlParameters: [parameters_$host],
  headerParameters: [parameters_accept],
  serializer: compiler_serializer
};
const apiVersionOperationSpec = {
  path: "/api-version",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ApiVersion
    },
    500: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  urlParameters: [parameters_$host],
  headerParameters: [parameters_accept],
  serializer: compiler_serializer
};
const apiOperationSpec = {
  path: "/api",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    },
    400: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  urlParameters: [parameters_$host],
  headerParameters: [parameters_accept],
  serializer: compiler_serializer
};
;// ./src/contract/compiler/Http.ts





/**
 * Contract Compiler over HTTP
 *
 * This class include api call's related to contract compiler functionality.
 * @category contract
 * @example CompilerHttp('COMPILER_URL')
 */
class CompilerHttp extends CompilerBase {
  /**
   * @param compilerUrl - Url for compiler API
   * @param options - Options
   * @param options.ignoreVersion - Print warning instead of throwing exception if compiler version
   * is not supported, use with caution
   */
  constructor(compilerUrl, {
    ignoreVersion = false
  } = {}) {
    super();
    let version;
    const getVersion = async opts => {
      if (version != null) return version;
      version = (await this.api.apiVersion(opts)).apiVersion;
      return version;
    };
    this.api = new Compiler(compilerUrl, {
      allowInsecureConnection: true,
      additionalPolicies: [genVersionCheckPolicy('compiler', getVersion, '8.0.0', '9.0.0', ignoreVersion), genErrorFormatterPolicy(body => {
        let message = '';
        if ('reason' in body) {
          message += ` ${body.reason}${body.parameter != null ? ` in ${body.parameter}` : ''
          // TODO: revising after improving documentation https://github.com/aeternity/aesophia_http/issues/78
          }${body.info != null ? ` (${JSON.stringify(body.info)})` : ''}`;
        }
        if (Array.isArray(body)) {
          message += `\n${body.map(e => `${e.type}:${e.pos.line}:${e.pos.col}: ${e.message}${e.context != null ? ` (${e.context})` : ''}`).join('\n')}`;
        }
        return message;
      })]
    });
    this.api.pipeline.removePolicy({
      name: core_rest_pipeline_.userAgentPolicyName
    });
    this.api.pipeline.removePolicy({
      name: core_rest_pipeline_.setClientRequestIdPolicyName
    });
  }
  async compileBySourceCode(sourceCode, fileSystem) {
    try {
      const cmpOut = await this.api.compileContract({
        code: sourceCode,
        options: {
          fileSystem
        }
      });
      const warnings = cmpOut.warnings.map(({
        type,
        ...warning
      }) => warning);
      const res = {
        ...cmpOut,
        warnings
      };
      // TODO: should be fixed when the compiledAci interface gets updated
      return res;
    } catch (error) {
      if (error instanceof core_rest_pipeline_.RestError && error.statusCode === 400) {
        throw new CompilerError(error.message);
      }
      throw error;
    }
  }

  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  async compile(path) {
    throw new NotImplementedError('File system access, use CompilerHttpNode instead');
  }
  async generateAciBySourceCode(sourceCode, fileSystem) {
    try {
      return await this.api.generateACI({
        code: sourceCode,
        options: {
          fileSystem
        }
      });
    } catch (error) {
      if (error instanceof core_rest_pipeline_.RestError && error.statusCode === 400) {
        throw new CompilerError(error.message);
      }
      throw error;
    }
  }

  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  async generateAci(path) {
    throw new NotImplementedError('File system access, use CompilerHttpNode instead');
  }
  async validateBySourceCode(bytecode, sourceCode, fileSystem) {
    try {
      await this.api.validateByteCode({
        bytecode,
        source: sourceCode,
        options: {
          fileSystem
        }
      });
      return true;
    } catch {
      return false;
    }
  }

  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  async validate(bytecode, path) {
    throw new NotImplementedError('File system access, use CompilerHttpNode instead');
  }
  async version() {
    return (await this.api.version()).version;
  }
}
;// ./src/utils/string.ts
/**
 * Convert string from snake_case to PascalCase
 * @param s - String to convert
 * @returns Converted string
 */
function snakeToPascal(s) {
  return s.replace(/_./g, match => match[1].toUpperCase());
}

/**
 * Convert string from PascalCase to snake_case
 * @param s - String to convert
 * @returns Converted string
 */
function pascalToSnake(s) {
  return s.replace(/[A-Z]/g, match => `_${match.toLowerCase()}`);
}
// EXTERNAL MODULE: external "websocket"
var external_websocket_ = __webpack_require__(8963);
var external_websocket_default = /*#__PURE__*/__webpack_require__.n(external_websocket_);
;// ./src/channel/internal.ts






const {
  w3cwebsocket: W3CWebSocket
} = (external_websocket_default());

// TODO: SignTx shouldn't return number or null

/**
 * @see {@link https://github.com/aeternity/protocol/blob/6734de2e4c7cce7e5e626caa8305fb535785131d/node/api/channels_api_usage.md#channel-establishing-parameters}
 */

// Send ping message every 10 seconds
const PING_TIMEOUT_MS = 10000;
// Close connection if pong message is not received within 15 seconds
const PONG_TIMEOUT_MS = 15000;
function emit(channel, ...args) {
  const [eventName, ...rest] = args;
  channel._eventEmitter.emit(eventName, ...rest);
}
function enterState(channel, nextState) {
  if (nextState == null) {
    throw new UnknownChannelStateError();
  }
  channel._debug('enter state', nextState.handler.name);
  channel._fsm = nextState;
  if (nextState?.handler?.enter != null) {
    nextState.handler.enter(channel);
  }
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  void dequeueAction(channel);
}

// TODO: rewrite to enum

function changeStatus(channel, newStatus, debug) {
  channel._debug(newStatus, `(prev. ${channel._status})`, debug !== null && debug !== void 0 ? debug : '');
  if (newStatus === channel._status) return;
  channel._status = newStatus;
  emit(channel, 'statusChanged', newStatus);
}
function changeState(channel, newState) {
  channel._state = newState;
  emit(channel, 'stateChanged', newState);
}
function send(channel, message) {
  channel._debug('send message', message.method, message.params);
  channel._websocket.send(json_big.stringify({
    jsonrpc: '2.0',
    ...message
  }));
}
function notify(channel, method, params = {}) {
  send(channel, {
    method,
    params
  });
}
async function dequeueAction(channel) {
  if (channel._isActionQueueLocked) return;
  const queue = channel._actionQueue;
  if (queue.length === 0) return;
  const index = queue.findIndex(action => action.guard(channel, channel._fsm));
  if (index === -1) return;
  channel._actionQueue = queue.filter((_, i) => index !== i);
  channel._isActionQueueLocked = true;
  const nextState = await queue[index].action(channel, channel._fsm);
  channel._isActionQueueLocked = false;
  enterState(channel, nextState);
}
async function enqueueAction(channel, guard, action) {
  const promise = new Promise((resolve, reject) => {
    channel._actionQueue.push({
      guard,
      action() {
        const res = action();
        return {
          ...res,
          state: {
            ...res.state,
            resolve,
            reject
          }
        };
      }
    });
  });
  void dequeueAction(channel);
  return promise;
}
async function handleMessage(channel, message) {
  const {
    handler,
    state: st
  } = channel._fsm;
  const nextState = await Promise.resolve(handler(channel, message, st));
  enterState(channel, nextState);
  // TODO: emit message and handler name (?) to move this code to Contract constructor
  if (message?.params?.data?.updates?.[0]?.op === 'OffChainNewContract' &&
  // if name is channelOpen, the contract was created by other participant
  nextState?.handler.name === 'channelOpen') {
    const round = channel.round();
    if (round == null) throw new UnexpectedTsError('Round is null');
    const owner = message?.params?.data?.updates?.[0]?.owner;
    emit(channel, 'newContract', buildContractId(owner, round + 1));
  }
}
async function dequeueMessage(channel) {
  if (channel._isMessageQueueLocked) return;
  channel._isMessageQueueLocked = true;
  while (channel._messageQueue.length > 0) {
    const message = channel._messageQueue.shift();
    if (message == null) throw new UnexpectedTsError();
    try {
      await handleMessage(channel, message);
    } catch (error) {
      ensureError(error);
      emit(channel, 'error', new ChannelIncomingMessageError(error, message));
    }
  }
  channel._isMessageQueueLocked = false;
}
function disconnect(channel) {
  channel._websocket.close();
  clearTimeout(channel._pingTimeoutId);
}
function ping(channel) {
  clearTimeout(channel._pingTimeoutId);
  channel._pingTimeoutId = setTimeout(() => {
    notify(channel, 'channels.system', {
      action: 'ping'
    });
    channel._pingTimeoutId = setTimeout(() => {
      disconnect(channel);
      emit(channel, 'error', new ChannelPingTimedOutError());
    }, PONG_TIMEOUT_MS);
  }, PING_TIMEOUT_MS);
}
function onMessage(channel, data) {
  const message = json_big.parse(data);
  channel._debug('received message', message.method, message.params);
  if (message.id != null) {
    const callback = channel._rpcCallbacks.get(message.id);
    if (callback == null) {
      emit(channel, 'error', new ChannelError(`Can't find callback by id: ${message.id}`));
      return;
    }
    try {
      callback(message);
    } finally {
      channel._rpcCallbacks.delete(message.id);
    }
    return;
  }
  if (message.method === 'channels.message') {
    emit(channel, 'message', message.params.data.message);
    return;
  }
  if (message.method === 'channels.system.pong') {
    if (message.params.channel_id === channel._channelId || channel._channelId == null) {
      ping(channel);
    }
    return;
  }
  channel._messageQueue.push(message);
  void dequeueMessage(channel);
}
async function call(channel, method, params) {
  return new Promise((resolve, reject) => {
    const id = channel._nextRpcMessageId;
    channel._nextRpcMessageId += 1;
    channel._rpcCallbacks.set(id, message => {
      if (message.error != null) {
        var _message$error$data$;
        const details = (_message$error$data$ = message.error.data[0].message) !== null && _message$error$data$ !== void 0 ? _message$error$data$ : '';
        reject(new ChannelCallError(message.error.message + details));
      } else resolve(message.result);
    });
    send(channel, {
      method,
      id,
      params
    });
  });
}
async function initialize(channel, connectionHandler, openHandler, {
  url,
  ...channelOptions
}) {
  channel._options = {
    url,
    ...channelOptions
  };
  const wsUrl = new URL(url);
  Object.entries(channelOptions).filter(([key]) => !['sign', 'debug'].includes(key)).forEach(([key, value]) => wsUrl.searchParams.set(pascalToSnake(key), value.toString()));
  wsUrl.searchParams.set('protocol', 'json-rpc');
  changeStatus(channel, 'connecting');
  channel._websocket = new W3CWebSocket(wsUrl.toString());
  await new Promise((resolve, reject) => {
    Object.assign(channel._websocket, {
      onerror: reject,
      onopen: async event => {
        resolve();
        changeStatus(channel, 'connected', event);
        enterState(channel, {
          handler: connectionHandler
        });
        ping(channel);
      },
      onclose: event => {
        changeStatus(channel, 'disconnected', event);
        clearTimeout(channel._pingTimeoutId);
      },
      onmessage: ({
        data
      }) => onMessage(channel, data)
    });
  });
}
;// ./src/channel/handlers.ts
/* eslint-disable consistent-return */
/* eslint-disable default-case */
/* eslint-disable @typescript-eslint/no-use-before-define */






async function appendSignature(tx, signFn) {
  const {
    signatures,
    encodedTx
  } = unpackTx(tx, Tag.SignedTx);
  const payloadTx = buildTx(encodedTx);
  const result = await signFn(payloadTx);
  if (typeof result === 'string') {
    const {
      signatures: signatures2
    } = unpackTx(result, Tag.SignedTx);
    return buildTx({
      tag: Tag.SignedTx,
      signatures: signatures.concat(signatures2),
      encodedTx: decode(payloadTx)
    });
  }
  return result;
}
async function signAndNotify(channel, method, data, signFn) {
  let signedTx;
  if (data.tx != null) signedTx = await signFn(data.tx);else if (data.signed_tx != null) signedTx = await appendSignature(data.signed_tx, signFn);else throw new ChannelError("Can't find transaction in message");
  const isError = typeof signedTx !== 'string';
  const key = data.tx != null ? 'tx' : 'signed_tx';
  notify(channel, method, isError ? {
    error: signedTx !== null && signedTx !== void 0 ? signedTx : 1
  } : {
    [key]: signedTx
  });
  return isError;
}
function handleUnexpectedMessage(_channel, message, state) {
  state?.reject?.(Object.assign(new UnexpectedChannelMessageError(`Unexpected message received:\n\n${JSON.stringify(message)}`), {
    wsMessage: message
  }));
  return {
    handler: channelOpen
  };
}
function awaitingCompletion(channel, message, state, onSuccess) {
  if (onSuccess != null && message.method === 'channels.update') {
    return onSuccess(channel, message, state);
  }
  if (message.method === 'channels.conflict') {
    state.resolve({
      accepted: false,
      errorCode: message.params.data.error_code,
      errorMessage: message.params.data.error_msg
    });
    return {
      handler: channelOpen
    };
  }
  if (message.method === 'channels.info') {
    if (message.params.data.event === 'aborted_update') {
      state.resolve({
        accepted: false
      });
      return {
        handler: channelOpen
      };
    }
  }
  if (message.error != null) {
    const codes = message.error.data.map(d => d.code);
    if (codes.includes(1001)) {
      state.reject(new InsufficientBalanceError('Insufficient balance'));
    } else if (codes.includes(1002)) {
      state.reject(new IllegalArgumentError('Amount cannot be negative'));
    } else {
      state.reject(new ChannelConnectionError(message.error.message));
    }
    return {
      handler: channelOpen
    };
  }
  return handleUnexpectedMessage(channel, message, state);
}
function awaitingConnection(channel, message) {
  if (message.method === 'channels.info') {
    const channelInfoStatus = message.params.data.event;
    let nextStatus = null;
    if (channelInfoStatus === 'channel_accept') nextStatus = 'accepted';
    if (channelInfoStatus === 'funding_created') nextStatus = 'halfSigned';
    if (nextStatus != null) {
      changeStatus(channel, nextStatus);
      return {
        handler: awaitingChannelCreateTx
      };
    }
    if (message.params.data.event === 'channel_reestablished') {
      return {
        handler: awaitingOpenConfirmation
      };
    }
    if (message.params.data.event === 'fsm_up') {
      channel._fsmId = message.params.data.fsm_id;
      return {
        handler: awaitingConnection
      };
    }
    return {
      handler: awaitingConnection
    };
  }
  if (message.method === 'channels.error') {
    emit(channel, 'error', new ChannelConnectionError(message?.payload?.message));
    return {
      handler: channelClosed
    };
  }
}
async function awaitingReestablish(channel, message, state) {
  if (message.method === 'channels.info' && message.params.data.event === 'fsm_up') {
    channel._fsmId = message.params.data.fsm_id;
    return {
      handler: function awaitingChannelReestablished(_, message2, state2) {
        if (message2.method === 'channels.info' && message2.params.data.event === 'channel_reestablished') return {
          handler: awaitingOpenConfirmation
        };
        return handleUnexpectedMessage(channel, message2, state2);
      }
    };
  }
  return handleUnexpectedMessage(channel, message, state);
}
async function awaitingReconnection(channel, message, state) {
  if (message.method === 'channels.info' && message.params.data.event === 'fsm_up') {
    channel._fsmId = message.params.data.fsm_id;
    const {
      signedTx
    } = await channel.state();
    changeState(channel, signedTx == null ? '' : buildTx(signedTx));
    return {
      handler: channelOpen
    };
  }
  return handleUnexpectedMessage(channel, message, state);
}
async function awaitingChannelCreateTx(channel, message) {
  const tag = channel._options.role === 'initiator' ? 'initiator_sign' : 'responder_sign';
  if (message.method === `channels.sign.${tag}`) {
    await signAndNotify(channel, `channels.${tag}`, message.params.data, async tx => channel._options.sign(tag, tx));
    return {
      handler: awaitingOnChainTx
    };
  }
}
function awaitingOnChainTx(channel, message) {
  function awaitingBlockInclusion(_, message2) {
    if (message2.method === 'channels.info') {
      switch (message2.params.data.event) {
        case 'funding_created':
        case 'own_funding_locked':
          return {
            handler: awaitingBlockInclusion
          };
        case 'funding_locked':
          return {
            handler: awaitingOpenConfirmation
          };
      }
    }
    if (message2.method === 'channels.on_chain_tx') {
      emit(channel, 'onChainTx', message2.params.data.tx, {
        info: message2.params.data.info,
        type: message2.params.data.type
      });
      return {
        handler: awaitingBlockInclusion
      };
    }
  }
  if (message.method === 'channels.on_chain_tx') {
    const {
      info
    } = message.params.data;
    const {
      role
    } = channel._options;
    if (info === 'funding_signed' && role === 'initiator' || info === 'funding_created' && role === 'responder') {
      return {
        handler: awaitingBlockInclusion
      };
    }
  }
  if (message.method === 'channels.info' && message.params.data.event === 'funding_signed' && channel._options.role === 'initiator') {
    channel._channelId = message.params.channel_id;
    changeStatus(channel, 'signed');
    return {
      handler: awaitingOnChainTx
    };
  }
}
function awaitingOpenConfirmation(channel, message, state) {
  if (message.method === 'channels.info' && message.params.data.event === 'open') {
    channel._channelId = message.params.channel_id;
    return {
      handler: function awaitingChannelsUpdate(_, message2, state2) {
        if (message2.method === 'channels.update') {
          changeState(channel, message2.params.data.state);
          return {
            handler: channelOpen
          };
        }
        return handleUnexpectedMessage(channel, message2, state2);
      }
    };
  }
  return handleUnexpectedMessage(channel, message, state);
}
async function channelOpen(channel, message, state) {
  switch (message.method) {
    case 'channels.info':
      switch (message.params.data.event) {
        case 'update':
        case 'withdraw_created':
        case 'deposit_created':
          return {
            handler: awaitingTxSignRequest
          };
        case 'own_withdraw_locked':
        case 'withdraw_locked':
        case 'own_deposit_locked':
        case 'deposit_locked':
        case 'peer_disconnected':
        case 'channel_reestablished':
        case 'open':
          // TODO: Better handling of peer_disconnected event.
          //
          //       We should enter intermediate state where offchain transactions
          //       are blocked until channel is reestablished.
          emit(channel, snakeToPascal(message.params.data.event));
          return {
            handler: channelOpen
          };
        case 'fsm_up':
          channel._fsmId = message.params.data.fsm_id;
          return {
            handler: channelOpen
          };
        case 'timeout':
        case 'close_mutual':
          return {
            handler: channelOpen
          };
        case 'closing':
          changeStatus(channel, 'closing');
          return {
            handler: channelOpen
          };
        case 'closed_confirmed':
          changeStatus(channel, 'closed');
          return {
            handler: channelClosed
          };
        case 'died':
          changeStatus(channel, 'died');
          return {
            handler: channelClosed
          };
        case 'shutdown':
          return {
            handler: channelOpen
          };
      }
      break;
    case 'channels.on_chain_tx':
      emit(channel, 'onChainTx', message.params.data.tx, {
        info: message.params.data.info,
        type: message.params.data.type
      });
      return {
        handler: channelOpen
      };
    case 'channels.leave':
      // TODO: emit event
      return {
        handler: channelOpen
      };
    case 'channels.update':
      changeState(channel, message.params.data.state);
      return {
        handler: channelOpen
      };
    case 'channels.sign.shutdown_sign_ack':
      return awaitingTxSignRequest(channel, message, state);
  }
}
channelOpen.enter = channel => {
  changeStatus(channel, 'open');
};
async function awaitingTxSignRequest(channel, message, state) {
  var _message$method$match;
  const [, tag] = (_message$method$match = message.method.match(/^channels\.sign\.([^.]+)$/)) !== null && _message$method$match !== void 0 ? _message$method$match : [];
  if (tag == null) return handleUnexpectedMessage(channel, message, state);
  const isError = await signAndNotify(channel, `channels.${tag}`, message.params.data, async tx => channel._options.sign(tag, tx, {
    updates: message.params.data.updates
  }));
  function awaitingUpdateConflict(_, message2) {
    if (message2.error != null) {
      return {
        handler: awaitingUpdateConflict,
        state
      };
    }
    if (message2.method === 'channels.conflict') {
      return {
        handler: channelOpen
      };
    }
    return handleUnexpectedMessage(channel, message2, state);
  }
  return isError ? {
    handler: awaitingUpdateConflict,
    state
  } : {
    handler: channelOpen
  };
}
async function awaitingShutdownTx(channel, message, state) {
  if (message.method !== 'channels.sign.shutdown_sign') {
    return handleUnexpectedMessage(channel, message, state);
  }
  await signAndNotify(channel, 'channels.shutdown_sign', message.params.data, async tx => state.sign(tx));
  return {
    handler(_, message2) {
      if (message2.method !== 'channels.on_chain_tx') {
        return handleUnexpectedMessage(channel, message2, state);
      }
      // state.resolve(message.params.data.tx)
      return {
        handler: channelClosed,
        state
      };
    },
    state
  };
}
function awaitingLeave(channel, message, state) {
  if (message.method === 'channels.leave') {
    state.resolve({
      channelId: message.params.channel_id,
      signedTx: message.params.data.state
    });
    disconnect(channel);
    return {
      handler: channelClosed
    };
  }
  if (message.method === 'channels.error') {
    state.reject(new ChannelConnectionError(message.data.message));
    return {
      handler: channelOpen
    };
  }
  return handleUnexpectedMessage(channel, message, state);
}
function channelClosed(_channel, message, state) {
  if (state == null) return {
    handler: channelClosed
  };
  if (message.params.data.event === 'closing') return {
    handler: channelClosed,
    state
  };
  if (message.params.data.info === 'channel_closed') {
    state.closeTx = message.params.data.tx;
    return {
      handler: channelClosed,
      state
    };
  }
  if (message.params.data.event === 'closed_confirmed') {
    state.resolve(state.closeTx);
    return {
      handler: channelClosed
    };
  }
  return {
    handler: channelClosed,
    state
  };
}
// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__(761);
var external_events_default = /*#__PURE__*/__webpack_require__.n(external_events_);
;// ./src/channel/Base.ts

function Base_classPrivateFieldInitSpec(e, t, a) { Base_checkPrivateRedeclaration(e, t), t.set(e, a); }
function Base_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function Base_classPrivateFieldGet(s, a) { return s.get(Base_assertClassBrand(s, a)); }
function Base_classPrivateFieldSet(s, a, r) { return s.set(Base_assertClassBrand(s, a), r), r; }
function Base_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }








function snakeToPascalObjKeys(obj) {
  return Object.entries(obj).reduce((result, [key, val]) => ({
    ...result,
    [snakeToPascal(key)]: val
  }), {});
}
let channelCounter = 0;

/**
 * Channel
 * @example
 * ```js
 * await Channel.initialize({
 *   url: 'ws://localhost:3001',
 *   role: 'initiator'
 *   initiatorId: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
 *   responderId: 'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',
 *   initiatorAmount: 1e18,
 *   responderAmount: 1e18,
 *   pushAmount: 0,
 *   channelReserve: 0,
 *   ttl: 1000,
 *   host: 'localhost',
 *   port: 3002,
 *   lockPeriod: 10,
 *   async sign (tag, tx) => await account.signTransaction(tx)
 * })
 * ```
 */
var _debugId = /*#__PURE__*/new WeakMap();
class Base_Channel {
  constructor() {
    defineProperty_default()(this, "_eventEmitter", new (external_events_default())());
    defineProperty_default()(this, "_nextRpcMessageId", 0);
    defineProperty_default()(this, "_rpcCallbacks", new Map());
    defineProperty_default()(this, "_messageQueue", []);
    defineProperty_default()(this, "_isMessageQueueLocked", false);
    defineProperty_default()(this, "_actionQueue", []);
    defineProperty_default()(this, "_isActionQueueLocked", false);
    defineProperty_default()(this, "_status", 'disconnected');
    defineProperty_default()(this, "_state", '');
    Base_classPrivateFieldInitSpec(this, _debugId, void 0);
    channelCounter += 1;
    Base_classPrivateFieldSet(_debugId, this, channelCounter);
  }
  _debug(...args) {
    if (this._options.debug !== true) return;
    console.debug(`Channel #${Base_classPrivateFieldGet(_debugId, this)}`, ...args);
  }

  /**
   * @param options - Channel params
   */
  static async initialize(options) {
    return Base_Channel._initialize(new Base_Channel(), options);
  }
  static async _initialize(channel, options) {
    var _options$existingFsmI;
    const reconnect = ((_options$existingFsmI = options.existingFsmId) !== null && _options$existingFsmI !== void 0 ? _options$existingFsmI : options.existingChannelId) != null;
    if (reconnect && (options.existingFsmId == null || options.existingChannelId == null)) {
      throw new IllegalArgumentError('`existingChannelId`, `existingFsmId` should be both provided or missed');
    }
    const reconnectHandler = handlers_namespaceObject[options.reestablish === true ? 'awaitingReestablish' : 'awaitingReconnection'];
    await initialize(channel, reconnect ? reconnectHandler : awaitingConnection, channelOpen, options);
    return channel;
  }

  /**
   * Register event listener function
   *
   * Possible events:
   *
   *   - "error"
   *   - "stateChanged"
   *   - "statusChanged"
   *   - "message"
   *   - "peerDisconnected"
   *   - "onChainTx"
   *   - "ownWithdrawLocked"
   *   - "withdrawLocked"
   *   - "ownDepositLocked"
   *   - "depositLocked"
   *   - "channelReestablished"
   *   - "newContract"
   *
   *
   * @param eventName - Event name
   * @param callback - Callback function
   */
  on(eventName, callback) {
    this._eventEmitter.on(eventName, callback);
  }

  /**
   * Remove event listener function
   * @param eventName - Event name
   * @param callback - Callback function
   */
  off(eventName, callback) {
    this._eventEmitter.removeListener(eventName, callback);
  }

  /**
   * Close the connection
   */
  disconnect() {
    return disconnect(this);
  }

  /**
   * Get current status
   */
  status() {
    return this._status;
  }

  /**
   * Get current state
   */
  async state() {
    const res = snakeToPascalObjKeys(await call(this, 'channels.get.offchain_state', {}));
    return {
      calls: unpackEntry(res.calls),
      ...(res.halfSignedTx !== '' && {
        halfSignedTx: unpackTx(res.halfSignedTx, Tag.SignedTx)
      }),
      ...(res.signedTx !== '' && {
        signedTx: unpackTx(res.signedTx, Tag.SignedTx)
      }),
      trees: unpackEntry(res.trees)
    };
  }

  /**
   * Get current round
   *
   * If round cannot be determined (for example when channel has not been opened)
   * it will return `null`.
   */
  round() {
    if (this._state === '') {
      return null;
    }
    const params = unpackTx(this._state, Tag.SignedTx).encodedTx;
    switch (params.tag) {
      case Tag.ChannelCreateTx:
        return 1;
      case Tag.ChannelOffChainTx:
      case Tag.ChannelWithdrawTx:
      case Tag.ChannelDepositTx:
        return params.round;
      default:
        return null;
    }
  }

  /**
   * Get channel id
   *
   */
  id() {
    if (this._channelId == null) throw new ChannelError('Channel is not initialized');
    return this._channelId;
  }

  /**
   * Get channel's fsm id
   *
   */
  fsmId() {
    if (this._fsmId == null) throw new ChannelError('Channel is not initialized');
    return this._fsmId;
  }
  async enqueueAction(action) {
    return enqueueAction(this, (channel, state) => state?.handler === channelOpen, action);
  }

  /**
   * Leave channel
   *
   * It is possible to leave a channel and then later reestablish the channel
   * off-chain state and continue operation. When a leave method is called,
   * the channel fsm passes it on to the peer fsm, reports the current mutually
   * signed state and then terminates.
   *
   * The channel can be reestablished by instantiating another Channel instance
   * with two extra params: existingChannelId and existingFsmId.
   *
   * @example
   * ```js
   * channel.leave().then(({ channelId, signedTx }) => {
   *   console.log(channelId)
   *   console.log(signedTx)
   * })
   * ```
   */
  async leave() {
    return this.enqueueAction(() => {
      notify(this, 'channels.leave');
      return {
        handler: awaitingLeave
      };
    });
  }

  /**
   * Trigger mutual close
   *
   * At any moment after the channel is opened, a closing procedure can be triggered.
   * This can be done by either of the parties. The process is similar to the off-chain updates.
   *
   * @param sign - Function which verifies and signs mutual close transaction
   * @example
   * ```js
   * channel.shutdown(
   *   async (tx) => await account.signTransaction(tx)
   * ).then(tx => console.log('on_chain_tx', tx))
   * ```
   */
  async shutdown(sign) {
    return this.enqueueAction(() => {
      notify(this, 'channels.shutdown');
      return {
        handler: awaitingShutdownTx,
        state: {
          sign
        }
      };
    });
  }
}
;// ./src/channel/Spend.ts






class ChannelSpend extends Base_Channel {
  /**
   * Trigger a transfer update
   *
   * The transfer update is moving coins from one channel account to another.
   * The update is a change to be applied on top of the latest state.
   *
   * Sender and receiver are the channel parties. Both the initiator and responder
   * can take those roles. Any public key outside the channel is considered invalid.
   *
   * @param from - Sender's public address
   * @param to - Receiver's public address
   * @param amount - Transaction amount
   * @param sign - Function which verifies and signs offchain transaction
   * @param metadata - Metadata
    * @example
   * ```js
   * channel.update(
   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
   *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',
   *   10,
   *   async (tx) => await account.signTransaction(tx)
   * ).then(({ accepted, signedTx }) =>
   *   if (accepted) {
   *     console.log('Update has been accepted')
   *   }
   * )
   * ```
   */
  async update(from, to, amount, sign, metadata = []) {
    return this.enqueueAction(() => {
      notify(this, 'channels.update.new', {
        from,
        to,
        amount,
        meta: metadata
      });
      const awaitingOffChainTx = async (_, message, state) => {
        if (message.method === 'channels.sign.update') {
          const isError = await signAndNotify(this, 'channels.update', message.params.data, async tx => sign(tx, {
            updates: message.params.data.updates
          }));
          if (isError) return {
            handler: awaitingOffChainTx,
            state
          };
          return {
            handler: (_2, message2) => awaitingCompletion(this, message2, state, () => {
              changeState(this, message2.params.data.state);
              state.resolve({
                accepted: true,
                signedTx: message2.params.data.state
              });
              return {
                handler: channelOpen
              };
            }),
            state
          };
        }
        if (message.method === 'channels.error') {
          state.reject(new ChannelConnectionError(message.data.message));
          return {
            handler: channelOpen
          };
        }
        return awaitingCompletion(this, message, state);
      };
      return {
        handler: awaitingOffChainTx
      };
    });
  }

  /**
   * Get proof of inclusion
   *
   * If a certain address of an account or a contract is not found
   * in the state tree - the response is an error.
   *
   * @param addresses - Addresses
   * @param addresses.accounts - List of account addresses to include in poi
   * @param addresses.contracts - List of contract addresses to include in poi
   * @example
   * ```js
   * channel.poi({
   *   accounts: [
   *     'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
   *     'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'
   *   ],
   *   contracts: ['ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA']
   * }).then(poi => console.log(poi))
   * ```
   */
  async poi({
    accounts,
    contracts
  }) {
    const {
      poi
    } = await call(this, 'channels.get.poi', {
      accounts,
      contracts
    });
    return unpackEntry(poi);
  }

  /**
   * Get balances
   *
   * The accounts param contains a list of addresses to fetch balances of.
   * Those can be either account balances or a contract ones, encoded as an account addresses.
   *
   * If a certain account address had not being found in the state tree - it is simply
   * skipped in the response.
   *
   * @param accounts - List of addresses to fetch balances from
   * @example
   * ```js
   * channel.balances([
   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
   *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'
   *   'ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA'
   * ]).then(balances =>
   *   console.log(balances['ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'])
   * )
   * ```
   */
  async balances(accounts) {
    return Object.fromEntries((await call(this, 'channels.get.balances', {
      accounts
    })).map(item => [item.account, item.balance]));
  }
  async awaitingActionTx(action, message, state) {
    if (message.method !== `channels.sign.${action}_tx`) {
      return handleUnexpectedMessage(this, message, state);
    }
    const awaitingActionCompletion = (_, message2) => {
      if (message2.method === 'channels.on_chain_tx') {
        state.onOnChainTx?.(message2.params.data.tx);
        return {
          handler: awaitingActionCompletion,
          state
        };
      }
      if (message2.method === 'channels.info' && [`own_${action}_locked`, `${action}_locked`].includes(message2.params.data.event)) {
        const Action = action === 'deposit' ? 'Deposit' : 'Withdraw';
        const isOwn = message2.params.data.event.startsWith('own_');
        state[`on${isOwn ? 'Own' : ''}${Action}Locked`]?.();
        return {
          handler: awaitingActionCompletion,
          state
        };
      }
      return awaitingCompletion(this, message2, state, () => {
        changeState(this, message2.params.data.state);
        state.resolve({
          accepted: true,
          signedTx: message2.params.data.state
        });
        return {
          handler: channelOpen
        };
      });
    };
    const {
      sign
    } = state;
    await signAndNotify(this, `channels.${action}_tx`, message.params.data, async tx => sign(tx, {
      updates: message.params.data.updates
    }));
    return {
      handler: awaitingActionCompletion,
      state
    };
  }

  /**
   * Withdraw coins from the channel
   *
   * After the channel had been opened any of the participants can initiate a withdrawal.
   * The process closely resembles the update. The most notable difference is that the
   * transaction has been co-signed: it is channel_withdraw_tx and after the procedure
   * is finished - it is being posted on-chain.
   *
   * Any of the participants can initiate a withdrawal. The only requirements are:
   *
   *   - Channel is already opened
   *   - No off-chain update/deposit/withdrawal is currently being performed
   *   - Channel is not being closed or in a solo closing state
   *   - The withdrawal amount must be equal to or greater than zero, and cannot exceed
   *     the available balance on the channel (minus the channel_reserve)
   *
   * After the other party had signed the withdraw transaction, the transaction is posted
   * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.
   * After computing transaction hash it can be tracked on the chain: entering the mempool,
   * block inclusion and a number of confirmations.
   *
   * After the minimum_depth block confirmations onOwnWithdrawLocked callback is called
   * (without any arguments).
   *
   * When the other party had confirmed that the block height needed is reached
   * onWithdrawLocked callback is called (without any arguments).
   *
   * @param amount - Amount of coins to withdraw
   * @param sign - Function which verifies and signs withdraw transaction
   * @param callbacks - Callbacks
   * @example
   * ```js
   * channel.withdraw(
   *   100,
   *   async (tx) => await account.signTransaction(tx),
   *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }
   * ).then(({ accepted, signedTx }) => {
   *   if (accepted) {
   *     console.log('Withdrawal has been accepted')
   *   } else {
   *     console.log('Withdrawal has been rejected')
   *   }
   * })
   * ```
   */
  async withdraw(amount, sign, {
    onOnChainTx,
    onOwnWithdrawLocked,
    onWithdrawLocked
  } = {}) {
    return this.enqueueAction(() => {
      notify(this, 'channels.withdraw', {
        amount
      });
      return {
        handler: async (_, message, state) => this.awaitingActionTx('withdraw', message, state),
        state: {
          sign,
          onOnChainTx,
          onOwnWithdrawLocked,
          onWithdrawLocked
        }
      };
    });
  }

  /**
   * Deposit coins into the channel
   *
   * After the channel had been opened any of the participants can initiate a deposit.
   * The process closely resembles the update. The most notable difference is that the
   * transaction has been co-signed: it is channel_deposit_tx and after the procedure
   * is finished - it is being posted on-chain.
   *
   * Any of the participants can initiate a deposit. The only requirements are:
   *
   *   - Channel is already opened
   *   - No off-chain update/deposit/withdrawal is currently being performed
   *   - Channel is not being closed or in a solo closing state
   *   - The deposit amount must be equal to or greater than zero, and cannot exceed
   *     the available balance on the channel (minus the channel_reserve)
   *
   * After the other party had signed the deposit transaction, the transaction is posted
   * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.
   * After computing transaction hash it can be tracked on the chain: entering the mempool,
   * block inclusion and a number of confirmations.
   *
   * After the minimum_depth block confirmations onOwnDepositLocked callback is called
   * (without any arguments).
   *
   * When the other party had confirmed that the block height needed is reached
   * onDepositLocked callback is called (without any arguments).
   *
   * @param amount - Amount of coins to deposit
   * @param sign - Function which verifies and signs deposit transaction
   * @param callbacks - Callbacks
   * @example
   * ```js
   * channel.deposit(
   *   100,
   *   async (tx) => await account.signTransaction(tx),
   *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }
   * ).then(({ accepted, state }) => {
   *   if (accepted) {
   *     console.log('Deposit has been accepted')
   *     console.log('The new state is:', state)
   *   } else {
   *     console.log('Deposit has been rejected')
   *   }
   * })
   * ```
   */
  async deposit(amount, sign, {
    onOnChainTx,
    onOwnDepositLocked,
    onDepositLocked
  } = {}) {
    return this.enqueueAction(() => {
      notify(this, 'channels.deposit', {
        amount
      });
      return {
        handler: async (_, message, state) => this.awaitingActionTx('deposit', message, state),
        state: {
          sign,
          onOnChainTx,
          onOwnDepositLocked,
          onDepositLocked
        }
      };
    });
  }

  /**
   * Send generic message
   *
   * If message is an object it will be serialized into JSON string
   * before sending.
   *
   * If there is ongoing update that has not yet been finished the message
   * will be sent after that update is finalized.
   *
   * @param message - Message
   * @param recipient - Address of the recipient
   * @example
   * ```js
   * channel.sendMessage(
   *   'hello world',
   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'
   * )
   * ```
   */
  async sendMessage(message, recipient) {
    const info = typeof message === 'object' ? JSON.stringify(message) : message;
    if (this.status() === 'connecting') {
      await new Promise(resolve => {
        const onStatusChanged = status => {
          if (status === 'connecting') return;
          resolve();
          this.off('statusChanged', onStatusChanged);
        };
        this.on('statusChanged', onStatusChanged);
      });
      // For some reason we can't immediately send a message when connection is
      // established. Thus we wait 500ms which seems to work.
      await pause(500);
    }
    notify(this, 'channels.message', {
      info,
      to: recipient
    });
  }
}
;// ./src/channel/Contract.ts









function Contract_snakeToPascalObjKeys(obj) {
  return Object.entries(obj).reduce((result, [key, val]) => ({
    ...result,
    [snakeToPascal(key)]: val
  }), {});
}
/**
 * @category state channel
 */
class ChannelContract extends ChannelSpend {
  static async initialize(options) {
    return Base_Channel._initialize(new ChannelContract(), options);
  }

  /**
   * Trigger create contract update
   *
   * The create contract update is creating a contract inside the channel's internal state tree.
   * The update is a change to be applied on top of the latest state.
   *
   * That would create a contract with the poster being the owner of it. Poster commits initially
   * a deposit amount of coins to the new contract.
   *
   * @param options - Options
   * @param options.code - Api encoded compiled AEVM byte code
   * @param options.callData - Api encoded compiled AEVM call data for the code
   * @param options.deposit - Initial amount the owner of the contract commits to it
   * @param options.vmVersion - Version of the Virtual Machine
   * @param options.abiVersion - Version of the Application Binary Interface
   * @param sign - Function which verifies and signs create contract transaction
   * @example
   * ```js
   * channel.createContract({
   *   code: 'cb_HKtpipK4aCgYb17wZ...',
   *   callData: 'cb_1111111111111111...',
   *   deposit: 10,
   *   vmVersion: 3,
   *   abiVersion: 1
   * }).then(({ accepted, signedTx, address }) => {
   *   if (accepted) {
   *     console.log('New contract has been created')
   *     console.log('Contract address:', address)
   *   } else {
   *     console.log('New contract has been rejected')
   *   }
   * })
   * ```
   */
  async createContract({
    code,
    callData,
    deposit,
    vmVersion,
    abiVersion
  }, sign) {
    return this.enqueueAction(() => {
      notify(this, 'channels.update.new_contract', {
        code,
        call_data: callData,
        deposit,
        vm_version: vmVersion,
        abi_version: abiVersion
      });
      return {
        handler: async (_, message, state) => {
          if (message.method !== 'channels.sign.update') {
            return handleUnexpectedMessage(this, message, state);
          }
          await signAndNotify(this, 'channels.update', message.params.data, async tx => state.sign(tx));
          return {
            handler: (_2, message2, state2) => awaitingCompletion(this, message2, state2, () => {
              const params = unpackTx(message2.params.data.state, Tag.SignedTx).encodedTx;
              if (params.tag !== Tag.ChannelOffChainTx) {
                throw new ChannelError(`Tag should be ${Tag[Tag.ChannelOffChainTx]}, got ${Tag[params.tag]} instead`);
              }
              const addressKey = this._options.role === 'initiator' ? 'initiatorId' : 'responderId';
              const owner = this._options[addressKey];
              changeState(this, message2.params.data.state);
              const address = buildContractId(owner, params.round);
              emit(this, 'newContract', address);
              state2.resolve({
                accepted: true,
                address,
                signedTx: message2.params.data.state
              });
              return {
                handler: channelOpen
              };
            }),
            state
          };
        },
        state: {
          sign
        }
      };
    });
  }

  /**
   * Trigger call a contract update
   *
   * The call contract update is calling a preexisting contract inside the channel's
   * internal state tree. The update is a change to be applied on top of the latest state.
   *
   * That would call a contract with the poster being the caller of it. Poster commits
   * an amount of coins to the contract.
   *
   * The call would also create a call object inside the channel state tree. It contains
   * the result of the contract call.
   *
   * It is worth mentioning that the gas is not consumed, because this is an off-chain
   * contract call. It would be consumed if it were an on-chain one. This could happen
   * if a call with a similar computation amount is to be forced on-chain.
   *
   * @param options - Options
   * @param sign - Function which verifies and signs contract call transaction
   * @example
   * ```js
   * channel.callContract({
   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',
   *   callData: 'cb_1111111111111111...',
   *   amount: 0,
   *   abiVersion: 1
   * }).then(({ accepted, signedTx }) => {
   *   if (accepted) {
   *     console.log('Contract called succesfully')
   *   } else {
   *     console.log('Contract call has been rejected')
   *   }
   * })
   * ```
   */
  async callContract({
    amount,
    callData,
    contract,
    abiVersion
  }, sign) {
    return this.enqueueAction(() => {
      notify(this, 'channels.update.call_contract', {
        amount,
        call_data: callData,
        contract_id: contract,
        abi_version: abiVersion
      });
      return {
        handler: async (_, message, state) => {
          if (message.method !== 'channels.sign.update') {
            return handleUnexpectedMessage(this, message, state);
          }
          await signAndNotify(this, 'channels.update', message.params.data, async tx => state.sign(tx, {
            updates: message.params.data.updates
          }));
          return {
            handler: (_2, message2, state2) => awaitingCompletion(this, message2, state2, () => {
              changeState(this, message2.params.data.state);
              state2.resolve({
                accepted: true,
                signedTx: message2.params.data.state
              });
              return {
                handler: channelOpen
              };
            }),
            state
          };
        },
        state: {
          sign
        }
      };
    });
  }

  /**
   * Trigger a force progress contract call
   * This call is going on-chain
   * @param options - Options
   * @param sign - Function which verifies and signs contract force progress transaction
   * @param callbacks - Callbacks
   * @example
   * ```js
   * channel.forceProgress({
   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',
   *   callData: 'cb_1111111111111111...',
   *   amount: 0,
   *   abiVersion: 1,
   *   gasPrice: 1000005554
   * }).then(({ accepted, signedTx }) => {
   *   if (accepted) {
   *     console.log('Contract force progress call successful')
   *   } else {
   *     console.log('Contract force progress call has been rejected')
   *   }
   * })
   * ```
   */
  async forceProgress({
    amount,
    callData,
    contract,
    abiVersion,
    gasLimit = 1000000,
    gasPrice = MIN_GAS_PRICE
  }, sign, {
    onOnChainTx
  } = {}) {
    return this.enqueueAction(() => {
      notify(this, 'channels.force_progress', {
        amount,
        call_data: callData,
        contract_id: contract,
        abi_version: abiVersion,
        gas_price: gasPrice,
        gas: gasLimit
      });
      return {
        handler: async (_, message, state) => {
          if (message.method !== 'channels.sign.force_progress_tx') {
            return handleUnexpectedMessage(this, message, state);
          }
          await signAndNotify(this, 'channels.force_progress_sign', message.params.data, async tx => state.sign(tx, {
            updates: message.params.data.updates
          }));
          return {
            handler: (_2, message2, state2) => {
              if (message2.method === 'channels.on_chain_tx') {
                state2.onOnChainTx?.(message2.params.data.tx);
                emit(this, 'onChainTx', message2.params.data.tx, {
                  info: message2.params.data.info,
                  type: message2.params.data.type
                });
                state2.resolve({
                  accepted: true,
                  tx: message2.params.data.tx
                });
                // TODO: shouldn't be unexpected message in this case
              }
              return handleUnexpectedMessage(this, message2, state2);
            },
            state
          };
        },
        state: {
          sign,
          onOnChainTx
        }
      };
    });
  }

  /**
   * Call contract using dry-run
   *
   * In order to get the result of a potential contract call, one might need to
   * dry-run a contract call. It takes the exact same arguments as a call would
   * and returns the call object.
   *
   * The call is executed in the channel's state, but it does not impact the state
   * whatsoever. It uses as an environment the latest channel's state and the current
   * top of the blockchain as seen by the node.
   *
   * @param options - Options
   * @example
   * ```js
   * channel.callContractStatic({
   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',
   *   callData: 'cb_1111111111111111...',
   *   amount: 0,
   *   abiVersion: 1
   * }).then(({ returnValue, gasUsed }) => {
   *   console.log('Returned value:', returnValue)
   *   console.log('Gas used:', gasUsed)
   * })
   * ```
   */
  async callContractStatic({
    amount,
    callData,
    contract,
    abiVersion
  }) {
    return Contract_snakeToPascalObjKeys(await call(this, 'channels.dry_run.call_contract', {
      amount,
      call_data: callData,
      contract_id: contract,
      abi_version: abiVersion
    }));
  }

  /**
   * Get contract call result
   *
   * The combination of a caller, contract and a round of execution determines the
   * contract call. Providing an incorrect set of those results in an error response.
   *
   * @param options - Options
   * @param options.caller - Address of contract caller
   * @param options.contract - Address of the contract
   * @param options.round - Round when contract was called
   * @example
   * ```js
   * channel.getContractCall({
   *   caller: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',
   *   round: 3
   * }).then(({ returnType, returnValue }) => {
   *   if (returnType === 'ok') console.log(returnValue)
   * })
   * ```
   */
  async getContractCall({
    caller,
    contract,
    round
  }) {
    return Contract_snakeToPascalObjKeys(await call(this, 'channels.get.contract_call', {
      caller_id: caller,
      contract_id: contract,
      round
    }));
  }

  /**
   * Get the latest contract state
   *
   * @param contract - Address of the contract
   * @example
   * ```js
   * channel.getContractState(
   *   'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa'
   * ).then(({ contract }) => {
   *   console.log('deposit:', contract.deposit)
   * })
   * ```
   */
  async getContractState(contract) {
    const result = await call(this, 'channels.get.contract', {
      pubkey: contract
    });
    return Contract_snakeToPascalObjKeys({
      ...result,
      contract: Contract_snakeToPascalObjKeys(result.contract)
    });
  }

  /**
   * Clean up all locally stored contract calls
   *
   * Contract calls are kept locally in order for the participant to be able to look them up.
   * They consume memory and in order for the participant to free it - one can prune all messages.
   * This cleans up all locally stored contract calls and those will no longer be available for
   * fetching and inspection.
   */
  async cleanContractCalls() {
    return this.enqueueAction(() => {
      notify(this, 'channels.clean_contract_calls');
      return {
        handler(_, message, state) {
          if (message.method === 'channels.calls_pruned.reply') {
            state.resolve();
            return {
              handler: channelOpen
            };
          }
          state.reject(new UnexpectedChannelMessageError('Unexpected message received'));
          return {
            handler: channelClosed
          };
        }
      };
    });
  }
}
// EXTERNAL MODULE: external "isomorphic-ws"
var external_isomorphic_ws_ = __webpack_require__(7250);
var external_isomorphic_ws_default = /*#__PURE__*/__webpack_require__.n(external_isomorphic_ws_);
;// ./src/MiddlewareSubscriber.ts
function MiddlewareSubscriber_classPrivateMethodInitSpec(e, a) { MiddlewareSubscriber_checkPrivateRedeclaration(e, a), a.add(e); }
function MiddlewareSubscriber_classPrivateFieldInitSpec(e, t, a) { MiddlewareSubscriber_checkPrivateRedeclaration(e, t), t.set(e, a); }
function MiddlewareSubscriber_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateGetter(s, r, a) { return a(MiddlewareSubscriber_assertClassBrand(s, r)); }
function MiddlewareSubscriber_classPrivateFieldSet(s, a, r) { return s.set(MiddlewareSubscriber_assertClassBrand(s, a), r), r; }
function MiddlewareSubscriber_classPrivateFieldGet(s, a) { return s.get(MiddlewareSubscriber_assertClassBrand(s, a)); }
function MiddlewareSubscriber_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/* eslint-disable max-classes-per-file */


var Source = /*#__PURE__*/function (Source) {
  Source["Middleware"] = "mdw";
  Source["Node"] = "node";
  Source["All"] = "all";
  return Source;
}(Source || {});
class MiddlewareSubscriberError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'MiddlewareSubscriberError';
  }
}
class MiddlewareSubscriberDisconnected extends MiddlewareSubscriberError {
  constructor(closeEvent) {
    super('Connection closed');
    this.closeEvent = closeEvent;
    this.name = 'MiddlewareSubscriberDisconnected';
  }
}

/**
 * @category middleware
 */
var _subscriptions = /*#__PURE__*/new WeakMap();
var _requestQueue = /*#__PURE__*/new WeakMap();
var _webSocket = /*#__PURE__*/new WeakMap();
var _MiddlewareSubscriber_brand = /*#__PURE__*/new WeakSet();
class MiddlewareSubscriber {
  get webSocket() {
    return MiddlewareSubscriber_classPrivateFieldGet(_webSocket, this);
  }
  constructor(url) {
    MiddlewareSubscriber_classPrivateMethodInitSpec(this, _MiddlewareSubscriber_brand);
    MiddlewareSubscriber_classPrivateFieldInitSpec(this, _subscriptions, []);
    MiddlewareSubscriber_classPrivateFieldInitSpec(this, _requestQueue, []);
    MiddlewareSubscriber_classPrivateFieldInitSpec(this, _webSocket, void 0);
    this.url = url;
  }
  async reconnect() {
    MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _disconnect).call(this);
    MiddlewareSubscriber_classPrivateFieldSet(_webSocket, this, await new Promise(resolve => {
      const webSocket = new (external_isomorphic_ws_default())(this.url);
      Object.assign(webSocket, {
        onopen: () => resolve(webSocket),
        onerror: errorEvent => {
          MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _emit).call(this, () => true, undefined, errorEvent.error);
        },
        onmessage: event => {
          if (typeof event.data !== 'string') {
            throw new InternalError(`Unknown incoming message type: ${typeof event.data}`);
          }
          MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _messageHandler).call(this, JSON.parse(event.data));
        },
        onclose: event => {
          MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _emit).call(this, () => true, undefined, new MiddlewareSubscriberDisconnected(event));
          MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _disconnect).call(this, true);
        }
      });
    }));
    await Promise.all([..._classPrivateGetter(_MiddlewareSubscriber_brand, this, _get_targets)].map(target => MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _sendSubscribe).call(this, true, target)));
  }
  // TODO: replace p?: any with a proper type definition

  subscribeKeyBlocks(cb) {
    return MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _subscribe).call(this, 'KeyBlocks', Source.Middleware, cb);
  }
  subscribeKeyBlocksNode(cb) {
    return MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _subscribe).call(this, 'KeyBlocks', Source.Node, cb);
  }
  subscribeKeyBlocksAll(cb) {
    return MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _subscribe).call(this, 'KeyBlocks', Source.All, cb);
  }
  subscribeMicroBlocks(cb) {
    return MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _subscribe).call(this, 'MicroBlocks', Source.Middleware, cb);
  }
  subscribeMicroBlocksNode(cb) {
    return MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _subscribe).call(this, 'MicroBlocks', Source.Node, cb);
  }
  subscribeMicroBlocksAll(cb) {
    return MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _subscribe).call(this, 'MicroBlocks', Source.All, cb);
  }
  subscribeTransactions(cb) {
    return MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _subscribe).call(this, 'Transactions', Source.Middleware, cb);
  }
  subscribeTransactionsNode(cb) {
    return MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _subscribe).call(this, 'Transactions', Source.Node, cb);
  }
  subscribeTransactionsAll(cb) {
    return MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _subscribe).call(this, 'Transactions', Source.All, cb);
  }
  subscribeObject(target, cb) {
    return MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _subscribe).call(this, target, Source.Middleware, cb);
  }
  subscribeObjectNode(target, cb) {
    return MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _subscribe).call(this, target, Source.Node, cb);
  }
  subscribeObjectAll(target, cb) {
    return MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _subscribe).call(this, target, Source.All, cb);
  }
}
function _get_targets(_this) {
  return new Set(MiddlewareSubscriber_classPrivateFieldGet(_subscriptions, _this).map(([target]) => target));
}
function _sendMessage(message) {
  if (MiddlewareSubscriber_classPrivateFieldGet(_webSocket, this) == null) throw new UnexpectedTsError();
  MiddlewareSubscriber_classPrivateFieldGet(_webSocket, this).send(JSON.stringify(message));
}
function _sendSubscribe(isSubscribe, target) {
  if (MiddlewareSubscriber_classPrivateFieldGet(_webSocket, this) == null) return;
  const payload = ['KeyBlocks', 'MicroBlocks', 'Transactions'].includes(target) ? target : 'Object';
  MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _sendMessage).call(this, {
    op: isSubscribe ? 'Subscribe' : 'Unsubscribe',
    payload,
    ...(payload === 'Object' && {
      target
    })
  });
  MiddlewareSubscriber_classPrivateFieldGet(_requestQueue, this).push([isSubscribe, target]);
}
function _emit(condition, p, e) {
  MiddlewareSubscriber_classPrivateFieldGet(_subscriptions, this).filter(([target, source]) => condition(target, source)).forEach(([,, cb]) => cb(p, e));
}
function _disconnect(onlyReset = false) {
  if (MiddlewareSubscriber_classPrivateFieldGet(_webSocket, this) == null) return;
  if (!onlyReset) MiddlewareSubscriber_classPrivateFieldGet(_webSocket, this).close();
  Object.assign(MiddlewareSubscriber_classPrivateFieldGet(_webSocket, this), {
    onopen: undefined,
    onerror: undefined,
    onmessage: undefined
  });
  MiddlewareSubscriber_classPrivateFieldSet(_webSocket, this, undefined);
}
function _messageHandler(message) {
  if (typeof message === 'string' || Array.isArray(message)) {
    const request = MiddlewareSubscriber_classPrivateFieldGet(_requestQueue, this).shift();
    if (request == null) throw new InternalError('Request queue is empty');
    const [isSubscribe, target] = request;
    let error;
    if (typeof message === 'string') error = new MiddlewareSubscriberError(message);
    if (message.includes(target) !== isSubscribe) {
      error = new InternalError(`Expected ${target} to be${isSubscribe ? '' : ' not'} included into ${message}`);
    }
    if (error != null) MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _emit).call(this, t => target === t, undefined, error);
    return;
  }
  MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _emit).call(this, (target, source) => (target === message.subscription || target === message.target) && (source === message.source || source === Source.All), message.payload);
}
function _subscribe(target, source, cb) {
  const subscription = [target, source, cb];
  if (_classPrivateGetter(_MiddlewareSubscriber_brand, this, _get_targets).size === 0) this.reconnect();
  if (!_classPrivateGetter(_MiddlewareSubscriber_brand, this, _get_targets).has(target)) MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _sendSubscribe).call(this, true, target);
  MiddlewareSubscriber_classPrivateFieldGet(_subscriptions, this).push(subscription);
  return () => {
    MiddlewareSubscriber_classPrivateFieldSet(_subscriptions, this, MiddlewareSubscriber_classPrivateFieldGet(_subscriptions, this).filter(item => item !== subscription));
    if (!_classPrivateGetter(_MiddlewareSubscriber_brand, this, _get_targets).has(target)) MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _sendSubscribe).call(this, false, target);
    if (_classPrivateGetter(_MiddlewareSubscriber_brand, this, _get_targets).size === 0) MiddlewareSubscriber_assertClassBrand(_MiddlewareSubscriber_brand, this, _disconnect).call(this);
  };
}
;// ./src/apis/middleware/models/parameters.ts
const models_parameters_accept = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
};
const models_parameters_$host = {
  parameterPath: "$host",
  mapper: {
    serializedName: "$host",
    required: true,
    type: {
      name: "String"
    }
  },
  skipEncoding: true
};
const accountId = {
  parameterPath: "accountId",
  mapper: {
    constraints: {
      Pattern: new RegExp("^ak_\\w{38,50}$")
    },
    serializedName: "accountId",
    required: true,
    type: {
      name: "String"
    }
  }
};
const ownedOnly = {
  parameterPath: ["options", "ownedOnly"],
  mapper: {
    serializedName: "owned_only",
    type: {
      name: "Boolean"
    }
  }
};
const parameters_typeParam = {
  parameterPath: ["options", "type"],
  mapper: {
    serializedName: "type",
    type: {
      name: "Enum",
      allowedValues: ["transactions", "aexn", "aex9", "aex141", "contract", "transfers", "claims", "swaps"]
    }
  }
};
const parameters_limit = {
  parameterPath: ["options", "limit"],
  mapper: {
    defaultValue: 10,
    constraints: {
      InclusiveMaximum: 100,
      InclusiveMinimum: 1
    },
    serializedName: "limit",
    type: {
      name: "Number"
    }
  }
};
const scope = {
  parameterPath: ["options", "scope"],
  mapper: {
    constraints: {
      Pattern: new RegExp("(gen):\\d+(-\\d+)?")
    },
    serializedName: "scope",
    type: {
      name: "String"
    }
  }
};
const direction = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction1 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const contract = {
  parameterPath: ["options", "contract"],
  mapper: {
    constraints: {
      Pattern: new RegExp("^ct_\\w{38,50}$")
    },
    serializedName: "contract",
    type: {
      name: "String"
    }
  }
};
const direction2 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction3 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction4 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const by = {
  parameterPath: ["options", "by"],
  mapper: {
    serializedName: "by",
    type: {
      name: "Enum",
      allowedValues: ["creation", "name", "symbol"]
    }
  }
};
const prefix = {
  parameterPath: ["options", "prefix"],
  mapper: {
    serializedName: "prefix",
    type: {
      name: "String"
    }
  }
};
const exact = {
  parameterPath: ["options", "exact"],
  mapper: {
    serializedName: "exact",
    type: {
      name: "String"
    }
  }
};
const direction5 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const contractId = {
  parameterPath: "contractId",
  mapper: {
    constraints: {
      Pattern: new RegExp("^ct_\\w{38,50}$")
    },
    serializedName: "contractId",
    required: true,
    type: {
      name: "String"
    }
  }
};
const direction6 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const templateId = {
  parameterPath: "templateId",
  mapper: {
    serializedName: "templateId",
    required: true,
    type: {
      name: "Number"
    }
  }
};
const direction7 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const tokenId = {
  parameterPath: "tokenId",
  mapper: {
    serializedName: "tokenId",
    required: true,
    type: {
      name: "Number"
    }
  }
};
const direction8 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const parameters_fromParam = {
  parameterPath: ["options", "from"],
  mapper: {
    constraints: {
      Pattern: new RegExp("^ak_\\w{38,50}$")
    },
    serializedName: "from",
    type: {
      name: "String"
    }
  }
};
const to = {
  parameterPath: ["options", "to"],
  mapper: {
    constraints: {
      Pattern: new RegExp("^ak_\\w{38,50}$")
    },
    serializedName: "to",
    type: {
      name: "String"
    }
  }
};
const id = {
  parameterPath: "id",
  mapper: {
    constraints: {
      Pattern: new RegExp("^ct_\\w{38,50}$")
    },
    serializedName: "id",
    required: true,
    type: {
      name: "String"
    }
  }
};
const direction9 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const by1 = {
  parameterPath: ["options", "by"],
  mapper: {
    serializedName: "by",
    type: {
      name: "Enum",
      allowedValues: ["creation", "name", "symbol"]
    }
  }
};
const direction10 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const by2 = {
  parameterPath: ["options", "by"],
  mapper: {
    serializedName: "by",
    type: {
      name: "String"
    }
  }
};
const blockHash = {
  parameterPath: ["options", "blockHash"],
  mapper: {
    constraints: {
      Pattern: new RegExp("^mh_\\w{38,50}$")
    },
    serializedName: "block_hash",
    type: {
      name: "String"
    }
  }
};
const models_parameters_hash = {
  parameterPath: ["options", "hash"],
  mapper: {
    constraints: {
      Pattern: new RegExp("^mh_\\w{38,50}$")
    },
    serializedName: "hash",
    type: {
      name: "String"
    }
  }
};
const direction11 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction12 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const state = {
  parameterPath: ["options", "state"],
  mapper: {
    serializedName: "state",
    type: {
      name: "Enum",
      allowedValues: ["active", "inactive"]
    }
  }
};
const id1 = {
  parameterPath: "id",
  mapper: {
    constraints: {
      Pattern: new RegExp("^ch_\\w{38,50}$")
    },
    serializedName: "id",
    required: true,
    type: {
      name: "String"
    }
  }
};
const direction13 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const contractId1 = {
  parameterPath: ["options", "contractId"],
  mapper: {
    constraints: {
      Pattern: new RegExp("^ct_\\w{38,50}$")
    },
    serializedName: "contract_id",
    type: {
      name: "String"
    }
  }
};
const parameters_event = {
  parameterPath: ["options", "event"],
  mapper: {
    serializedName: "event",
    type: {
      name: "String"
    }
  }
};
const functionParam = {
  parameterPath: ["options", "function"],
  mapper: {
    serializedName: "function",
    type: {
      name: "String"
    }
  }
};
const functionPrefix = {
  parameterPath: ["options", "functionPrefix"],
  mapper: {
    serializedName: "function_prefix",
    type: {
      name: "String"
    }
  }
};
const data = {
  parameterPath: ["options", "data"],
  mapper: {
    serializedName: "data",
    type: {
      name: "String"
    }
  }
};
const aexnArgs = {
  parameterPath: ["options", "aexnArgs"],
  mapper: {
    serializedName: "aexn-args",
    type: {
      name: "Boolean"
    }
  }
};
const direction14 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction15 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction16 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const contractId2 = {
  parameterPath: "contractId",
  mapper: {
    constraints: {
      Pattern: new RegExp("^ct_\\w{38,50}$")
    },
    serializedName: "contract_id",
    required: true,
    type: {
      name: "String"
    }
  }
};
const direction17 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const scope1 = {
  parameterPath: ["options", "scope"],
  mapper: {
    constraints: {
      Pattern: new RegExp("(epoch):\\d+(-\\d+)?")
    },
    serializedName: "scope",
    type: {
      name: "String"
    }
  }
};
const direction18 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const parameters_height = {
  parameterPath: "height",
  mapper: {
    serializedName: "height",
    required: true,
    type: {
      name: "Number"
    }
  }
};
const direction19 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const validator = {
  parameterPath: "validator",
  mapper: {
    constraints: {
      Pattern: new RegExp("^ak_\\w{38,50}$")
    },
    serializedName: "validator",
    required: true,
    type: {
      name: "String"
    }
  }
};
const direction20 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction21 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction22 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const hashOrKbi = {
  parameterPath: "hashOrKbi",
  mapper: {
    serializedName: "hash_or_kbi",
    required: true,
    type: {
      name: "String"
    }
  }
};
const direction23 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const hash1 = {
  parameterPath: "hash",
  mapper: {
    constraints: {
      Pattern: new RegExp("^mh_\\w{38,50}$")
    },
    serializedName: "hash",
    required: true,
    type: {
      name: "String"
    }
  }
};
const ownedBy = {
  parameterPath: ["options", "ownedBy"],
  mapper: {
    constraints: {
      Pattern: new RegExp("^ak_\\w{38,50}$")
    },
    serializedName: "owned_by",
    type: {
      name: "String"
    }
  }
};
const state1 = {
  parameterPath: ["options", "state"],
  mapper: {
    serializedName: "state",
    type: {
      name: "String"
    }
  }
};
const direction24 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction25 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const id2 = {
  parameterPath: "id",
  mapper: {
    serializedName: "id",
    required: true,
    type: {
      name: "String"
    }
  }
};
const direction26 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction27 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction28 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction29 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction30 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction31 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const id3 = {
  parameterPath: "id",
  mapper: {
    constraints: {
      Pattern: new RegExp("^ok_\\w{38,50}$")
    },
    serializedName: "id",
    required: true,
    type: {
      name: "String"
    }
  }
};
const intervalBy = {
  parameterPath: ["options", "intervalBy"],
  mapper: {
    serializedName: "interval_by",
    type: {
      name: "Enum",
      allowedValues: ["day", "week", "month"]
    }
  }
};
const direction32 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const intervalBy1 = {
  parameterPath: ["options", "intervalBy"],
  mapper: {
    serializedName: "interval_by",
    type: {
      name: "Enum",
      allowedValues: ["day", "week", "month"]
    }
  }
};
const minStartDate = {
  parameterPath: ["options", "minStartDate"],
  mapper: {
    serializedName: "min_start_date",
    type: {
      name: "String"
    }
  }
};
const maxStartDate = {
  parameterPath: ["options", "maxStartDate"],
  mapper: {
    serializedName: "max_start_date",
    type: {
      name: "String"
    }
  }
};
const direction33 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const intervalBy2 = {
  parameterPath: ["options", "intervalBy"],
  mapper: {
    serializedName: "interval_by",
    type: {
      name: "Enum",
      allowedValues: ["day", "week", "month"]
    }
  }
};
const typeParam1 = {
  parameterPath: ["options", "type"],
  mapper: {
    serializedName: "type",
    type: {
      name: "Enum",
      allowedValues: ["key", "micro"]
    }
  }
};
const direction34 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const intervalBy3 = {
  parameterPath: ["options", "intervalBy"],
  mapper: {
    serializedName: "interval_by",
    type: {
      name: "Enum",
      allowedValues: ["day", "week", "month"]
    }
  }
};
const direction35 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction36 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const intervalBy4 = {
  parameterPath: ["options", "intervalBy"],
  mapper: {
    serializedName: "interval_by",
    type: {
      name: "Enum",
      allowedValues: ["day", "week", "month"]
    }
  }
};
const direction37 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const intervalBy5 = {
  parameterPath: ["options", "intervalBy"],
  mapper: {
    serializedName: "interval_by",
    type: {
      name: "Enum",
      allowedValues: ["day", "week", "month"]
    }
  }
};
const direction38 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction39 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const intervalBy6 = {
  parameterPath: ["options", "intervalBy"],
  mapper: {
    serializedName: "interval_by",
    type: {
      name: "Enum",
      allowedValues: ["day", "week", "month"]
    }
  }
};
const direction40 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const direction41 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const intervalBy7 = {
  parameterPath: ["options", "intervalBy"],
  mapper: {
    serializedName: "interval_by",
    type: {
      name: "Enum",
      allowedValues: ["day", "week", "month"]
    }
  }
};
const direction42 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const intervalBy8 = {
  parameterPath: ["options", "intervalBy"],
  mapper: {
    serializedName: "interval_by",
    type: {
      name: "Enum",
      allowedValues: ["day", "week", "month"]
    }
  }
};
const txType = {
  parameterPath: ["options", "txType"],
  mapper: {
    serializedName: "tx_type",
    type: {
      name: "String"
    }
  }
};
const direction43 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const typeParam2 = {
  parameterPath: ["options", "type"],
  mapper: {
    serializedName: "type",
    type: {
      name: "Sequence",
      element: {
        type: {
          name: "Enum",
          allowedValues: ["channel_close_mutual", "channel_close_solo", "channel_create", "channel_deposit", "channel_force_progress", "channel_offchain", "channel_settle", "channel_slash", "channel_snapshot_solo", "channel_withdraw", "contract_call", "contract_create", "ga_attach", "ga_meta", "name_claim", "name_preclaim", "name_revoke", "name_transfer", "name_update", "oracle_extend", "oracle_query", "oracle_register", "oracle_response", "paying_for", "spend"]
        }
      }
    }
  },
  collectionFormat: "Multi"
};
const typeGroup = {
  parameterPath: ["options", "typeGroup"],
  mapper: {
    serializedName: "type_group",
    type: {
      name: "Sequence",
      element: {
        type: {
          name: "Enum",
          allowedValues: ["channel", "contract", "ga", "name", "oracle", "paying_for", "spend"]
        }
      }
    }
  },
  collectionFormat: "Multi"
};
const account = {
  parameterPath: ["options", "account"],
  mapper: {
    constraints: {
      Pattern: new RegExp("^ak_\\w{38,50}$")
    },
    serializedName: "account",
    type: {
      name: "String"
    }
  }
};
const channel = {
  parameterPath: ["options", "channel"],
  mapper: {
    constraints: {
      Pattern: new RegExp("^ch_\\w{38,50}$")
    },
    serializedName: "channel",
    type: {
      name: "String"
    }
  }
};
const oracle = {
  parameterPath: ["options", "oracle"],
  mapper: {
    constraints: {
      Pattern: new RegExp("^ok_\\w{38,50}$")
    },
    serializedName: "oracle",
    type: {
      name: "String"
    }
  }
};
const senderId = {
  parameterPath: ["options", "senderId"],
  mapper: {
    constraints: {
      Pattern: new RegExp("^ak_\\w{38,50}$")
    },
    serializedName: "sender_id",
    type: {
      name: "String"
    }
  }
};
const recipientId = {
  parameterPath: ["options", "recipientId"],
  mapper: {
    constraints: {
      Pattern: new RegExp("^ak_\\w{38,50}$")
    },
    serializedName: "recipient_id",
    type: {
      name: "String"
    }
  }
};
const entrypoint = {
  parameterPath: ["options", "entrypoint"],
  mapper: {
    serializedName: "entrypoint",
    type: {
      name: "String"
    }
  }
};
const scope2 = {
  parameterPath: ["options", "scope"],
  mapper: {
    constraints: {
      Pattern: new RegExp("(time|gen):\\d+(-\\d+)?")
    },
    serializedName: "scope",
    type: {
      name: "String"
    }
  }
};
const direction44 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const id4 = {
  parameterPath: ["options", "id"],
  mapper: {
    constraints: {
      Pattern: new RegExp("^ak_\\w{38,50}$")
    },
    serializedName: "id",
    type: {
      name: "String"
    }
  }
};
const direction45 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
const hash2 = {
  parameterPath: "hash",
  mapper: {
    constraints: {
      Pattern: new RegExp("^th_\\w{38,50}$")
    },
    serializedName: "hash",
    required: true,
    type: {
      name: "String"
    }
  }
};
const direction46 = {
  parameterPath: ["options", "direction"],
  mapper: {
    serializedName: "direction",
    type: {
      name: "Enum",
      allowedValues: ["forward", "backward"]
    }
  }
};
;// ./src/apis/middleware/models/mappers.ts
const PathsBx0Ya3V3AccountsAccountidActivitiesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsBx0Ya3V3AccountsAccountidActivitiesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Activity"
            }
          }
        }
      }
    }
  }
};
const Activity = {
  type: {
    name: "Composite",
    className: "Activity",
    modelProperties: {
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      blockTime: {
        serializedName: "block_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["SpendTxEvent", "OracleRegisterTxEvent", "OracleExtendTxEvent", "OracleQueryTxEvent", "OracleResponseTxEvent", "NamePreclaimTxEvent", "NameClaimTxEvent", "NameTransferTxEvent", "NameUpdateTxEvent", "NameRevokeTxEvent", "ContractCreateTxEvent", "ContractCallTxEvent", "GaAttachTxEvent", "GaMetaTxEvent", "ChannelCreateTxEvent", "ChannelDepositTxEvent", "ChannelWithdrawTxEvent", "ChannelForceProgressTxEvent", "ChannelCloseMutualTxEvent", "ChannelCloseSoloTxEvent", "ChannelSlashTxEvent", "ChannelSettleTxEvent", "ChannelSnapshotSoloTxEvent", "ChannelSetDelegatesTxEvent", "ChannelOffchainTxEvent", "ChannelClientReconnectTxEvent", "PayingForTxEvent"]
        }
      },
      payload: {
        serializedName: "payload",
        type: {
          name: "Composite",
          className: "ActivityPayload"
        }
      }
    }
  }
};
const ActivityPayload = {
  type: {
    name: "Composite",
    className: "ActivityPayload",
    modelProperties: {
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        type: {
          name: "String"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        type: {
          name: "Number"
        }
      },
      encodedTx: {
        constraints: {
          Pattern: new RegExp("^tx_\\w+$")
        },
        serializedName: "encoded_tx",
        type: {
          name: "String"
        }
      },
      hash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "hash",
        type: {
          name: "String"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        type: {
          name: "UnixTime"
        }
      },
      signatures: {
        serializedName: "signatures",
        type: {
          name: "Sequence",
          element: {
            constraints: {
              Pattern: new RegExp("^sg_\\w+$")
            },
            type: {
              name: "String"
            }
          }
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "Tx"
        }
      },
      amount: {
        serializedName: "amount",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      contractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract_id",
        type: {
          name: "String"
        }
      },
      logIdx: {
        serializedName: "log_idx",
        type: {
          name: "Number"
        }
      },
      recipientId: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "recipient_id",
        type: {
          name: "String"
        }
      },
      senderId: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "sender_id",
        type: {
          name: "String"
        }
      },
      txHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "tx_hash",
        type: {
          name: "String"
        }
      },
      recipient: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "recipient",
        type: {
          name: "String"
        }
      },
      sender: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "sender",
        type: {
          name: "String"
        }
      },
      tokenId: {
        serializedName: "token_id",
        type: {
          name: "Number"
        }
      },
      contractTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "contract_tx_hash",
        type: {
          name: "String"
        }
      },
      callTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "call_tx_hash",
        type: {
          name: "String"
        }
      },
      function: {
        serializedName: "function",
        type: {
          name: "String"
        }
      },
      internalTx: {
        serializedName: "internal_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      height: {
        serializedName: "height",
        type: {
          name: "Number"
        }
      },
      kind: {
        serializedName: "kind",
        type: {
          name: "Enum",
          allowedValues: ["accounts_extra_lima", "accounts_fortuna", "accounts_genesis", "accounts_lima", "accounts_minerva", "contracts_lima", "reward_dev", "reward_block", "fee_refund_oracle", "fee_lock_name", "fee_refund_name", "fee_spend_name", "reward_oracle"]
        }
      },
      refTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "ref_tx_hash",
        type: {
          name: "String"
        }
      }
    }
  }
};
const mappers_Tx = {
  type: {
    name: "Composite",
    className: "Tx",
    modelProperties: {
      recipientId: {
        serializedName: "recipient_id",
        type: {
          name: "String"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      senderId: {
        serializedName: "sender_id",
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      payload: {
        serializedName: "payload",
        type: {
          name: "String"
        }
      },
      initiatorId: {
        serializedName: "initiator_id",
        type: {
          name: "String"
        }
      },
      initiatorAmount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "initiator_amount",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      responderId: {
        serializedName: "responder_id",
        type: {
          name: "String"
        }
      },
      responderAmount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "responder_amount",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      channelReserve: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "channel_reserve",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      lockPeriod: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "lock_period",
        type: {
          name: "Number"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        type: {
          name: "String"
        }
      },
      delegateIds: {
        serializedName: "delegate_ids",
        type: {
          name: "Composite",
          className: "Delegates"
        }
      },
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        type: {
          name: "String"
        }
      },
      round: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "round",
        type: {
          name: "Number"
        }
      },
      toId: {
        serializedName: "to_id",
        type: {
          name: "String"
        }
      },
      update: {
        serializedName: "update",
        type: {
          name: "Composite",
          className: "OffChainUpdate"
        }
      },
      offchainTrees: {
        serializedName: "offchain_trees",
        type: {
          name: "String"
        }
      },
      initiatorAmountFinal: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "initiator_amount_final",
        type: {
          name: "Number"
        }
      },
      responderAmountFinal: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "responder_amount_final",
        type: {
          name: "Number"
        }
      },
      poi: {
        serializedName: "poi",
        type: {
          name: "String"
        }
      },
      initiatorDelegateIds: {
        serializedName: "initiator_delegate_ids",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      responderDelegateIds: {
        serializedName: "responder_delegate_ids",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      queryFormat: {
        serializedName: "query_format",
        type: {
          name: "String"
        }
      },
      responseFormat: {
        serializedName: "response_format",
        type: {
          name: "String"
        }
      },
      queryFee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "query_fee",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      oracleTtl: {
        serializedName: "oracle_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      accountId: {
        serializedName: "account_id",
        type: {
          name: "String"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        type: {
          name: "Number"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        type: {
          name: "String"
        }
      },
      queryTtl: {
        serializedName: "query_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      queryId: {
        serializedName: "query_id",
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        type: {
          name: "String"
        }
      },
      commitmentId: {
        serializedName: "commitment_id",
        type: {
          name: "String"
        }
      },
      name: {
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      nameSalt: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "name_salt",
        type: {
          name: "Number"
        }
      },
      nameFee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "name_fee",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nameId: {
        serializedName: "name_id",
        type: {
          name: "String"
        }
      },
      nameTtl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "name_ttl",
        type: {
          name: "Number"
        }
      },
      pointers: {
        serializedName: "pointers",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NamePointer"
            }
          }
        }
      },
      clientTtl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "client_ttl",
        type: {
          name: "Number"
        }
      },
      ownerId: {
        serializedName: "owner_id",
        type: {
          name: "String"
        }
      },
      code: {
        serializedName: "code",
        type: {
          name: "String"
        }
      },
      vmVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "vm_version",
        type: {
          name: "Number"
        }
      },
      deposit: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "deposit",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      gas: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "gas",
        type: {
          name: "Number"
        }
      },
      gasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas_price",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      callData: {
        serializedName: "call_data",
        type: {
          name: "String"
        }
      },
      callerId: {
        serializedName: "caller_id",
        type: {
          name: "String"
        }
      },
      contractId: {
        serializedName: "contract_id",
        type: {
          name: "String"
        }
      },
      authFun: {
        constraints: {
          Pattern: new RegExp("^(0x|0X)?[a-fA-F0-9]+$")
        },
        serializedName: "auth_fun",
        type: {
          name: "String"
        }
      },
      gaId: {
        serializedName: "ga_id",
        type: {
          name: "String"
        }
      },
      authData: {
        serializedName: "auth_data",
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "SignedTx"
        }
      },
      payerId: {
        serializedName: "payer_id",
        type: {
          name: "String"
        }
      },
      version: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "version",
        required: true,
        type: {
          name: "Number"
        }
      },
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["SpendTx", "ChannelCreateTx", "ChannelDepositTx", "ChannelWithdrawTx", "ChannelForceProgressTx", "ChannelCloseMutualTx", "ChannelCloseSoloTx", "ChannelSlashTx", "ChannelSettleTx", "ChannelSnapshotSoloTx", "ChannelSetDelegatesTx", "OracleRegisterTx", "OracleExtendTx", "OracleQueryTx", "OracleRespondTx", "NamePreclaimTx", "NameClaimTx", "NameUpdateTx", "NameTransferTx", "NameRevokeTx", "ContractCreateTx", "ContractCallTx", "GAAttachTx", "GAMetaTx", "PayingForTx"]
        }
      }
    }
  }
};
const mappers_Delegates = {
  type: {
    name: "Composite",
    className: "Delegates",
    modelProperties: {
      initiator: {
        serializedName: "initiator",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      responder: {
        serializedName: "responder",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const mappers_OffChainUpdate = {
  serializedName: "OffChainUpdate",
  type: {
    name: "Composite",
    className: "OffChainUpdate",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: {
      serializedName: "op",
      clientName: "op"
    },
    modelProperties: {
      op: {
        serializedName: "op",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const mappers_RelativeTTL = {
  type: {
    name: "Composite",
    className: "RelativeTTL",
    modelProperties: {
      type: {
        defaultValue: "delta",
        isConstant: true,
        serializedName: "type",
        type: {
          name: "String"
        }
      },
      value: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "value",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const mappers_Ttl = {
  type: {
    name: "Composite",
    className: "Ttl",
    modelProperties: {
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["delta", "block"]
        }
      },
      value: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "value",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const mappers_NamePointer = {
  type: {
    name: "Composite",
    className: "NamePointer",
    modelProperties: {
      key: {
        serializedName: "key",
        required: true,
        type: {
          name: "String"
        }
      },
      encodedKey: {
        serializedName: "encoded_key",
        type: {
          name: "String"
        }
      },
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const mappers_SignedTx = {
  type: {
    name: "Composite",
    className: "SignedTx",
    modelProperties: {
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "Tx"
        }
      },
      blockHeight: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: -1
        },
        serializedName: "block_height",
        type: {
          name: "Number"
        }
      },
      blockHash: {
        serializedName: "block_hash",
        type: {
          name: "String"
        }
      },
      hash: {
        serializedName: "hash",
        type: {
          name: "String"
        }
      },
      encodedTx: {
        serializedName: "encoded_tx",
        type: {
          name: "String"
        }
      },
      signatures: {
        serializedName: "signatures",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const PaginatedResponse = {
  type: {
    name: "Composite",
    className: "PaginatedResponse",
    modelProperties: {
      next: {
        serializedName: "next",
        required: true,
        nullable: true,
        type: {
          name: "String"
        }
      },
      prev: {
        serializedName: "prev",
        required: true,
        nullable: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ErrorResponse = {
  type: {
    name: "Composite",
    className: "ErrorResponse",
    modelProperties: {
      error: {
        serializedName: "error",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths1Q9E32FV3AccountsAccountidAex141TokensGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1Q9E32FV3AccountsAccountidAex141TokensGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex141TokenResponse"
            }
          }
        }
      }
    }
  }
};
const Aex141TokenResponse = {
  type: {
    name: "Composite",
    className: "Aex141TokenResponse",
    modelProperties: {
      contractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      ownerId: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "owner_id",
        type: {
          name: "String"
        }
      },
      tokenId: {
        serializedName: "token_id",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsZ92TkfV3AccountsAccountidAex9BalancesGetResponses200ContentApplicationJsonSchemaAllof1 = {
  type: {
    name: "Composite",
    className: "PathsZ92TkfV3AccountsAccountidAex9BalancesGetResponses200ContentApplicationJsonSchemaAllof1",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex9BalanceResponse"
            }
          }
        }
      }
    }
  }
};
const Aex9BalanceResponse = {
  type: {
    name: "Composite",
    className: "Aex9BalanceResponse",
    modelProperties: {
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      blockHash: {
        serializedName: "block_hash",
        required: true,
        type: {
          name: "Number"
        }
      },
      contractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      decimals: {
        serializedName: "decimals",
        required: true,
        type: {
          name: "Number"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      tokenName: {
        serializedName: "token_name",
        required: true,
        type: {
          name: "String"
        }
      },
      tokenSymbol: {
        serializedName: "token_symbol",
        required: true,
        type: {
          name: "String"
        }
      },
      txHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      txIndex: {
        serializedName: "tx_index",
        required: true,
        type: {
          name: "Number"
        }
      },
      txType: {
        serializedName: "tx_type",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths10R8Q7PV3AccountsAccountidDexSwapsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths10R8Q7PV3AccountsAccountidDexSwapsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DexSwap"
            }
          }
        }
      }
    }
  }
};
const DexSwap = {
  type: {
    name: "Composite",
    className: "DexSwap",
    modelProperties: {
      amounts: {
        serializedName: "amounts",
        type: {
          name: "Composite",
          className: "DexSwapAmounts"
        }
      },
      action: {
        serializedName: "action",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["SWAP", "BUY", "SELL"]
        }
      },
      caller: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "caller",
        required: true,
        type: {
          name: "String"
        }
      },
      fromToken: {
        serializedName: "from_token",
        required: true,
        type: {
          name: "String"
        }
      },
      toToken: {
        serializedName: "to_token",
        required: true,
        type: {
          name: "String"
        }
      },
      logIdx: {
        serializedName: "log_idx",
        required: true,
        type: {
          name: "Number"
        }
      },
      toAccount: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "to_account",
        required: true,
        type: {
          name: "String"
        }
      },
      txHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      fromContract: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "from_contract",
        required: true,
        type: {
          name: "String"
        }
      },
      toContract: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "to_contract",
        required: true,
        type: {
          name: "String"
        }
      },
      fromAmount: {
        serializedName: "from_amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      toAmount: {
        serializedName: "to_amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fromDecimals: {
        serializedName: "from_decimals",
        required: true,
        type: {
          name: "Number"
        }
      },
      toDecimals: {
        serializedName: "to_decimals",
        required: true,
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const DexSwapAmounts = {
  type: {
    name: "Composite",
    className: "DexSwapAmounts",
    modelProperties: {
      amount0In: {
        serializedName: "amount0_in",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      amount1In: {
        serializedName: "amount1_in",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      amount0Out: {
        serializedName: "amount0_out",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      amount1Out: {
        serializedName: "amount1_out",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      }
    }
  }
};
const Paths16G4GzrV3AccountsAccountidNamesClaimsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths16G4GzrV3AccountsAccountidNamesClaimsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NameClaim"
            }
          }
        }
      }
    }
  }
};
const NameClaim = {
  type: {
    name: "Composite",
    className: "NameClaim",
    modelProperties: {
      activeFrom: {
        serializedName: "active_from",
        required: true,
        type: {
          name: "Number"
        }
      },
      sourceTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "source_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      sourceTxType: {
        serializedName: "source_tx_type",
        required: true,
        type: {
          name: "String"
        }
      },
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "NameClaimTx"
        }
      },
      internalSource: {
        serializedName: "internal_source",
        type: {
          name: "Boolean"
        }
      }
    }
  }
};
const mappers_NameClaimTx = {
  type: {
    name: "Composite",
    className: "NameClaimTx",
    modelProperties: {
      name: {
        serializedName: "name",
        required: true,
        type: {
          name: "String"
        }
      },
      nameSalt: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "name_salt",
        required: true,
        type: {
          name: "Number"
        }
      },
      nameFee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "name_fee",
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const NotFoundResponse = {
  type: {
    name: "Composite",
    className: "NotFoundResponse",
    modelProperties: {
      error: {
        serializedName: "error",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PathsA60QxwV3AccountsAccountidNamesPointeesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsA60QxwV3AccountsAccountidNamesPointeesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Pointee"
            }
          }
        }
      }
    }
  }
};
const Pointee = {
  type: {
    name: "Composite",
    className: "Pointee",
    modelProperties: {
      active: {
        serializedName: "active",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      name: {
        constraints: {
          Pattern: new RegExp("^\\w+\\.chain$")
        },
        serializedName: "name",
        required: true,
        type: {
          name: "String"
        }
      },
      key: {
        serializedName: "key",
        required: true,
        type: {
          name: "String"
        }
      },
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "NameUpdateTx"
        }
      },
      sourceTxType: {
        serializedName: "source_tx_type",
        required: true,
        type: {
          name: "String"
        }
      },
      sourceTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "source_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      blockTime: {
        serializedName: "block_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      }
    }
  }
};
const mappers_NameUpdateTx = {
  type: {
    name: "Composite",
    className: "NameUpdateTx",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nameTtl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "name_ttl",
        required: true,
        type: {
          name: "Number"
        }
      },
      pointers: {
        serializedName: "pointers",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NamePointer"
            }
          }
        }
      },
      clientTtl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "client_ttl",
        required: true,
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsXcg812V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsXcg812V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      contractCreateTx: {
        serializedName: "contract_create_tx",
        type: {
          name: "Composite",
          className: "Get200ApplicationJsonProperties"
        }
      },
      contractCallTx: {
        serializedName: "contract_call_tx",
        type: {
          name: "Composite",
          className: "PathsEvgmfsV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesContractCallTx"
        }
      },
      gaAttachTx: {
        serializedName: "ga_attach_tx",
        type: {
          name: "Composite",
          className: "Paths1Mat0BzV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesGaAttachTx"
        }
      },
      gaMetaTx: {
        serializedName: "ga_meta_tx",
        type: {
          name: "Composite",
          className: "Paths1Smy8TV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesGaMetaTx"
        }
      },
      channelCloseMutualTx: {
        serializedName: "channel_close_mutual_tx",
        type: {
          name: "Composite",
          className: "PathsTachlnV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCloseMutualTx"
        }
      },
      channelCloseSoloTx: {
        serializedName: "channel_close_solo_tx",
        type: {
          name: "Composite",
          className: "Paths1AeqodeV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCloseSoloTx"
        }
      },
      channelCreateTx: {
        serializedName: "channel_create_tx",
        type: {
          name: "Composite",
          className: "PathsGp6EyrV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCreateTx"
        }
      },
      channelDepositTx: {
        serializedName: "channel_deposit_tx",
        type: {
          name: "Composite",
          className: "Paths10Z6Jt8V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelDepositTx"
        }
      },
      channelForceProgressTx: {
        serializedName: "channel_force_progress_tx",
        type: {
          name: "Composite",
          className: "Paths1Jkl3L3V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelForceProgressTx"
        }
      },
      channelSetDelegatesTx: {
        serializedName: "channel_set_delegates_tx",
        type: {
          name: "Composite",
          className: "PathsN9Iv8YV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSetDelegatesTx"
        }
      },
      channelSettleTx: {
        serializedName: "channel_settle_tx",
        type: {
          name: "Composite",
          className: "PathsCsym65V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSettleTx"
        }
      },
      channelSlashTx: {
        serializedName: "channel_slash_tx",
        type: {
          name: "Composite",
          className: "PathsEwav40V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSlashTx"
        }
      },
      channelSnapshotSoloTx: {
        serializedName: "channel_snapshot_solo_tx",
        type: {
          name: "Composite",
          className: "Paths5Ehb0PV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSnapshotSoloTx"
        }
      },
      channelWithdrawTx: {
        serializedName: "channel_withdraw_tx",
        type: {
          name: "Composite",
          className: "Paths1Qk8BkgV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelWithdrawTx"
        }
      },
      nameClaimTx: {
        serializedName: "name_claim_tx",
        type: {
          name: "Composite",
          className: "PathsC7WhtoV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameClaimTx"
        }
      },
      namePreclaimTx: {
        serializedName: "name_preclaim_tx",
        type: {
          name: "Composite",
          className: "Paths1R4Z885V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNamePreclaimTx"
        }
      },
      nameRevokeTx: {
        serializedName: "name_revoke_tx",
        type: {
          name: "Composite",
          className: "PathsKrpz02V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameRevokeTx"
        }
      },
      nameTransferTx: {
        serializedName: "name_transfer_tx",
        type: {
          name: "Composite",
          className: "PathsPs07B4V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameTransferTx"
        }
      },
      nameUpdateTx: {
        serializedName: "name_update_tx",
        type: {
          name: "Composite",
          className: "PathsTug6HrV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameUpdateTx"
        }
      },
      oracleExtendTx: {
        serializedName: "oracle_extend_tx",
        type: {
          name: "Composite",
          className: "Paths17Dchb7V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleExtendTx"
        }
      },
      oracleQueryTx: {
        serializedName: "oracle_query_tx",
        type: {
          name: "Composite",
          className: "Paths1Ngkd7FV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleQueryTx"
        }
      },
      oracleRegisterTx: {
        serializedName: "oracle_register_tx",
        type: {
          name: "Composite",
          className: "PathsMvqgifV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleRegisterTx"
        }
      },
      oracleResponseTx: {
        serializedName: "oracle_response_tx",
        type: {
          name: "Composite",
          className: "Paths1U2Ve7RV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleResponseTx"
        }
      },
      payingForTx: {
        serializedName: "paying_for_tx",
        type: {
          name: "Composite",
          className: "Paths1N757S0V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesPayingForTx"
        }
      },
      spendTx: {
        serializedName: "spend_tx",
        type: {
          name: "Composite",
          className: "Paths11Bqs5V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesSpendTx"
        }
      },
      channelOffchainTx: {
        serializedName: "channel_offchain_tx",
        type: {
          name: "Composite",
          className: "Paths4Pjk8DV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelOffchainTx"
        }
      },
      total: {
        serializedName: "total",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Get200ApplicationJsonProperties = {
  type: {
    name: "Composite",
    className: "Get200ApplicationJsonProperties",
    modelProperties: {
      ownerId: {
        serializedName: "owner_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsEvgmfsV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesContractCallTx = {
  type: {
    name: "Composite",
    className: "PathsEvgmfsV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesContractCallTx",
    modelProperties: {
      contractId: {
        serializedName: "contract_id",
        type: {
          name: "Number"
        }
      },
      callerId: {
        serializedName: "caller_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1Mat0BzV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesGaAttachTx = {
  type: {
    name: "Composite",
    className: "Paths1Mat0BzV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesGaAttachTx",
    modelProperties: {
      ownerId: {
        serializedName: "owner_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1Smy8TV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesGaMetaTx = {
  type: {
    name: "Composite",
    className: "Paths1Smy8TV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesGaMetaTx",
    modelProperties: {
      gaId: {
        serializedName: "ga_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsTachlnV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCloseMutualTx = {
  type: {
    name: "Composite",
    className: "PathsTachlnV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCloseMutualTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "Number"
        }
      },
      fromId: {
        serializedName: "from_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1AeqodeV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCloseSoloTx = {
  type: {
    name: "Composite",
    className: "Paths1AeqodeV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCloseSoloTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "Number"
        }
      },
      fromId: {
        serializedName: "from_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsGp6EyrV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCreateTx = {
  type: {
    name: "Composite",
    className: "PathsGp6EyrV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelCreateTx",
    modelProperties: {
      initiatorId: {
        serializedName: "initiator_id",
        type: {
          name: "Number"
        }
      },
      responderId: {
        serializedName: "responder_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths10Z6Jt8V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelDepositTx = {
  type: {
    name: "Composite",
    className: "Paths10Z6Jt8V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelDepositTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "Number"
        }
      },
      fromId: {
        serializedName: "from_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1Jkl3L3V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelForceProgressTx = {
  type: {
    name: "Composite",
    className: "Paths1Jkl3L3V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelForceProgressTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "Number"
        }
      },
      fromId: {
        serializedName: "from_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsN9Iv8YV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSetDelegatesTx = {
  type: {
    name: "Composite",
    className: "PathsN9Iv8YV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSetDelegatesTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "Number"
        }
      },
      fromId: {
        serializedName: "from_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsCsym65V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSettleTx = {
  type: {
    name: "Composite",
    className: "PathsCsym65V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSettleTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "Number"
        }
      },
      fromId: {
        serializedName: "from_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsEwav40V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSlashTx = {
  type: {
    name: "Composite",
    className: "PathsEwav40V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSlashTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "Number"
        }
      },
      fromId: {
        serializedName: "from_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths5Ehb0PV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSnapshotSoloTx = {
  type: {
    name: "Composite",
    className: "Paths5Ehb0PV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelSnapshotSoloTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "Number"
        }
      },
      fromId: {
        serializedName: "from_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1Qk8BkgV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelWithdrawTx = {
  type: {
    name: "Composite",
    className: "Paths1Qk8BkgV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelWithdrawTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "Number"
        }
      },
      toId: {
        serializedName: "to_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsC7WhtoV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameClaimTx = {
  type: {
    name: "Composite",
    className: "PathsC7WhtoV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameClaimTx",
    modelProperties: {
      accountId: {
        serializedName: "account_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1R4Z885V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNamePreclaimTx = {
  type: {
    name: "Composite",
    className: "Paths1R4Z885V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNamePreclaimTx",
    modelProperties: {
      accountId: {
        serializedName: "account_id",
        type: {
          name: "Number"
        }
      },
      commitmentId: {
        serializedName: "commitment_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsKrpz02V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameRevokeTx = {
  type: {
    name: "Composite",
    className: "PathsKrpz02V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameRevokeTx",
    modelProperties: {
      accountId: {
        serializedName: "account_id",
        type: {
          name: "Number"
        }
      },
      nameId: {
        serializedName: "name_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsPs07B4V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameTransferTx = {
  type: {
    name: "Composite",
    className: "PathsPs07B4V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameTransferTx",
    modelProperties: {
      recipientId: {
        serializedName: "recipient_id",
        type: {
          name: "Number"
        }
      },
      accountId: {
        serializedName: "account_id",
        type: {
          name: "Number"
        }
      },
      nameId: {
        serializedName: "name_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsTug6HrV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameUpdateTx = {
  type: {
    name: "Composite",
    className: "PathsTug6HrV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesNameUpdateTx",
    modelProperties: {
      accountId: {
        serializedName: "account_id",
        type: {
          name: "Number"
        }
      },
      nameId: {
        serializedName: "name_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths17Dchb7V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleExtendTx = {
  type: {
    name: "Composite",
    className: "Paths17Dchb7V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleExtendTx",
    modelProperties: {
      oracleId: {
        serializedName: "oracle_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1Ngkd7FV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleQueryTx = {
  type: {
    name: "Composite",
    className: "Paths1Ngkd7FV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleQueryTx",
    modelProperties: {
      senderId: {
        serializedName: "sender_id",
        type: {
          name: "Number"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsMvqgifV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleRegisterTx = {
  type: {
    name: "Composite",
    className: "PathsMvqgifV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleRegisterTx",
    modelProperties: {
      accountId: {
        serializedName: "account_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1U2Ve7RV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleResponseTx = {
  type: {
    name: "Composite",
    className: "Paths1U2Ve7RV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesOracleResponseTx",
    modelProperties: {
      oracleId: {
        serializedName: "oracle_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1N757S0V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesPayingForTx = {
  type: {
    name: "Composite",
    className: "Paths1N757S0V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesPayingForTx",
    modelProperties: {
      payerId: {
        serializedName: "payer_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths11Bqs5V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesSpendTx = {
  type: {
    name: "Composite",
    className: "Paths11Bqs5V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesSpendTx",
    modelProperties: {
      senderId: {
        serializedName: "sender_id",
        type: {
          name: "Number"
        }
      },
      recipientId: {
        serializedName: "recipient_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths4Pjk8DV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelOffchainTx = {
  type: {
    name: "Composite",
    className: "Paths4Pjk8DV3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchemaPropertiesChannelOffchainTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths8I0YgwV3Aex141GetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths8I0YgwV3Aex141GetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex141Response"
            }
          }
        }
      }
    }
  }
};
const Aex141Response = {
  type: {
    name: "Composite",
    className: "Aex141Response",
    modelProperties: {
      baseUrl: {
        serializedName: "base_url",
        required: true,
        type: {
          name: "String"
        }
      },
      contractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      contractTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "contract_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      extensions: {
        serializedName: "extensions",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      limits: {
        serializedName: "limits",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      invalid: {
        serializedName: "invalid",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      creationTime: {
        serializedName: "creation_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsWkpcwaV3Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsWkpcwaV3Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex141TemplatesResponse"
            }
          }
        }
      }
    }
  }
};
const Aex141TemplatesResponse = {
  type: {
    name: "Composite",
    className: "Aex141TemplatesResponse",
    modelProperties: {
      contractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      edition: {
        serializedName: "edition",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      logIdx: {
        serializedName: "log_idx",
        required: true,
        type: {
          name: "Number"
        }
      },
      templateId: {
        serializedName: "template_id",
        required: true,
        type: {
          name: "Number"
        }
      },
      txHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PathsRay4X0V3Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsRay4X0V3Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex141TemplateTokensResponse"
            }
          }
        }
      }
    }
  }
};
const Aex141TemplateTokensResponse = {
  type: {
    name: "Composite",
    className: "Aex141TemplateTokensResponse",
    modelProperties: {
      ownerId: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      logIdx: {
        serializedName: "log_idx",
        required: true,
        type: {
          name: "Number"
        }
      },
      tokenId: {
        serializedName: "token_id",
        required: true,
        type: {
          name: "Number"
        }
      },
      txHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths1TkisghV3Aex141ContractidTokensGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1TkisghV3Aex141ContractidTokensGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex141TokenResponse"
            }
          }
        }
      }
    }
  }
};
const Aex141TokenDetailResponse = {
  type: {
    name: "Composite",
    className: "Aex141TokenDetailResponse",
    modelProperties: {
      contractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      ownerId: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      tokenId: {
        serializedName: "token_id",
        required: true,
        type: {
          name: "Number"
        }
      },
      metadata: {
        serializedName: "metadata",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
const Paths1A8Ah39V3Aex141ContractidTransfersGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1A8Ah39V3Aex141ContractidTransfersGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex141TransferEvent"
            }
          }
        }
      }
    }
  }
};
const Aex141TransferEvent = {
  type: {
    name: "Composite",
    className: "Aex141TransferEvent",
    modelProperties: {
      blockHeight: {
        serializedName: "block_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      contractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      logIdx: {
        serializedName: "log_idx",
        required: true,
        type: {
          name: "Number"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        required: true,
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      recipient: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "recipient",
        required: true,
        type: {
          name: "String"
        }
      },
      sender: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "sender",
        required: true,
        type: {
          name: "String"
        }
      },
      tokenId: {
        serializedName: "token_id",
        required: true,
        type: {
          name: "Number"
        }
      },
      txHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths1Uqqby0V3Aex9GetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1Uqqby0V3Aex9GetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex9Response"
            }
          }
        }
      }
    }
  }
};
const Aex9Response = {
  type: {
    name: "Composite",
    className: "Aex9Response",
    modelProperties: {
      contractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      contractTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "contract_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      initialSupply: {
        serializedName: "initial_supply",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      eventSupply: {
        serializedName: "event_supply",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      decimals: {
        serializedName: "decimals",
        required: true,
        type: {
          name: "Number"
        }
      },
      extensions: {
        serializedName: "extensions",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      holders: {
        serializedName: "holders",
        required: true,
        type: {
          name: "Number"
        }
      },
      name: {
        serializedName: "name",
        required: true,
        type: {
          name: "String"
        }
      },
      symbol: {
        serializedName: "symbol",
        required: true,
        type: {
          name: "String"
        }
      },
      invalid: {
        serializedName: "invalid",
        required: true,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};
const Paths19IxhsmV3Aex9CountGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths19IxhsmV3Aex9CountGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsEeiffwV3Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsEeiffwV3Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex9ContractBalanceResponse"
            }
          }
        }
      }
    }
  }
};
const Aex9ContractBalanceResponse = {
  type: {
    name: "Composite",
    className: "Aex9ContractBalanceResponse",
    modelProperties: {
      accountId: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      blockHash: {
        serializedName: "block_hash",
        required: true,
        type: {
          name: "Number"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "Number"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      lastTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "last_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      lastLogIdx: {
        serializedName: "last_log_idx",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsKr825V3Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsKr825V3Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      account: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "account",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      contract: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths108B3VtV3Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchemaAllof1 = {
  type: {
    name: "Composite",
    className: "Paths108B3VtV3Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchemaAllof1",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Get200ApplicationJsonAllOfPropertiesItemsItem"
            }
          }
        }
      }
    }
  }
};
const Get200ApplicationJsonAllOfPropertiesItemsItem = {
  type: {
    name: "Composite",
    className: "Get200ApplicationJsonAllOfPropertiesItemsItem",
    modelProperties: {
      account: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "account",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      contract: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsQmewnaV3ChannelsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsQmewnaV3ChannelsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Channel"
            }
          }
        }
      }
    }
  }
};
const mappers_Channel = {
  type: {
    name: "Composite",
    className: "Channel",
    modelProperties: {
      active: {
        serializedName: "active",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      channel: {
        constraints: {
          Pattern: new RegExp("^ch_\\w{38,50}$")
        },
        serializedName: "channel",
        required: true,
        type: {
          name: "String"
        }
      },
      channelReserve: {
        serializedName: "channel_reserve",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      delegateIds: {
        serializedName: "delegate_ids",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      initiator: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "initiator",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmount: {
        serializedName: "initiator_amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      lastUpdatedHeight: {
        serializedName: "last_updated_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      lastUpdatedTxType: {
        serializedName: "last_updated_tx_type",
        required: true,
        type: {
          name: "String"
        }
      },
      lastUpdatedTime: {
        serializedName: "last_updated_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      lastUpdatedTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "last_updated_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      lockPeriod: {
        serializedName: "lock_period",
        required: true,
        type: {
          name: "Number"
        }
      },
      lockedUntil: {
        serializedName: "locked_until",
        required: true,
        type: {
          name: "Number"
        }
      },
      responder: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "responder",
        required: true,
        type: {
          name: "String"
        }
      },
      responderAmount: {
        serializedName: "responder_amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      round: {
        serializedName: "round",
        required: true,
        type: {
          name: "Number"
        }
      },
      soloRound: {
        serializedName: "solo_round",
        required: true,
        type: {
          name: "Number"
        }
      },
      stateHash: {
        constraints: {
          Pattern: new RegExp("^st_\\w+$")
        },
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      updatesCount: {
        serializedName: "updates_count",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths18L84JcV3ContractsCallsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths18L84JcV3ContractsCallsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ContractCall"
            }
          }
        }
      }
    }
  }
};
const ContractCall = {
  type: {
    name: "Composite",
    className: "ContractCall",
    modelProperties: {
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      callTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "call_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      contractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      contractTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "contract_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      internalTx: {
        serializedName: "internal_tx",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      localIdx: {
        serializedName: "local_idx",
        required: true,
        type: {
          name: "Number"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths10Kk1UxV3ContractsLogsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths10Kk1UxV3ContractsLogsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ContractLog"
            }
          }
        }
      }
    }
  }
};
const ContractLog = {
  type: {
    name: "Composite",
    className: "ContractLog",
    modelProperties: {
      args: {
        serializedName: "args",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      blockTime: {
        serializedName: "block_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      callTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "call_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      contractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      contractTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "contract_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "String"
        }
      },
      eventHash: {
        serializedName: "event_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      eventName: {
        serializedName: "event_name",
        required: true,
        nullable: true,
        type: {
          name: "String"
        }
      },
      extCallerContractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "ext_caller_contract_id",
        required: true,
        nullable: true,
        type: {
          name: "String"
        }
      },
      extCallerContractTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "ext_caller_contract_tx_hash",
        required: true,
        nullable: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      logIdx: {
        serializedName: "log_idx",
        required: true,
        type: {
          name: "Number"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        required: true,
        type: {
          name: "Number"
        }
      },
      parentContractId: {
        serializedName: "parent_contract_id",
        required: true,
        nullable: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const models_mappers_Contract = {
  type: {
    name: "Composite",
    className: "Contract",
    modelProperties: {
      aexnType: {
        serializedName: "aexn_type",
        required: true,
        nullable: true,
        type: {
          name: "String"
        }
      },
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      contract: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract",
        required: true,
        type: {
          name: "String"
        }
      },
      sourceTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "source_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      sourceTxType: {
        serializedName: "source_tx_type",
        required: true,
        type: {
          name: "String"
        }
      },
      createTx: {
        serializedName: "create_tx",
        type: {
          name: "Composite",
          className: "ContractCreateTx"
        }
      }
    }
  }
};
const mappers_ContractCreateTx = {
  type: {
    name: "Composite",
    className: "ContractCreateTx",
    modelProperties: {
      ownerId: {
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "vm_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      deposit: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "deposit",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      gas: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "gas",
        required: true,
        type: {
          name: "Number"
        }
      },
      gasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas_price",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths9Yfxl2V3DexSwapsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths9Yfxl2V3DexSwapsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DexSwap"
            }
          }
        }
      }
    }
  }
};
const Paths6Vze8ZV3DexContractIdSwapsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths6Vze8ZV3DexContractIdSwapsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DexSwap"
            }
          }
        }
      }
    }
  }
};
const Paths1F8GzwrV3HyperchainEpochsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1F8GzwrV3HyperchainEpochsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "EpochInfo"
            }
          }
        }
      }
    }
  }
};
const EpochInfo = {
  type: {
    name: "Composite",
    className: "EpochInfo",
    modelProperties: {
      epoch: {
        serializedName: "epoch",
        required: true,
        type: {
          name: "Number"
        }
      },
      first: {
        serializedName: "first",
        required: true,
        type: {
          name: "Number"
        }
      },
      last: {
        serializedName: "last",
        required: true,
        type: {
          name: "Number"
        }
      },
      length: {
        serializedName: "length",
        required: true,
        type: {
          name: "Number"
        }
      },
      seed: {
        serializedName: "seed",
        required: true,
        type: {
          name: "String"
        }
      },
      lastPinHeight: {
        serializedName: "last_pin_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      parentBlockHash: {
        serializedName: "parent_block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      lastLeader: {
        serializedName: "last_leader",
        required: true,
        type: {
          name: "String"
        }
      },
      epochStartTime: {
        serializedName: "epoch_start_time",
        required: true,
        type: {
          name: "Number"
        }
      },
      validators: {
        serializedName: "validators",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "EpochInfoValidatorsItem"
            }
          }
        }
      }
    }
  }
};
const EpochInfoValidatorsItem = {
  type: {
    name: "Composite",
    className: "EpochInfoValidatorsItem",
    modelProperties: {
      validator: {
        serializedName: "validator",
        type: {
          name: "String"
        }
      },
      stake: {
        serializedName: "stake",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths7W5O80V3HyperchainScheduleGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths7W5O80V3HyperchainScheduleGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Schedule"
            }
          }
        }
      }
    }
  }
};
const Schedule = {
  type: {
    name: "Composite",
    className: "Schedule",
    modelProperties: {
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      leader: {
        serializedName: "leader",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths1Qg7SclV3HyperchainValidatorsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1Qg7SclV3HyperchainValidatorsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Validator"
            }
          }
        }
      }
    }
  }
};
const Validator = {
  type: {
    name: "Composite",
    className: "Validator",
    modelProperties: {
      epoch: {
        serializedName: "epoch",
        required: true,
        type: {
          name: "Number"
        }
      },
      validator: {
        serializedName: "validator",
        required: true,
        type: {
          name: "String"
        }
      },
      totalStakes: {
        serializedName: "total_stakes",
        required: true,
        type: {
          name: "Number"
        }
      },
      delegates: {
        serializedName: "delegates",
        required: true,
        type: {
          name: "Number"
        }
      },
      rewardsEarned: {
        serializedName: "rewards_earned",
        required: true,
        type: {
          name: "Number"
        }
      },
      pinningHistory: {
        serializedName: "pinning_history",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "Number"
            }
          }
        }
      }
    }
  }
};
const Paths7Ks32NV3HyperchainValidatorsValidatorDelegatesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths7Ks32NV3HyperchainValidatorsValidatorDelegatesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Delegate"
            }
          }
        }
      }
    }
  }
};
const Delegate = {
  type: {
    name: "Composite",
    className: "Delegate",
    modelProperties: {
      epoch: {
        serializedName: "epoch",
        required: true,
        type: {
          name: "Number"
        }
      },
      delegate: {
        serializedName: "delegate",
        required: true,
        type: {
          name: "String"
        }
      },
      stake: {
        serializedName: "stake",
        required: true,
        type: {
          name: "Number"
        }
      },
      validator: {
        serializedName: "validator",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PathsDwhnfdV3HyperchainValidatorsValidatorDelegatesTopGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsDwhnfdV3HyperchainValidatorsValidatorDelegatesTopGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Delegate"
            }
          }
        }
      }
    }
  }
};
const PathsEue6HzV3KeyBlocksGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsEue6HzV3KeyBlocksGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "KeyBlockExtended"
            }
          }
        }
      }
    }
  }
};
const mappers_KeyBlock = {
  type: {
    name: "Composite",
    className: "KeyBlock",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      miner: {
        serializedName: "miner",
        required: true,
        type: {
          name: "String"
        }
      },
      beneficiary: {
        serializedName: "beneficiary",
        required: true,
        type: {
          name: "String"
        }
      },
      target: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "target",
        required: true,
        type: {
          name: "Number"
        }
      },
      pow: {
        constraints: {
          MinItems: 42,
          MaxItems: 42
        },
        serializedName: "pow",
        type: {
          name: "Sequence",
          element: {
            constraints: {
              InclusiveMaximum: 4294967295,
              InclusiveMinimum: 0
            },
            type: {
              name: "Number"
            }
          }
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      time: {
        serializedName: "time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      version: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "version",
        required: true,
        type: {
          name: "Number"
        }
      },
      info: {
        serializedName: "info",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PathsNn60D7V3KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsNn60D7V3KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "MicroBlockExtended"
            }
          }
        }
      }
    }
  }
};
const mappers_MicroBlockHeader = {
  type: {
    name: "Composite",
    className: "MicroBlockHeader",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      pofHash: {
        serializedName: "pof_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      txsHash: {
        serializedName: "txs_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      signature: {
        serializedName: "signature",
        required: true,
        type: {
          name: "String"
        }
      },
      time: {
        serializedName: "time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      version: {
        constraints: {
          InclusiveMaximum: 4294967295,
          InclusiveMinimum: 0
        },
        serializedName: "version",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsXhlqwrV3MicroBlocksHashTransactionsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsXhlqwrV3MicroBlocksHashTransactionsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Transaction"
            }
          }
        }
      }
    }
  }
};
const Transaction = {
  type: {
    name: "Composite",
    className: "Transaction",
    modelProperties: {
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      encodedTx: {
        constraints: {
          Pattern: new RegExp("^tx_\\w+$")
        },
        serializedName: "encoded_tx",
        required: true,
        type: {
          name: "String"
        }
      },
      hash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        required: true,
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      signatures: {
        serializedName: "signatures",
        required: true,
        type: {
          name: "Sequence",
          element: {
            constraints: {
              Pattern: new RegExp("^sg_\\w+$")
            },
            type: {
              name: "String"
            }
          }
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "Tx"
        }
      }
    }
  }
};
const Paths181Cs9V3NamesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths181Cs9V3NamesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Name"
            }
          }
        }
      }
    }
  }
};
const mappers_Name = {
  type: {
    name: "Composite",
    className: "Name",
    modelProperties: {
      active: {
        serializedName: "active",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      hash: {
        constraints: {
          Pattern: new RegExp("^nm_\\w{38,50}$")
        },
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      activeFrom: {
        serializedName: "active_from",
        required: true,
        type: {
          name: "Number"
        }
      },
      approximateActivationTime: {
        serializedName: "approximate_activation_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      approximateExpireTime: {
        serializedName: "approximate_expire_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      expireHeight: {
        serializedName: "expire_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      pointers: {
        serializedName: "pointers",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NamePointer"
            }
          }
        }
      },
      auction: {
        serializedName: "auction",
        type: {
          name: "Composite",
          className: "Auction"
        }
      },
      auctionTimeout: {
        serializedName: "auction_timeout",
        required: true,
        type: {
          name: "Number"
        }
      },
      ownership: {
        serializedName: "ownership",
        type: {
          name: "Composite",
          className: "NameOwnership"
        }
      },
      name: {
        constraints: {
          Pattern: new RegExp("^\\w+\\.chain$")
        },
        serializedName: "name",
        required: true,
        type: {
          name: "String"
        }
      },
      nameFee: {
        serializedName: "name_fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      revoke: {
        serializedName: "revoke",
        type: {
          name: "Composite",
          className: "NameTx"
        }
      },
      claimsCount: {
        serializedName: "claims_count",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Auction = {
  type: {
    name: "Composite",
    className: "Auction",
    modelProperties: {
      auctionEnd: {
        serializedName: "auction_end",
        required: true,
        type: {
          name: "Number"
        }
      },
      activationTime: {
        serializedName: "activation_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      approximateExpireTime: {
        serializedName: "approximate_expire_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      lastBid: {
        serializedName: "last_bid",
        type: {
          name: "Composite",
          className: "AuctionLastBid"
        }
      },
      name: {
        constraints: {
          Pattern: new RegExp("^\\w+\\.chain$")
        },
        serializedName: "name",
        required: true,
        type: {
          name: "String"
        }
      },
      nameFee: {
        serializedName: "name_fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      claimsCount: {
        serializedName: "claims_count",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const AuctionLastBid = {
  type: {
    name: "Composite",
    className: "AuctionLastBid",
    modelProperties: {
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      encodedTx: {
        constraints: {
          Pattern: new RegExp("^tx_\\w+$")
        },
        serializedName: "encoded_tx",
        required: true,
        type: {
          name: "String"
        }
      },
      hash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        required: true,
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      signatures: {
        serializedName: "signatures",
        required: true,
        type: {
          name: "Sequence",
          element: {
            constraints: {
              Pattern: new RegExp("^sg_\\w+$")
            },
            type: {
              name: "String"
            }
          }
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "AuctionLastBidTx"
        }
      }
    }
  }
};
const Components17W16A5SchemasAuctionPropertiesLastBidPropertiesTxAllof1 = {
  type: {
    name: "Composite",
    className: "Components17W16A5SchemasAuctionPropertiesLastBidPropertiesTxAllof1",
    modelProperties: {
      nameId: {
        constraints: {
          Pattern: new RegExp("^nm_\\w{38,50}$")
        },
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      },
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const NameOwnership = {
  type: {
    name: "Composite",
    className: "NameOwnership",
    modelProperties: {
      current: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "current",
        type: {
          name: "String"
        }
      },
      original: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "original",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameTx = {
  type: {
    name: "Composite",
    className: "NameTx",
    modelProperties: {
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      hash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        required: true,
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      signatures: {
        serializedName: "signatures",
        required: true,
        type: {
          name: "Sequence",
          element: {
            constraints: {
              Pattern: new RegExp("^sg_\\w+$")
            },
            type: {
              name: "String"
            }
          }
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "NameTxTx"
        }
      }
    }
  }
};
const mappers_NameRevokeTx = {
  type: {
    name: "Composite",
    className: "NameRevokeTx",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Components171VsjiSchemasNametxPropertiesTxAllof1 = {
  type: {
    name: "Composite",
    className: "Components171VsjiSchemasNametxPropertiesTxAllof1",
    modelProperties: {
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1R08F8HV3NamesAuctionsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1R08F8HV3NamesAuctionsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Auction"
            }
          }
        }
      }
    }
  }
};
const PathsCrb9BgV3NamesAuctionsIdClaimsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsCrb9BgV3NamesAuctionsIdClaimsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NameClaim"
            }
          }
        }
      }
    }
  }
};
const PathsMyl4W2V3NamesIdClaimsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsMyl4W2V3NamesIdClaimsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NameClaim"
            }
          }
        }
      }
    }
  }
};
const Paths1Ukwk06V3NamesIdTransfersGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1Ukwk06V3NamesIdTransfersGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NameTransfer"
            }
          }
        }
      }
    }
  }
};
const NameTransfer = {
  type: {
    name: "Composite",
    className: "NameTransfer",
    modelProperties: {
      activeFrom: {
        serializedName: "active_from",
        required: true,
        type: {
          name: "Number"
        }
      },
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      sourceTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "source_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      sourceTxType: {
        serializedName: "source_tx_type",
        required: true,
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "NameTransferTx"
        }
      },
      internalSource: {
        serializedName: "internal_source",
        type: {
          name: "Boolean"
        }
      }
    }
  }
};
const mappers_NameTransferTx = {
  type: {
    name: "Composite",
    className: "NameTransferTx",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      },
      recipientId: {
        serializedName: "recipient_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsRcnvllV3NamesIdUpdatesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsRcnvllV3NamesIdUpdatesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NameUpdate"
            }
          }
        }
      }
    }
  }
};
const NameUpdate = {
  type: {
    name: "Composite",
    className: "NameUpdate",
    modelProperties: {
      activeFrom: {
        serializedName: "active_from",
        required: true,
        type: {
          name: "Number"
        }
      },
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      sourceTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "source_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      sourceTxType: {
        serializedName: "source_tx_type",
        required: true,
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "NameUpdateTx"
        }
      },
      internalSource: {
        serializedName: "internal_source",
        type: {
          name: "Boolean"
        }
      }
    }
  }
};
const PathsGcr9MrV3OraclesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsGcr9MrV3OraclesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Oracle"
            }
          }
        }
      }
    }
  }
};
const mappers_Oracle = {
  type: {
    name: "Composite",
    className: "Oracle",
    modelProperties: {
      active: {
        serializedName: "active",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      activeFrom: {
        serializedName: "active_from",
        required: true,
        type: {
          name: "Number"
        }
      },
      approximateExpireTime: {
        serializedName: "approximate_expire_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      expireHeight: {
        serializedName: "expire_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      registerTime: {
        serializedName: "register_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      registerTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "register_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      format: {
        serializedName: "format",
        type: {
          name: "Composite",
          className: "OracleFormat"
        }
      },
      oracle: {
        constraints: {
          Pattern: new RegExp("^ok_\\w{38,50}$")
        },
        serializedName: "oracle",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        serializedName: "query_fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      register: {
        serializedName: "register",
        type: {
          name: "Composite",
          className: "OracleTx"
        }
      }
    }
  }
};
const OracleFormat = {
  type: {
    name: "Composite",
    className: "OracleFormat",
    modelProperties: {
      query: {
        serializedName: "query",
        required: true,
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OracleTx = {
  type: {
    name: "Composite",
    className: "OracleTx",
    modelProperties: {
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      hash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        required: true,
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      signatures: {
        serializedName: "signatures",
        required: true,
        type: {
          name: "Sequence",
          element: {
            constraints: {
              Pattern: new RegExp("^sg_\\w+$")
            },
            type: {
              name: "String"
            }
          }
        }
      },
      encodedTx: {
        constraints: {
          Pattern: new RegExp("^tx_\\w+$")
        },
        serializedName: "encoded_tx",
        required: true,
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "OracleTxTx"
        }
      }
    }
  }
};
const mappers_OracleRegisterTx = {
  type: {
    name: "Composite",
    className: "OracleRegisterTx",
    modelProperties: {
      queryFormat: {
        serializedName: "query_format",
        required: true,
        type: {
          name: "String"
        }
      },
      responseFormat: {
        serializedName: "response_format",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "query_fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      oracleTtl: {
        serializedName: "oracle_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Components1Viuqa3SchemasOracletxPropertiesTxAllof1 = {
  type: {
    name: "Composite",
    className: "Components1Viuqa3SchemasOracletxPropertiesTxAllof1",
    modelProperties: {
      oracleId: {
        constraints: {
          Pattern: new RegExp("^ok_\\w{38,50}$")
        },
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "Number"
        }
      },
      txHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PathsZ4L2QlV3OraclesIdExtendsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsZ4L2QlV3OraclesIdExtendsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "OracleExtend"
            }
          }
        }
      }
    }
  }
};
const OracleExtend = {
  type: {
    name: "Composite",
    className: "OracleExtend",
    modelProperties: {
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      sourceTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "source_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      sourceTxType: {
        serializedName: "source_tx_type",
        required: true,
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "OracleExtendTx"
        }
      }
    }
  }
};
const mappers_OracleExtendTx = {
  type: {
    name: "Composite",
    className: "OracleExtendTx",
    modelProperties: {
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      oracleTtl: {
        serializedName: "oracle_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1Uni7AtV3OraclesIdQueriesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1Uni7AtV3OraclesIdQueriesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "OracleQuery"
            }
          }
        }
      }
    }
  }
};
const mappers_OracleQuery = {
  type: {
    name: "Composite",
    className: "OracleQuery",
    modelProperties: {
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      blockTime: {
        serializedName: "block_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      queryId: {
        constraints: {
          Pattern: new RegExp("^oq_\\w{38,50}$")
        },
        serializedName: "query_id",
        required: true,
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        type: {
          name: "Composite",
          className: "OracleResponse"
        }
      },
      sourceTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "source_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      sourceTxType: {
        serializedName: "source_tx_type",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        serializedName: "nonce",
        required: true,
        type: {
          name: "Number"
        }
      },
      oracleId: {
        constraints: {
          Pattern: new RegExp("^ok_\\w{38,50}$")
        },
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        serializedName: "query_fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      queryTtl: {
        serializedName: "query_ttl",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      senderId: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "sender_id",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const OracleResponse = {
  type: {
    name: "Composite",
    className: "OracleResponse",
    modelProperties: {
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      blockTime: {
        serializedName: "block_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      queryId: {
        constraints: {
          Pattern: new RegExp("^oq_\\w{38,50}$")
        },
        serializedName: "query_id",
        required: true,
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        type: {
          name: "Composite",
          className: "OracleQuery"
        }
      },
      sourceTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "source_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      sourceTxType: {
        serializedName: "source_tx_type",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        serializedName: "nonce",
        required: true,
        type: {
          name: "Number"
        }
      },
      oracleId: {
        constraints: {
          Pattern: new RegExp("^ok_\\w{38,50}$")
        },
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        required: true,
        type: {
          name: "String"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      ttl: {
        serializedName: "ttl",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1Tcj5A9V3OraclesIdResponsesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1Tcj5A9V3OraclesIdResponsesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "OracleResponse"
            }
          }
        }
      }
    }
  }
};
const Stats = {
  type: {
    name: "Composite",
    className: "Stats",
    modelProperties: {
      minersCount: {
        serializedName: "miners_count",
        type: {
          name: "Number"
        }
      },
      feesTrend: {
        serializedName: "fees_trend",
        type: {
          name: "Number"
        }
      },
      last24HsAverageTransactionFees: {
        serializedName: "last_24hs_average_transaction_fees",
        type: {
          name: "Number"
        }
      },
      last24HsTransactions: {
        serializedName: "last_24hs_transactions",
        type: {
          name: "Number"
        }
      },
      maxTransactionsPerSecond: {
        serializedName: "max_transactions_per_second",
        type: {
          name: "Number"
        }
      },
      maxTransactionsPerSecondBlockHash: {
        constraints: {
          Pattern: new RegExp("^kh_\\w{38,50}$")
        },
        serializedName: "max_transactions_per_second_block_hash",
        type: {
          name: "String"
        }
      },
      transactionsTrend: {
        serializedName: "transactions_trend",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsFso5IiV3StatsActiveAccountsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsFso5IiV3StatsActiveAccountsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Stat"
            }
          }
        }
      }
    }
  }
};
const Stat = {
  type: {
    name: "Composite",
    className: "Stat",
    modelProperties: {
      count: {
        serializedName: "count",
        required: true,
        type: {
          name: "Number"
        }
      },
      startDate: {
        serializedName: "start_date",
        required: true,
        type: {
          name: "String"
        }
      },
      endDate: {
        serializedName: "end_date",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths1Fl1Lh2V3StatsAex9TransfersGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1Fl1Lh2V3StatsAex9TransfersGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Stat"
            }
          }
        }
      }
    }
  }
};
const Paths1A27TirV3StatsBlocksGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1A27TirV3StatsBlocksGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Stat"
            }
          }
        }
      }
    }
  }
};
const Paths72Dp44V3StatsContractsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths72Dp44V3StatsContractsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Stat"
            }
          }
        }
      }
    }
  }
};
const Paths1J83O75V3StatsDeltaGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1J83O75V3StatsDeltaGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DeltaStat"
            }
          }
        }
      }
    }
  }
};
const DeltaStat = {
  type: {
    name: "Composite",
    className: "DeltaStat",
    modelProperties: {
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      auctionsStarted: {
        serializedName: "auctions_started",
        required: true,
        type: {
          name: "Number"
        }
      },
      blockReward: {
        serializedName: "block_reward",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      burnedInAuctions: {
        serializedName: "burned_in_auctions",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      channelsClosed: {
        serializedName: "channels_closed",
        required: true,
        type: {
          name: "Number"
        }
      },
      channelsOpened: {
        serializedName: "channels_opened",
        required: true,
        type: {
          name: "Number"
        }
      },
      contractsCreated: {
        serializedName: "contracts_created",
        required: true,
        type: {
          name: "Number"
        }
      },
      devReward: {
        serializedName: "dev_reward",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      namesActivated: {
        serializedName: "names_activated",
        required: true,
        type: {
          name: "Number"
        }
      },
      namesExpired: {
        serializedName: "names_expired",
        required: true,
        type: {
          name: "Number"
        }
      },
      namesRevoked: {
        serializedName: "names_revoked",
        required: true,
        type: {
          name: "Number"
        }
      },
      oraclesExpired: {
        serializedName: "oracles_expired",
        required: true,
        type: {
          name: "Number"
        }
      },
      oraclesRegistered: {
        serializedName: "oracles_registered",
        required: true,
        type: {
          name: "Number"
        }
      },
      lastTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "last_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      lockedInAuctions: {
        serializedName: "locked_in_auctions",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      lockedInChannels: {
        serializedName: "locked_in_channels",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      }
    }
  }
};
const Paths1Qw6KhfV3StatsDifficultyGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1Qw6KhfV3StatsDifficultyGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Stat"
            }
          }
        }
      }
    }
  }
};
const Paths1IskjkV3StatsHashrateGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1IskjkV3StatsHashrateGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Stat"
            }
          }
        }
      }
    }
  }
};
const Paths50Qhc7V3StatsMinersGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths50Qhc7V3StatsMinersGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Miner"
            }
          }
        }
      }
    }
  }
};
const Miner = {
  type: {
    name: "Composite",
    className: "Miner",
    modelProperties: {
      miner: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "miner",
        required: true,
        type: {
          name: "String"
        }
      },
      totalReward: {
        serializedName: "total_reward",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      }
    }
  }
};
const PathsD92Xl6V3StatsNamesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsD92Xl6V3StatsNamesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Stat"
            }
          }
        }
      }
    }
  }
};
const Paths1K55ZdgV3StatsTotalGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1K55ZdgV3StatsTotalGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TotalStat"
            }
          }
        }
      }
    }
  }
};
const TotalStat = {
  type: {
    name: "Composite",
    className: "TotalStat",
    modelProperties: {
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      contracts: {
        serializedName: "contracts",
        required: true,
        type: {
          name: "Number"
        }
      },
      lockedInAuctions: {
        serializedName: "locked_in_auctions",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      burnedInAuctions: {
        serializedName: "burned_in_auctions",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      lockedInChannels: {
        serializedName: "locked_in_channels",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      activeAuctions: {
        serializedName: "active_auctions",
        required: true,
        type: {
          name: "Number"
        }
      },
      activeNames: {
        serializedName: "active_names",
        required: true,
        type: {
          name: "Number"
        }
      },
      inactiveNames: {
        serializedName: "inactive_names",
        required: true,
        type: {
          name: "Number"
        }
      },
      activeOracles: {
        serializedName: "active_oracles",
        required: true,
        type: {
          name: "Number"
        }
      },
      inactiveOracles: {
        serializedName: "inactive_oracles",
        required: true,
        type: {
          name: "Number"
        }
      },
      openChannels: {
        serializedName: "open_channels",
        required: true,
        type: {
          name: "Number"
        }
      },
      sumBlockReward: {
        serializedName: "sum_block_reward",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      sumDevReward: {
        serializedName: "sum_dev_reward",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      totalTokenSupply: {
        serializedName: "total_token_supply",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      lastTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "last_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths3Bfys0V3StatsTotalAccountsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths3Bfys0V3StatsTotalAccountsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Stat"
            }
          }
        }
      }
    }
  }
};
const Paths6PaqluV3StatsTransactionsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths6PaqluV3StatsTransactionsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Stat"
            }
          }
        }
      }
    }
  }
};
const mappers_Status = {
  type: {
    name: "Composite",
    className: "Status",
    modelProperties: {
      mdwAsyncTasks: {
        serializedName: "mdw_async_tasks",
        type: {
          name: "Composite",
          className: "StatusMdwAsyncTasks"
        }
      },
      mdwGensPerMinute: {
        serializedName: "mdw_gens_per_minute",
        required: true,
        type: {
          name: "Number"
        }
      },
      mdwHeight: {
        serializedName: "mdw_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      mdwLastMigration: {
        serializedName: "mdw_last_migration",
        required: true,
        type: {
          name: "Number"
        }
      },
      mdwRevision: {
        serializedName: "mdw_revision",
        required: true,
        type: {
          name: "String"
        }
      },
      mdwSynced: {
        serializedName: "mdw_synced",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      mdwSyncing: {
        serializedName: "mdw_syncing",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      mdwTxIndex: {
        serializedName: "mdw_tx_index",
        required: true,
        type: {
          name: "Number"
        }
      },
      mdwVersion: {
        serializedName: "mdw_version",
        required: true,
        type: {
          name: "String"
        }
      },
      nodeHeight: {
        serializedName: "node_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      nodeProgress: {
        serializedName: "node_progress",
        required: true,
        type: {
          name: "Number"
        }
      },
      nodeRevision: {
        serializedName: "node_revision",
        required: true,
        type: {
          name: "String"
        }
      },
      nodeSyncing: {
        serializedName: "node_syncing",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      nodeVersion: {
        serializedName: "node_version",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const StatusMdwAsyncTasks = {
  type: {
    name: "Composite",
    className: "StatusMdwAsyncTasks",
    modelProperties: {
      longTasks: {
        serializedName: "long_tasks",
        required: true,
        type: {
          name: "Number"
        }
      },
      producerBuffer: {
        serializedName: "producer_buffer",
        required: true,
        type: {
          name: "Number"
        }
      },
      totalPending: {
        serializedName: "total_pending",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsHa9C78V3TransactionsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsHa9C78V3TransactionsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Transaction"
            }
          }
        }
      }
    }
  }
};
const PathsI72FylV3TransactionsPendingGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsI72FylV3TransactionsPendingGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "PendingTransaction"
            }
          }
        }
      }
    }
  }
};
const PendingTransaction = {
  type: {
    name: "Composite",
    className: "PendingTransaction",
    modelProperties: {
      blockHash: {
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      encodedTx: {
        constraints: {
          Pattern: new RegExp("^tx_\\w+$")
        },
        serializedName: "encoded_tx",
        required: true,
        type: {
          name: "String"
        }
      },
      failures: {
        serializedName: "failures",
        required: true,
        type: {
          name: "Number"
        }
      },
      hash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      signatures: {
        serializedName: "signatures",
        required: true,
        type: {
          name: "Sequence",
          element: {
            constraints: {
              Pattern: new RegExp("^sg_\\w+$")
            },
            type: {
              name: "String"
            }
          }
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "Tx"
        }
      }
    }
  }
};
const PathsVdg67V3TransfersGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsVdg67V3TransfersGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Transfer"
            }
          }
        }
      }
    }
  }
};
const Transfer = {
  type: {
    name: "Composite",
    className: "Transfer",
    modelProperties: {
      accountId: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      kind: {
        serializedName: "kind",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["reward_dev", "reward_block"]
        }
      },
      refBlockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "ref_block_hash",
        required: true,
        nullable: true,
        type: {
          name: "String"
        }
      },
      refTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "ref_tx_hash",
        required: true,
        nullable: true,
        type: {
          name: "String"
        }
      },
      refTxType: {
        serializedName: "ref_tx_type",
        required: true,
        nullable: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Aex9TransferEvent = {
  type: {
    name: "Composite",
    className: "Aex9TransferEvent",
    modelProperties: {
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      contractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      logIdx: {
        serializedName: "log_idx",
        required: true,
        type: {
          name: "Number"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        required: true,
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      recipientId: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "recipient_id",
        required: true,
        type: {
          name: "String"
        }
      },
      senderId: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "sender_id",
        required: true,
        type: {
          name: "String"
        }
      },
      txHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Aex9TransferResponse = {
  type: {
    name: "Composite",
    className: "Aex9TransferResponse",
    modelProperties: {
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      callTxi: {
        serializedName: "call_txi",
        required: true,
        type: {
          name: "Number"
        }
      },
      contractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      logIdx: {
        serializedName: "log_idx",
        required: true,
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        required: true,
        type: {
          name: "UnixTime"
        }
      },
      recipient: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "recipient",
        required: true,
        type: {
          name: "String"
        }
      },
      sender: {
        constraints: {
          Pattern: new RegExp("^ak_\\w{38,50}$")
        },
        serializedName: "sender",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const InternalContractCallEvent = {
  type: {
    name: "Composite",
    className: "InternalContractCallEvent",
    modelProperties: {
      contractTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "contract_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      contractId: {
        constraints: {
          Pattern: new RegExp("^ct_\\w{38,50}$")
        },
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      callTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "call_tx_hash",
        type: {
          name: "String"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      internalTx: {
        serializedName: "internal_tx",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        required: true,
        type: {
          name: "Number"
        }
      },
      blockHash: {
        constraints: {
          Pattern: new RegExp("^mh_\\w{38,50}$")
        },
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const InternalTransferEvent = {
  type: {
    name: "Composite",
    className: "InternalTransferEvent",
    modelProperties: {
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      kind: {
        serializedName: "kind",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["accounts_extra_lima", "accounts_fortuna", "accounts_genesis", "accounts_lima", "accounts_minerva", "contracts_lima", "reward_dev", "reward_block", "fee_refund_oracle", "fee_lock_name", "fee_refund_name", "fee_spend_name", "reward_oracle"]
        }
      },
      refTxHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "ref_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameClaimEvent = {
  type: {
    name: "Composite",
    className: "NameClaimEvent",
    modelProperties: {
      txHash: {
        constraints: {
          Pattern: new RegExp("^th_\\w{38,50}$")
        },
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
const mappers_SpendTx = {
  type: {
    name: "Composite",
    className: "SpendTx",
    modelProperties: {
      recipientId: {
        serializedName: "recipient_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      senderId: {
        serializedName: "sender_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const mappers_ChannelCreateTx = {
  type: {
    name: "Composite",
    className: "ChannelCreateTx",
    modelProperties: {
      initiatorId: {
        serializedName: "initiator_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "initiator_amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      responderId: {
        serializedName: "responder_id",
        required: true,
        type: {
          name: "String"
        }
      },
      responderAmount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "responder_amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      channelReserve: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "channel_reserve",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      lockPeriod: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "lock_period",
        required: true,
        type: {
          name: "Number"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      delegateIds: {
        serializedName: "delegate_ids",
        type: {
          name: "Composite",
          className: "Delegates"
        }
      }
    }
  }
};
const mappers_ChannelDepositTx = {
  type: {
    name: "Composite",
    className: "ChannelDepositTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        required: true,
        type: {
          name: "Number"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "round",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const mappers_ChannelWithdrawTx = {
  type: {
    name: "Composite",
    className: "ChannelWithdrawTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      toId: {
        serializedName: "to_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        required: true,
        type: {
          name: "Number"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "round",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const mappers_ChannelForceProgressTx = {
  type: {
    name: "Composite",
    className: "ChannelForceProgressTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "round",
        required: true,
        type: {
          name: "Number"
        }
      },
      update: {
        serializedName: "update",
        type: {
          name: "Composite",
          className: "OffChainUpdate"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      offchainTrees: {
        serializedName: "offchain_trees",
        type: {
          name: "String"
        }
      }
    }
  }
};
const mappers_ChannelCloseMutualTx = {
  type: {
    name: "Composite",
    className: "ChannelCloseMutualTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmountFinal: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "initiator_amount_final",
        required: true,
        type: {
          name: "Number"
        }
      },
      responderAmountFinal: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "responder_amount_final",
        required: true,
        type: {
          name: "Number"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const mappers_ChannelCloseSoloTx = {
  type: {
    name: "Composite",
    className: "ChannelCloseSoloTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      poi: {
        serializedName: "poi",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const mappers_ChannelSlashTx = {
  type: {
    name: "Composite",
    className: "ChannelSlashTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      poi: {
        serializedName: "poi",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const mappers_ChannelSettleTx = {
  type: {
    name: "Composite",
    className: "ChannelSettleTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmountFinal: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "initiator_amount_final",
        required: true,
        type: {
          name: "Number"
        }
      },
      responderAmountFinal: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "responder_amount_final",
        required: true,
        type: {
          name: "Number"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const mappers_ChannelSnapshotSoloTx = {
  type: {
    name: "Composite",
    className: "ChannelSnapshotSoloTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const mappers_ChannelSetDelegatesTx = {
  type: {
    name: "Composite",
    className: "ChannelSetDelegatesTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorDelegateIds: {
        serializedName: "initiator_delegate_ids",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      responderDelegateIds: {
        serializedName: "responder_delegate_ids",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "round",
        required: true,
        type: {
          name: "Number"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const mappers_OracleQueryTx = {
  type: {
    name: "Composite",
    className: "OracleQueryTx",
    modelProperties: {
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "query_fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      queryTtl: {
        serializedName: "query_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      senderId: {
        serializedName: "sender_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const mappers_OracleRespondTx = {
  type: {
    name: "Composite",
    className: "OracleRespondTx",
    modelProperties: {
      queryId: {
        serializedName: "query_id",
        required: true,
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        required: true,
        type: {
          name: "String"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const mappers_NamePreclaimTx = {
  type: {
    name: "Composite",
    className: "NamePreclaimTx",
    modelProperties: {
      commitmentId: {
        serializedName: "commitment_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const mappers_ContractCallTx = {
  type: {
    name: "Composite",
    className: "ContractCallTx",
    modelProperties: {
      callerId: {
        serializedName: "caller_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      amount: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "amount",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      gas: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "gas",
        required: true,
        type: {
          name: "Number"
        }
      },
      gasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas_price",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const mappers_GAAttachTx = {
  type: {
    name: "Composite",
    className: "GAAttachTx",
    modelProperties: {
      ownerId: {
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "vm_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      gas: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "gas",
        required: true,
        type: {
          name: "Number"
        }
      },
      gasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas_price",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      },
      authFun: {
        constraints: {
          Pattern: new RegExp("^(0x|0X)?[a-fA-F0-9]+$")
        },
        serializedName: "auth_fun",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const mappers_GAMetaTx = {
  type: {
    name: "Composite",
    className: "GAMetaTx",
    modelProperties: {
      gaId: {
        serializedName: "ga_id",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        constraints: {
          InclusiveMaximum: 65535,
          InclusiveMinimum: 0
        },
        serializedName: "abi_version",
        required: true,
        type: {
          name: "Number"
        }
      },
      gas: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "gas",
        required: true,
        type: {
          name: "Number"
        }
      },
      gasPrice: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "gas_price",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      ttl: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "ttl",
        type: {
          name: "Number"
        }
      },
      authData: {
        serializedName: "auth_data",
        required: true,
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "SignedTx"
        }
      }
    }
  }
};
const mappers_PayingForTx = {
  type: {
    name: "Composite",
    className: "PayingForTx",
    modelProperties: {
      payerId: {
        serializedName: "payer_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        constraints: {
          InclusiveMinimum: 0
        },
        serializedName: "fee",
        required: true,
        type: {
          // @ts-expect-error we are extending autorest with BigInt support
          name: "BigInt"
        }
      },
      nonce: {
        constraints: {
          InclusiveMaximum: 18446744073709552000,
          InclusiveMinimum: 0
        },
        serializedName: "nonce",
        type: {
          name: "Number"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "SignedTx"
        }
      }
    }
  }
};
const Paths1EfdbjrV3AccountsAccountidActivitiesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1EfdbjrV3AccountsAccountidActivitiesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsBx0Ya3V3AccountsAccountidActivitiesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths3Hsv3GV3AccountsAccountidAex141TokensGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths3Hsv3GV3AccountsAccountidAex141TokensGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1Q9E32FV3AccountsAccountidAex141TokensGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsKm52GqV3AccountsAccountidAex9BalancesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsKm52GqV3AccountsAccountidAex9BalancesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PaginatedResponse.type.modelProperties,
      ...PathsZ92TkfV3AccountsAccountidAex9BalancesGetResponses200ContentApplicationJsonSchemaAllof1.type.modelProperties
    }
  }
};
const PathsZpy8S9V3AccountsAccountidDexSwapsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsZpy8S9V3AccountsAccountidDexSwapsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths10R8Q7PV3AccountsAccountidDexSwapsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths16Cyh9EV3AccountsAccountidNamesClaimsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths16Cyh9EV3AccountsAccountidNamesClaimsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths16G4GzrV3AccountsAccountidNamesClaimsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Mheci5V3AccountsAccountidNamesPointeesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Mheci5V3AccountsAccountidNamesPointeesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsA60QxwV3AccountsAccountidNamesPointeesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1XwlyjtV3Aex141GetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1XwlyjtV3Aex141GetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths8I0YgwV3Aex141GetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths181AjwxV3Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths181AjwxV3Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsWkpcwaV3Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths15Mi2TaV3Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths15Mi2TaV3Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsRay4X0V3Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsWl652MV3Aex141ContractidTokensGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsWl652MV3Aex141ContractidTokensGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1TkisghV3Aex141ContractidTokensGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1O7Q6IhV3Aex141ContractidTransfersGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1O7Q6IhV3Aex141ContractidTransfersGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1A8Ah39V3Aex141ContractidTransfersGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Vr3Y2EV3Aex9GetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Vr3Y2EV3Aex9GetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1Uqqby0V3Aex9GetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1N61UurV3Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1N61UurV3Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsEeiffwV3Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Uybd4PV3Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Uybd4PV3Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PaginatedResponse.type.modelProperties,
      ...Paths108B3VtV3Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchemaAllof1.type.modelProperties
    }
  }
};
const Paths3EzhapV3ChannelsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths3EzhapV3ChannelsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsQmewnaV3ChannelsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Txblx8V3ContractsCallsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Txblx8V3ContractsCallsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths18L84JcV3ContractsCallsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths7A1M6RV3ContractsLogsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths7A1M6RV3ContractsLogsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths10Kk1UxV3ContractsLogsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Di8FnjV3DexSwapsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Di8FnjV3DexSwapsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths9Yfxl2V3DexSwapsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsKwxlzlV3DexContractIdSwapsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsKwxlzlV3DexContractIdSwapsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths6Vze8ZV3DexContractIdSwapsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths194Lg3IV3HyperchainEpochsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths194Lg3IV3HyperchainEpochsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1F8GzwrV3HyperchainEpochsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1S5Zlt1V3HyperchainScheduleGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1S5Zlt1V3HyperchainScheduleGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths7W5O80V3HyperchainScheduleGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Ibn686V3HyperchainValidatorsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Ibn686V3HyperchainValidatorsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1Qg7SclV3HyperchainValidatorsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1I4U8D5V3HyperchainValidatorsValidatorDelegatesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1I4U8D5V3HyperchainValidatorsValidatorDelegatesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths7Ks32NV3HyperchainValidatorsValidatorDelegatesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths15K0AlgV3HyperchainValidatorsValidatorDelegatesTopGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths15K0AlgV3HyperchainValidatorsValidatorDelegatesTopGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsDwhnfdV3HyperchainValidatorsValidatorDelegatesTopGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths277OngV3KeyBlocksGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths277OngV3KeyBlocksGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsEue6HzV3KeyBlocksGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1159W94V3KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1159W94V3KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsNn60D7V3KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths15Bkk50V3MicroBlocksHashTransactionsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths15Bkk50V3MicroBlocksHashTransactionsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsXhlqwrV3MicroBlocksHashTransactionsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths12S1Nd4V3NamesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths12S1Nd4V3NamesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths181Cs9V3NamesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsKjq4D4V3NamesAuctionsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsKjq4D4V3NamesAuctionsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1R08F8HV3NamesAuctionsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1F98AqgV3NamesIdClaimsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1F98AqgV3NamesIdClaimsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsMyl4W2V3NamesIdClaimsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Raw8PV3NamesIdTransfersGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Raw8PV3NamesIdTransfersGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1Ukwk06V3NamesIdTransfersGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Ec8CltV3NamesIdUpdatesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Ec8CltV3NamesIdUpdatesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsRcnvllV3NamesIdUpdatesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1E14NekV3OraclesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1E14NekV3OraclesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsGcr9MrV3OraclesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1L5C64RV3OraclesIdExtendsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1L5C64RV3OraclesIdExtendsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsZ4L2QlV3OraclesIdExtendsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths8722JhV3OraclesIdQueriesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths8722JhV3OraclesIdQueriesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1Uni7AtV3OraclesIdQueriesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsVron83V3OraclesIdResponsesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsVron83V3OraclesIdResponsesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1Tcj5A9V3OraclesIdResponsesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsCgzmimV3StatsActiveAccountsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsCgzmimV3StatsActiveAccountsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsFso5IiV3StatsActiveAccountsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1UxyhelV3StatsAex9TransfersGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1UxyhelV3StatsAex9TransfersGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1Fl1Lh2V3StatsAex9TransfersGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Sxjoy0V3StatsBlocksGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Sxjoy0V3StatsBlocksGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1A27TirV3StatsBlocksGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsWbrhqnV3StatsContractsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsWbrhqnV3StatsContractsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths72Dp44V3StatsContractsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths5Xf9ScV3StatsDeltaGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths5Xf9ScV3StatsDeltaGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1J83O75V3StatsDeltaGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1D7Up0DV3StatsDifficultyGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1D7Up0DV3StatsDifficultyGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1Qw6KhfV3StatsDifficultyGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsR51VshV3StatsHashrateGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsR51VshV3StatsHashrateGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1IskjkV3StatsHashrateGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsA8Q6T7V3StatsMinersGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsA8Q6T7V3StatsMinersGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths50Qhc7V3StatsMinersGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsCeyhpaV3StatsNamesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsCeyhpaV3StatsNamesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsD92Xl6V3StatsNamesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsJoz7P5V3StatsTotalGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsJoz7P5V3StatsTotalGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1K55ZdgV3StatsTotalGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths15F3FfuV3StatsTotalAccountsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths15F3FfuV3StatsTotalAccountsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths3Bfys0V3StatsTotalAccountsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1IfhshmV3StatsTransactionsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1IfhshmV3StatsTransactionsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths6PaqluV3StatsTransactionsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Pymq07V3TransactionsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Pymq07V3TransactionsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsHa9C78V3TransactionsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsUq0T7JV3TransactionsPendingGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsUq0T7JV3TransactionsPendingGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsI72FylV3TransactionsPendingGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsA7P0KiV3TransfersGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsA7P0KiV3TransfersGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsVdg67V3TransfersGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const AuctionLastBidTx = {
  type: {
    name: "Composite",
    className: "AuctionLastBidTx",
    modelProperties: {
      ...mappers_NameClaimTx.type.modelProperties,
      ...Components17W16A5SchemasAuctionPropertiesLastBidPropertiesTxAllof1.type.modelProperties
    }
  }
};
const KeyBlockExtended = {
  type: {
    name: "Composite",
    className: "KeyBlockExtended",
    modelProperties: {
      ...mappers_KeyBlock.type.modelProperties,
      beneficiaryReward: {
        serializedName: "beneficiary_reward",
        required: true,
        type: {
          name: "Number"
        }
      },
      flags: {
        constraints: {
          Pattern: new RegExp("^ba_\\w+$")
        },
        serializedName: "flags",
        required: true,
        type: {
          name: "String"
        }
      },
      microBlocksCount: {
        serializedName: "micro_blocks_count",
        required: true,
        type: {
          name: "Number"
        }
      },
      transactionsCount: {
        serializedName: "transactions_count",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const MicroBlockExtended = {
  type: {
    name: "Composite",
    className: "MicroBlockExtended",
    modelProperties: {
      ...mappers_MicroBlockHeader.type.modelProperties,
      microBlockIndex: {
        serializedName: "micro_block_index",
        required: true,
        type: {
          name: "Number"
        }
      },
      transactionsCount: {
        serializedName: "transactions_count",
        required: true,
        type: {
          name: "Number"
        }
      },
      gas: {
        serializedName: "gas",
        required: true,
        type: {
          name: "Number"
        }
      },
      flags: {
        constraints: {
          Pattern: new RegExp("^ba_\\w+$")
        },
        serializedName: "flags",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameTxTx = {
  type: {
    name: "Composite",
    className: "NameTxTx",
    modelProperties: {
      ...mappers_NameRevokeTx.type.modelProperties,
      ...Components171VsjiSchemasNametxPropertiesTxAllof1.type.modelProperties
    }
  }
};
const OracleTxTx = {
  type: {
    name: "Composite",
    className: "OracleTxTx",
    modelProperties: {
      ...mappers_OracleRegisterTx.type.modelProperties,
      ...Components1Viuqa3SchemasOracletxPropertiesTxAllof1.type.modelProperties
    }
  }
};
let mappers_discriminators = {
  "OffChainUpdate.OffChainUpdate": mappers_OffChainUpdate
};
;// ./src/apis/middleware/middleware.ts




class middleware_Middleware extends core_client_.ServiceClient {
  /**
   * Initializes a new instance of the Middleware class.
   * @param $host server parameter
   * @param options The parameter options
   */
  constructor($host, options) {
    var _ref, _options$endpoint;
    if ($host === undefined) {
      throw new Error("'$host' cannot be null");
    }

    // Initializing default values for options
    if (!options) {
      options = {};
    }
    const defaults = {
      requestContentType: "application/json; charset=utf-8"
    };
    const packageDetails = `azsdk-js-middleware/1.0.0-beta.1`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
    const optionsWithDefaults = {
      ...defaults,
      ...options,
      userAgentOptions: {
        userAgentPrefix
      },
      endpoint: (_ref = (_options$endpoint = options.endpoint) !== null && _options$endpoint !== void 0 ? _options$endpoint : options.baseUri) !== null && _ref !== void 0 ? _ref : "{$host}"
    };
    super(optionsWithDefaults);
    // Parameter assignments
    this.$host = $host;
  }

  /**
   * Get an account activities.
   * @param accountId The account address Account address
   * @param options The options parameters.
   */
  getAccountActivities(accountId, options) {
    return this.sendOperationRequest({
      accountId,
      options
    }, getAccountActivitiesOperationSpec);
  }

  /**
   * Get tokens owned by an account.
   * @param accountId The account id Account address
   * @param options The options parameters.
   */
  getAex141OwnedTokens(accountId, options) {
    return this.sendOperationRequest({
      accountId,
      options
    }, getAex141OwnedTokensOperationSpec);
  }

  /**
   * Get all AEX9 balances for an account on the last block.
   * @param accountId Account id Account address
   * @param options The options parameters.
   */
  getAex9AccountBalances(accountId, options) {
    return this.sendOperationRequest({
      accountId,
      options
    }, getAex9AccountBalancesOperationSpec);
  }

  /**
   * Get DEX swap tokens
   * @param accountId The account id Account address
   * @param options The options parameters.
   */
  getAccountDexSwaps(accountId, options) {
    return this.sendOperationRequest({
      accountId,
      options
    }, getAccountDexSwapsOperationSpec);
  }

  /**
   * Get all name claims of an account
   * @param accountId The account that made the claims Account address
   * @param options The options parameters.
   */
  getAccountNameClaims(accountId, options) {
    return this.sendOperationRequest({
      accountId,
      options
    }, getAccountNameClaimsOperationSpec);
  }

  /**
   * Get account pointees
   * @param accountId The account that names point to Account address
   * @param options The options parameters.
   */
  getAccountPointees(accountId, options) {
    return this.sendOperationRequest({
      accountId,
      options
    }, getAccountPointeesOperationSpec);
  }

  /**
   * Get transactions count and its type for given aeternity ID.
   * @param accountId The ID of the address/name/oracle/etc Account address
   * @param options The options parameters.
   */
  getAccountTransactionsCount(accountId, options) {
    return this.sendOperationRequest({
      accountId,
      options
    }, getAccountTransactionsCountOperationSpec);
  }

  /**
   * Get AEX141 contracts sorted by creation time, name or symbol.
   * @param options The options parameters.
   */
  getSortedAex141Contracts(options) {
    return this.sendOperationRequest({
      options
    }, getSortedAex141ContractsOperationSpec);
  }

  /**
   * Get templates AEX-141 contract tokens.
   * @param contractId The contract id Contract address
   * @param options The options parameters.
   */
  getAex141ContractTemplates(contractId, options) {
    return this.sendOperationRequest({
      contractId,
      options
    }, getAex141ContractTemplatesOperationSpec);
  }

  /**
   * Get AEX-141 template tokens.
   * @param contractId Contract id Contract address
   * @param templateId Template id
   * @param options The options parameters.
   */
  getAex141TemplateTokens(contractId, templateId, options) {
    return this.sendOperationRequest({
      contractId,
      templateId,
      options
    }, getAex141TemplateTokensOperationSpec);
  }

  /**
   * Get owners of tokens of a AEX-141 contract.
   * @param contractId The contract id Contract address
   * @param options The options parameters.
   */
  getAex141ContractTokens(contractId, options) {
    return this.sendOperationRequest({
      contractId,
      options
    }, getAex141ContractTokensOperationSpec);
  }

  /**
   * Get owner of a NFT (AEX-141 token).
   * @param contractId The contract id Contract address
   * @param tokenId The nft token id
   * @param options The options parameters.
   */
  getAex141TokenOwner(contractId, tokenId, options) {
    return this.sendOperationRequest({
      contractId,
      tokenId,
      options
    }, getAex141TokenOwnerOperationSpec);
  }

  /**
   * Get AEX-141 transfers on a contract.
   * @param contractId Contract id Contract address
   * @param options The options parameters.
   */
  getAex141ContractTransfers(contractId, options) {
    return this.sendOperationRequest({
      contractId,
      options
    }, getAex141ContractTransfersOperationSpec);
  }

  /**
   * Get AEX141 contract meta-info, extensions, limits and stats.
   * @param id The contract id Contract address
   * @param options The options parameters.
   */
  getAex141ByContract(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getAex141ByContractOperationSpec);
  }

  /**
   * Get AEX9 tokens sorted by creation time, name or symbol.
   * @param options The options parameters.
   */
  getSortedAex9Tokens(options) {
    return this.sendOperationRequest({
      options
    }, getSortedAex9TokensOperationSpec);
  }

  /**
   * Get AEX9 tokens count.
   * @param options The options parameters.
   */
  getAex9TokensCount(options) {
    return this.sendOperationRequest({
      options
    }, getAex9TokensCountOperationSpec);
  }

  /**
   * Get AEX9 balances on a contract.
   * @param contractId Contract id Contract address
   * @param options The options parameters.
   */
  getAex9ContractBalances(contractId, options) {
    return this.sendOperationRequest({
      contractId,
      options
    }, getAex9ContractBalancesOperationSpec);
  }

  /**
   * Get AEX9 balance for an account on a contract.
   * @param contractId Contract id Contract address
   * @param accountId Account id Account address
   * @param options The options parameters.
   */
  getAex9ContractAccountBalance(contractId, accountId, options) {
    return this.sendOperationRequest({
      contractId,
      accountId,
      options
    }, getAex9ContractAccountBalanceOperationSpec);
  }

  /**
   * Get AEX9 account balance on a contract throughout all heights when changed.
   * @param contractId Contract id Contract address
   * @param accountId Account id Account address
   * @param options The options parameters.
   */
  getAex9ContractAccountBalanceHistory(contractId, accountId, options) {
    return this.sendOperationRequest({
      contractId,
      accountId,
      options
    }, getAex9ContractAccountBalanceHistoryOperationSpec);
  }

  /**
   * Get AEX9 creation and meta_info information by contract id.
   * @param id The contract id Contract address
   * @param options The options parameters.
   */
  getAex9ByContract(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getAex9ByContractOperationSpec);
  }

  /**
   * Get multiple channels.
   * @param options The options parameters.
   */
  getChannels(options) {
    return this.sendOperationRequest({
      options
    }, getChannelsOperationSpec);
  }

  /**
   * Get a single channel.
   * @param id The channel Channel ID
   * @param options The options parameters.
   */
  getChannel(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getChannelOperationSpec);
  }

  /**
   * Get contract calls.
   * @param options The options parameters.
   */
  getContractCalls(options) {
    return this.sendOperationRequest({
      options
    }, getContractCallsOperationSpec);
  }

  /**
   * Get contract logs.
   * @param options The options parameters.
   */
  getContractLogs(options) {
    return this.sendOperationRequest({
      options
    }, getContractLogsOperationSpec);
  }

  /**
   * Gets contract creation info.
   * @param id Contract that emitted the logs Contract address
   * @param options The options parameters.
   */
  getContract(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, middleware_getContractOperationSpec);
  }

  /**
   * Get DEX swap tokens
   * @param options The options parameters.
   */
  getDexSwaps(options) {
    return this.sendOperationRequest({
      options
    }, getDexSwapsOperationSpec);
  }

  /**
   * Get DEX swap tokens
   * @param contractId The contract id Contract address
   * @param options The options parameters.
   */
  getDexSwapsByContractId(contractId, options) {
    return this.sendOperationRequest({
      contractId,
      options
    }, getDexSwapsByContractIdOperationSpec);
  }

  /**
   * Get Epoch information
   * @param options The options parameters.
   */
  getEpochs(options) {
    return this.sendOperationRequest({
      options
    }, getEpochsOperationSpec);
  }

  /**
   * Get Top Epoch information
   * @param options The options parameters.
   */
  getEpochTop(options) {
    return this.sendOperationRequest({
      options
    }, getEpochTopOperationSpec);
  }

  /**
   * Get Schedule information
   * @param options The options parameters.
   */
  getSchedules(options) {
    return this.sendOperationRequest({
      options
    }, getSchedulesOperationSpec);
  }

  /**
   * Get Schedule information
   * @param height Schedule height
   * @param options The options parameters.
   */
  getSchedule(height, options) {
    return this.sendOperationRequest({
      height,
      options
    }, getScheduleOperationSpec);
  }

  /**
   * Get Validators information
   * @param options The options parameters.
   */
  getValidators(options) {
    return this.sendOperationRequest({
      options
    }, getValidatorsOperationSpec);
  }

  /**
   * Get Validator information
   * @param validator Validator address Account address
   * @param options The options parameters.
   */
  getValidator(validator, options) {
    return this.sendOperationRequest({
      validator,
      options
    }, getValidatorOperationSpec);
  }

  /**
   * Get Delegates information for validator
   * @param validator Validator address Account address
   * @param options The options parameters.
   */
  getValidatorDelegates(validator, options) {
    return this.sendOperationRequest({
      validator,
      options
    }, getValidatorDelegatesOperationSpec);
  }

  /**
   * Get top Delegates information for validator
   * @param validator Validator address Account address
   * @param options The options parameters.
   */
  getTopValidatorDelegates(validator, options) {
    return this.sendOperationRequest({
      validator,
      options
    }, getTopValidatorDelegatesOperationSpec);
  }

  /**
   * Get multiple key blocks.
   * @param options The options parameters.
   */
  getKeyBlocks(options) {
    return this.sendOperationRequest({
      options
    }, getKeyBlocksOperationSpec);
  }

  /**
   * Get a single key block.
   * @param hashOrKbi The key block encoded hash or key block index 
   * @param options The options parameters.
   */
  getKeyBlock(hashOrKbi, options) {
    return this.sendOperationRequest({
      hashOrKbi,
      options
    }, getKeyBlockOperationSpec);
  }

  /**
   * Get the key block micro blocks.
   * @param hashOrKbi The key block encoded hash or key block index 
   * @param options The options parameters.
   */
  getKeyBlockMicroBlocks(hashOrKbi, options) {
    return this.sendOperationRequest({
      hashOrKbi,
      options
    }, getKeyBlockMicroBlocksOperationSpec);
  }

  /**
   * Get a micro block
   * @param hash The micro block encoded hash Micro block hash
   * @param options The options parameters.
   */
  getMicroBlock(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getMicroBlockOperationSpec);
  }

  /**
   * Get a micro block transactions
   * @param hash The micro block encoded hash Micro block hash
   * @param options The options parameters.
   */
  getMicroBlockTransactions(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getMicroBlockTransactionsOperationSpec);
  }

  /**
   * Get multiple names.
   * @param options The options parameters.
   */
  getNames(options) {
    return this.sendOperationRequest({
      options
    }, getNamesOperationSpec);
  }

  /**
   * Get multiple names.
   * @param options The options parameters.
   */
  getNamesAuctions(options) {
    return this.sendOperationRequest({
      options
    }, getNamesAuctionsOperationSpec);
  }

  /**
   * Get name auction
   * @param id The name 
   * @param options The options parameters.
   */
  getNameAuction(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getNameAuctionOperationSpec);
  }

  /**
   * Get name auction claims
   * @param id The name 
   * @param options The options parameters.
   */
  getNameAuctionClaims(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getNameAuctionClaimsOperationSpec);
  }

  /**
   * Get the total number of active names.
   * @param options The options parameters.
   */
  getNamesCount(options) {
    return this.sendOperationRequest({
      options
    }, getNamesCountOperationSpec);
  }

  /**
   * Get a single name.
   * @param id The name 
   * @param options The options parameters.
   */
  getName(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getNameOperationSpec);
  }

  /**
   * Get name claims
   * @param id The name or name hash 
   * @param options The options parameters.
   */
  getNameClaims(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getNameClaimsOperationSpec);
  }

  /**
   * Get name transfers
   * @param id The name or name hash 
   * @param options The options parameters.
   */
  getNameTransfers(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getNameTransfersOperationSpec);
  }

  /**
   * Get name updates
   * @param id The name or name hash 
   * @param options The options parameters.
   */
  getNameUpdates(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getNameUpdatesOperationSpec);
  }

  /**
   * Get multiple oracles.
   * @param options The options parameters.
   */
  getOracles(options) {
    return this.sendOperationRequest({
      options
    }, getOraclesOperationSpec);
  }

  /**
   * Get a single oracle.
   * @param id The oracle Oracle address
   * @param options The options parameters.
   */
  getOracle(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getOracleOperationSpec);
  }

  /**
   * Get an oracle's extensions.
   * @param id The oracle Oracle address
   * @param options The options parameters.
   */
  getOracleExtends(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getOracleExtendsOperationSpec);
  }

  /**
   * Get an oracle's queries.
   * @param id The oracle Oracle address
   * @param options The options parameters.
   */
  getOracleQueries(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getOracleQueriesOperationSpec);
  }

  /**
   * Get an oracle's responses.
   * @param id The oracle Oracle address
   * @param options The options parameters.
   */
  getOracleResponses(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getOracleResponsesOperationSpec);
  }

  /**
   * Get stats.
   * @param options The options parameters.
   */
  getStats(options) {
    return this.sendOperationRequest({
      options
    }, getStatsOperationSpec);
  }

  /**
   * Get active accounts stats.
   * @param options The options parameters.
   */
  getActiveAccountsStats(options) {
    return this.sendOperationRequest({
      options
    }, getActiveAccountsStatsOperationSpec);
  }

  /**
   * Get total AEx9 token transfers.
   * @param options The options parameters.
   */
  getAex9TransfersStats(options) {
    return this.sendOperationRequest({
      options
    }, getAex9TransfersStatsOperationSpec);
  }

  /**
   * Get total blocks count stats.
   * @param options The options parameters.
   */
  getBlocksStats(options) {
    return this.sendOperationRequest({
      options
    }, getBlocksStatsOperationSpec);
  }

  /**
   * Get the created contracts count per interval.
   * @param options The options parameters.
   */
  getContractsStats(options) {
    return this.sendOperationRequest({
      options
    }, getContractsStatsOperationSpec);
  }

  /**
   * Get delta stats.
   * @param options The options parameters.
   */
  getDeltaStats(options) {
    return this.sendOperationRequest({
      options
    }, getDeltaStatsOperationSpec);
  }

  /**
   * Get total blocks difficulty stats.
   * @param options The options parameters.
   */
  getDifficultyStats(options) {
    return this.sendOperationRequest({
      options
    }, getDifficultyStatsOperationSpec);
  }

  /**
   * Get total blocks hashrate stats.
   * @param options The options parameters.
   */
  getHashrateStats(options) {
    return this.sendOperationRequest({
      options
    }, getHashrateStatsOperationSpec);
  }

  /**
   * Get miners list with total rewards obtained through mining.
   * @param options The options parameters.
   */
  getMinerStats(options) {
    return this.sendOperationRequest({
      options
    }, getMinerStatsOperationSpec);
  }

  /**
   * Get total names count stats.
   * @param options The options parameters.
   */
  getNamesStats(options) {
    return this.sendOperationRequest({
      options
    }, getNamesStatsOperationSpec);
  }

  /**
   * Get total accumulated stats.
   * @param options The options parameters.
   */
  getTotalStats(options) {
    return this.sendOperationRequest({
      options
    }, getTotalStatsOperationSpec);
  }

  /**
   * Get total accounts created per interval stats.
   * @param options The options parameters.
   */
  getTotalAccountsStats(options) {
    return this.sendOperationRequest({
      options
    }, getTotalAccountsStatsOperationSpec);
  }

  /**
   * Get total transactions count stats.
   * @param options The options parameters.
   */
  getTransactionsStats(options) {
    return this.sendOperationRequest({
      options
    }, getTransactionsStatsOperationSpec);
  }

  /**
   * Gets the current syncing status of both middleware and the node
   * @param options The options parameters.
   */
  getStatus(options) {
    return this.sendOperationRequest({
      options
    }, middleware_getStatusOperationSpec);
  }

  /**
   * Get multiple transactions.
   * @param options The options parameters.
   */
  getTransactions(options) {
    return this.sendOperationRequest({
      options
    }, getTransactionsOperationSpec);
  }

  /**
   * Get count of transactions at the latest height.
   * @param options The options parameters.
   */
  getTransactionsCount(options) {
    return this.sendOperationRequest({
      options
    }, getTransactionsCountOperationSpec);
  }

  /**
   * Get pending transactions.
   * @param options The options parameters.
   */
  getPendingTransactions(options) {
    return this.sendOperationRequest({
      options
    }, getPendingTransactionsOperationSpec);
  }

  /**
   * Get count of pending transactions.
   * @param options The options parameters.
   */
  getPendingTransactionsCount(options) {
    return this.sendOperationRequest({
      options
    }, getPendingTransactionsCountOperationSpec);
  }

  /**
   * Get a single transaction.
   * @param hash The transaction encoded hash Transaction hash
   * @param options The options parameters.
   */
  getTransaction(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getTransactionOperationSpec);
  }

  /**
   * Get multiple transfers.
   * @param options The options parameters.
   */
  getTransfers(options) {
    return this.sendOperationRequest({
      options
    }, getTransfersOperationSpec);
  }
}
// Operation Specifications
const middleware_serializer = createSerializer(middleware_models_mappers_namespaceObject, /* isXml */false);
const getAccountActivitiesOperationSpec = {
  path: "/v3/accounts/{accountId}/activities",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1EfdbjrV3AccountsAccountidActivitiesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [ownedOnly, parameters_typeParam, parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host, accountId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex141OwnedTokensOperationSpec = {
  path: "/v3/accounts/{accountId}/aex141/tokens",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths3Hsv3GV3AccountsAccountidAex141TokensGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction1, contract],
  urlParameters: [models_parameters_$host, accountId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9AccountBalancesOperationSpec = {
  path: "/v3/accounts/{accountId}/aex9/balances",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsKm52GqV3AccountsAccountidAex9BalancesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, accountId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAccountDexSwapsOperationSpec = {
  path: "/v3/accounts/{accountId}/dex/swaps",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsZpy8S9V3AccountsAccountidDexSwapsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [direction2],
  urlParameters: [models_parameters_$host, accountId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAccountNameClaimsOperationSpec = {
  path: "/v3/accounts/{accountId}/names/claims",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths16Cyh9EV3AccountsAccountidNamesClaimsGetResponses200ContentApplicationJsonSchema
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction3],
  urlParameters: [models_parameters_$host, accountId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAccountPointeesOperationSpec = {
  path: "/v3/accounts/{accountId}/names/pointees",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Mheci5V3AccountsAccountidNamesPointeesGetResponses200ContentApplicationJsonSchema
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, accountId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAccountTransactionsCountOperationSpec = {
  path: "/v3/accounts/{accountId}/transactions/count",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsXcg812V3AccountsAccountidTransactionsCountGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, accountId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getSortedAex141ContractsOperationSpec = {
  path: "/v3/aex141",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1XwlyjtV3Aex141GetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction4, by, prefix, exact],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex141ContractTemplatesOperationSpec = {
  path: "/v3/aex141/{contractId}/templates",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths181AjwxV3Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction5],
  urlParameters: [models_parameters_$host, contractId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex141TemplateTokensOperationSpec = {
  path: "/v3/aex141/{contractId}/templates/{templateId}/tokens",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths15Mi2TaV3Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction6],
  urlParameters: [models_parameters_$host, contractId, templateId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex141ContractTokensOperationSpec = {
  path: "/v3/aex141/{contractId}/tokens",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsWl652MV3Aex141ContractidTokensGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction7],
  urlParameters: [models_parameters_$host, contractId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex141TokenOwnerOperationSpec = {
  path: "/v3/aex141/{contractId}/tokens/{tokenId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Aex141TokenDetailResponse
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, contractId, tokenId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex141ContractTransfersOperationSpec = {
  path: "/v3/aex141/{contractId}/transfers",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1O7Q6IhV3Aex141ContractidTransfersGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction8, parameters_fromParam, to],
  urlParameters: [models_parameters_$host, contractId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex141ByContractOperationSpec = {
  path: "/v3/aex141/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Aex141Response
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getSortedAex9TokensOperationSpec = {
  path: "/v3/aex9",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Vr3Y2EV3Aex9GetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, prefix, exact, direction9, by1],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9TokensCountOperationSpec = {
  path: "/v3/aex9/count",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths19IxhsmV3Aex9CountGetResponses200ContentApplicationJsonSchema
    }
  },
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9ContractBalancesOperationSpec = {
  path: "/v3/aex9/{contractId}/balances",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1N61UurV3Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction10, by2, blockHash],
  urlParameters: [models_parameters_$host, contractId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9ContractAccountBalanceOperationSpec = {
  path: "/v3/aex9/{contractId}/balances/{accountId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsKr825V3Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [models_parameters_hash],
  urlParameters: [models_parameters_$host, accountId, contractId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9ContractAccountBalanceHistoryOperationSpec = {
  path: "/v3/aex9/{contractId}/balances/{accountId}/history",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Uybd4PV3Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction11],
  urlParameters: [models_parameters_$host, accountId, contractId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9ByContractOperationSpec = {
  path: "/v3/aex9/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Aex9Response
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getChannelsOperationSpec = {
  path: "/v3/channels",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths3EzhapV3ChannelsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction12, state],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getChannelOperationSpec = {
  path: "/v3/channels/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: mappers_Channel
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id1],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getContractCallsOperationSpec = {
  path: "/v3/contracts/calls",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Txblx8V3ContractsCallsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction13],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getContractLogsOperationSpec = {
  path: "/v3/contracts/logs",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths7A1M6RV3ContractsLogsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, contractId1, parameters_event, functionParam, functionPrefix, data, aexnArgs, direction14],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const middleware_getContractOperationSpec = {
  path: "/v3/contracts/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: models_mappers_Contract
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getDexSwapsOperationSpec = {
  path: "/v3/dex/swaps",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Di8FnjV3DexSwapsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [direction15],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getDexSwapsByContractIdOperationSpec = {
  path: "/v3/dex/{contract_id}/swaps",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsKwxlzlV3DexContractIdSwapsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [direction16],
  urlParameters: [models_parameters_$host, contractId2],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getEpochsOperationSpec = {
  path: "/v3/hyperchain/epochs",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths194Lg3IV3HyperchainEpochsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction17, scope1],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getEpochTopOperationSpec = {
  path: "/v3/hyperchain/epochs/top",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: EpochInfo
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getSchedulesOperationSpec = {
  path: "/v3/hyperchain/schedule",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1S5Zlt1V3HyperchainScheduleGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope1, direction18],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getScheduleOperationSpec = {
  path: "/v3/hyperchain/schedule/height/{height}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Schedule
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, parameters_height],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getValidatorsOperationSpec = {
  path: "/v3/hyperchain/validators",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Ibn686V3HyperchainValidatorsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope1, direction19],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getValidatorOperationSpec = {
  path: "/v3/hyperchain/validators/{validator}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Validator
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, validator],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getValidatorDelegatesOperationSpec = {
  path: "/v3/hyperchain/validators/{validator}/delegates",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1I4U8D5V3HyperchainValidatorsValidatorDelegatesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope1, direction20],
  urlParameters: [models_parameters_$host, validator],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTopValidatorDelegatesOperationSpec = {
  path: "/v3/hyperchain/validators/{validator}/delegates/top",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths15K0AlgV3HyperchainValidatorsValidatorDelegatesTopGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope1, direction21],
  urlParameters: [models_parameters_$host, validator],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getKeyBlocksOperationSpec = {
  path: "/v3/key-blocks",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths277OngV3KeyBlocksGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction22],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getKeyBlockOperationSpec = {
  path: "/v3/key-blocks/{hash_or_kbi}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: KeyBlockExtended
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, hashOrKbi],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getKeyBlockMicroBlocksOperationSpec = {
  path: "/v3/key-blocks/{hash_or_kbi}/micro-blocks",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1159W94V3KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction23],
  urlParameters: [models_parameters_$host, hashOrKbi],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getMicroBlockOperationSpec = {
  path: "/v3/micro-blocks/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: MicroBlockExtended
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, hash1],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getMicroBlockTransactionsOperationSpec = {
  path: "/v3/micro-blocks/{hash}/transactions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths15Bkk50V3MicroBlocksHashTransactionsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, hash1],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNamesOperationSpec = {
  path: "/v3/names",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths12S1Nd4V3NamesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, prefix, by2, ownedBy, state1, direction24],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNamesAuctionsOperationSpec = {
  path: "/v3/names/auctions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsKjq4D4V3NamesAuctionsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction25],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNameAuctionOperationSpec = {
  path: "/v3/names/auctions/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Auction
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction26],
  urlParameters: [models_parameters_$host, id2],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNameAuctionClaimsOperationSpec = {
  path: "/v3/names/auctions/{id}/claims",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsCrb9BgV3NamesAuctionsIdClaimsGetResponses200ContentApplicationJsonSchema
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction27],
  urlParameters: [models_parameters_$host, id2],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNamesCountOperationSpec = {
  path: "/v3/names/count",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Number"
        }
      }
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [ownedBy],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNameOperationSpec = {
  path: "/v3/names/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: mappers_Name
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id2],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNameClaimsOperationSpec = {
  path: "/v3/names/{id}/claims",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1F98AqgV3NamesIdClaimsGetResponses200ContentApplicationJsonSchema
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction28],
  urlParameters: [models_parameters_$host, id2],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNameTransfersOperationSpec = {
  path: "/v3/names/{id}/transfers",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Raw8PV3NamesIdTransfersGetResponses200ContentApplicationJsonSchema
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction29],
  urlParameters: [models_parameters_$host, id2],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNameUpdatesOperationSpec = {
  path: "/v3/names/{id}/updates",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Ec8CltV3NamesIdUpdatesGetResponses200ContentApplicationJsonSchema
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction30],
  urlParameters: [models_parameters_$host, id2],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getOraclesOperationSpec = {
  path: "/v3/oracles",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1E14NekV3OraclesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, state1, direction31],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getOracleOperationSpec = {
  path: "/v3/oracles/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: mappers_Oracle
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id3],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getOracleExtendsOperationSpec = {
  path: "/v3/oracles/{id}/extends",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1L5C64RV3OraclesIdExtendsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id3],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getOracleQueriesOperationSpec = {
  path: "/v3/oracles/{id}/queries",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths8722JhV3OraclesIdQueriesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id3],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getOracleResponsesOperationSpec = {
  path: "/v3/oracles/{id}/responses",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsVron83V3OraclesIdResponsesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id3],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getStatsOperationSpec = {
  path: "/v3/stats",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Stats
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getActiveAccountsStatsOperationSpec = {
  path: "/v3/stats/active-accounts",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsCgzmimV3StatsActiveAccountsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, intervalBy, direction32],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9TransfersStatsOperationSpec = {
  path: "/v3/stats/aex9-transfers",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1UxyhelV3StatsAex9TransfersGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, intervalBy1, minStartDate, maxStartDate, direction33],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getBlocksStatsOperationSpec = {
  path: "/v3/stats/blocks",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Sxjoy0V3StatsBlocksGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, minStartDate, maxStartDate, intervalBy2, typeParam1, direction34],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getContractsStatsOperationSpec = {
  path: "/v3/stats/contracts",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsWbrhqnV3StatsContractsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, minStartDate, maxStartDate, intervalBy3, direction35],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getDeltaStatsOperationSpec = {
  path: "/v3/stats/delta",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths5Xf9ScV3StatsDeltaGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction36],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getDifficultyStatsOperationSpec = {
  path: "/v3/stats/difficulty",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1D7Up0DV3StatsDifficultyGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, minStartDate, maxStartDate, intervalBy4, direction37],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getHashrateStatsOperationSpec = {
  path: "/v3/stats/hashrate",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsR51VshV3StatsHashrateGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, minStartDate, maxStartDate, intervalBy5, direction38],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getMinerStatsOperationSpec = {
  path: "/v3/stats/miners",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsA8Q6T7V3StatsMinersGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction39],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNamesStatsOperationSpec = {
  path: "/v3/stats/names",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsCeyhpaV3StatsNamesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, minStartDate, maxStartDate, intervalBy6, direction40],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTotalStatsOperationSpec = {
  path: "/v3/stats/total",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsJoz7P5V3StatsTotalGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction41],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTotalAccountsStatsOperationSpec = {
  path: "/v3/stats/total-accounts",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths15F3FfuV3StatsTotalAccountsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, intervalBy7, direction42],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTransactionsStatsOperationSpec = {
  path: "/v3/stats/transactions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1IfhshmV3StatsTransactionsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, minStartDate, maxStartDate, intervalBy8, txType, direction43],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const middleware_getStatusOperationSpec = {
  path: "/v3/status",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: mappers_Status
    }
  },
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTransactionsOperationSpec = {
  path: "/v3/transactions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Pymq07V3TransactionsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, contract, typeParam2, typeGroup, account, channel, oracle, senderId, recipientId, entrypoint, scope2, direction44],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTransactionsCountOperationSpec = {
  path: "/v3/transactions/count",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Number"
        }
      }
    }
  },
  queryParameters: [scope, txType, id4],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getPendingTransactionsOperationSpec = {
  path: "/v3/transactions/pending",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsUq0T7JV3TransactionsPendingGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction45],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getPendingTransactionsCountOperationSpec = {
  path: "/v3/transactions/pending/count",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Number"
        }
      }
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTransactionOperationSpec = {
  path: "/v3/transactions/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Transaction
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, hash2],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTransfersOperationSpec = {
  path: "/v3/transfers",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsA7P0KiV3TransfersGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction46],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const operationSpecs = [getAccountActivitiesOperationSpec, getAex141OwnedTokensOperationSpec, getAex9AccountBalancesOperationSpec, getAccountDexSwapsOperationSpec, getAccountNameClaimsOperationSpec, getAccountPointeesOperationSpec, getAccountTransactionsCountOperationSpec, getSortedAex141ContractsOperationSpec, getAex141ContractTemplatesOperationSpec, getAex141TemplateTokensOperationSpec, getAex141ContractTokensOperationSpec, getAex141TokenOwnerOperationSpec, getAex141ContractTransfersOperationSpec, getAex141ByContractOperationSpec, getSortedAex9TokensOperationSpec, getAex9TokensCountOperationSpec, getAex9ContractBalancesOperationSpec, getAex9ContractAccountBalanceOperationSpec, getAex9ByContractOperationSpec, getChannelsOperationSpec, getChannelOperationSpec, getContractCallsOperationSpec, getContractLogsOperationSpec, middleware_getContractOperationSpec, getDexSwapsOperationSpec, getDexSwapsByContractIdOperationSpec, getEpochsOperationSpec, getEpochTopOperationSpec, getSchedulesOperationSpec, getScheduleOperationSpec, getValidatorsOperationSpec, getValidatorOperationSpec, getValidatorDelegatesOperationSpec, getTopValidatorDelegatesOperationSpec, getKeyBlocksOperationSpec, getKeyBlockOperationSpec, getKeyBlockMicroBlocksOperationSpec, getMicroBlockOperationSpec, getMicroBlockTransactionsOperationSpec, getNamesOperationSpec, getNamesAuctionsOperationSpec, getNameAuctionOperationSpec, getNameAuctionClaimsOperationSpec, getNamesCountOperationSpec, getNameOperationSpec, getNameClaimsOperationSpec, getNameTransfersOperationSpec, getNameUpdatesOperationSpec, getOraclesOperationSpec, getOracleOperationSpec, getOracleExtendsOperationSpec, getOracleQueriesOperationSpec, getOracleResponsesOperationSpec, getStatsOperationSpec, getActiveAccountsStatsOperationSpec, getAex9TransfersStatsOperationSpec, getBlocksStatsOperationSpec, getContractsStatsOperationSpec, getDeltaStatsOperationSpec, getDifficultyStatsOperationSpec, getHashrateStatsOperationSpec, getMinerStatsOperationSpec, getNamesStatsOperationSpec, getTotalStatsOperationSpec, getTotalAccountsStatsOperationSpec, getTransactionsStatsOperationSpec, middleware_getStatusOperationSpec, getTransactionsOperationSpec, getTransactionsCountOperationSpec, getPendingTransactionsOperationSpec, getPendingTransactionsCountOperationSpec, getTransactionOperationSpec, getTransfersOperationSpec];
;// ./src/utils/MiddlewarePage.ts
function MiddlewarePage_classPrivateFieldInitSpec(e, t, a) { MiddlewarePage_checkPrivateRedeclaration(e, t), t.set(e, a); }
function MiddlewarePage_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function MiddlewarePage_classPrivateFieldGet(s, a) { return s.get(MiddlewarePage_assertClassBrand(s, a)); }
function MiddlewarePage_classPrivateFieldSet(s, a, r) { return s.set(MiddlewarePage_assertClassBrand(s, a), r), r; }
function MiddlewarePage_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
/* eslint-disable max-classes-per-file */


function isMiddlewareRawPage(maybePage) {
  const testPage = maybePage;
  return testPage?.data != null && Array.isArray(testPage.data) && 'next' in testPage && 'prev' in testPage;
}

/**
 * @category exception
 */
class MiddlewarePageMissed extends BaseError {
  constructor(isNext) {
    super(`There is no ${isNext ? 'next' : 'previous'} page`);
    this.name = 'MiddlewarePageMissed';
  }
}

/**
 * A wrapper around the middleware's page allowing to get the next/previous pages.
 */
var _middleware = /*#__PURE__*/new WeakMap();
class MiddlewarePage {
  constructor(rawPage, middleware) {
    MiddlewarePage_classPrivateFieldInitSpec(this, _middleware, void 0);
    this.data = rawPage.data;
    this.nextPath = rawPage.next;
    this.prevPath = rawPage.prev;
    MiddlewarePage_classPrivateFieldSet(_middleware, this, middleware);
  }

  /**
   * Get the next page.
   * Check the presence of `nextPath` to not fall outside existing pages.
   * @throws MiddlewarePageMissed
   */
  async next() {
    if (this.nextPath == null) throw new MiddlewarePageMissed(true);
    return MiddlewarePage_classPrivateFieldGet(_middleware, this).requestByPath(this.nextPath);
  }

  /**
   * Get the previous page.
   * Check the presence of `prevPath` to not fall outside existing pages.
   * @throws MiddlewarePageMissed
   */
  async prev() {
    if (this.prevPath == null) throw new MiddlewarePageMissed(false);
    return MiddlewarePage_classPrivateFieldGet(_middleware, this).requestByPath(this.prevPath);
  }
}
;// ./src/Middleware.ts







/**
 * @category middleware
 */
class Middleware extends middleware_Middleware {
  /**
   * @param url - Url for middleware API
   * @param options - Options
   * @param options.ignoreVersion - Print warning instead of throwing exception if middleware
   * is not supported, use with caution
   * @param options.retryCount - Amount of extra requests to do in case of failure
   * @param options.retryOverallDelay - Time in ms to wait between all retries
   */
  constructor(url, {
    ignoreVersion = false,
    retryCount = 3,
    retryOverallDelay = 800,
    ...options
  } = {}) {
    let version;
    const getVersion = async opts => {
      if (version != null) return version;
      version = (await this.getStatus(opts)).mdwVersion;
      return version;
    };

    // eslint-disable-next-line constructor-super
    super(url, {
      allowInsecureConnection: true,
      additionalPolicies: [genVersionCheckPolicy('middleware', getVersion, '1.81.0', '2.0.0', ignoreVersion), genRequestQueuesPolicy(), genCombineGetRequestsPolicy(), genRetryOnFailurePolicy(retryCount, retryOverallDelay), genErrorFormatterPolicy(body => ` ${body.error}`)],
      ...options
    });
    this.pipeline.addPolicy(parseBigIntPolicy, {
      phase: 'Deserialize'
    });
    this.pipeline.removePolicy({
      name: core_rest_pipeline_.userAgentPolicyName
    });
    this.pipeline.removePolicy({
      name: core_rest_pipeline_.setClientRequestIdPolicyName
    });
    // TODO: use instead our retry policy
    this.pipeline.removePolicy({
      name: 'defaultRetryPolicy'
    });
  }

  /**
   * Get a middleware response by path instead of a method name and arguments.
   * @param pathWithQuery - a path to request starting with `/v3/`
   */
  async requestByPath(pathWithQuery) {
    const queryPos = pathWithQuery.indexOf('?');
    const path = pathWithQuery.slice(0, queryPos === -1 ? pathWithQuery.length : queryPos);
    const query = pathWithQuery.slice(queryPos === -1 ? pathWithQuery.length : queryPos + 1);
    const operationSpec = operationSpecs.find(os => {
      let p = path;
      if (os.path == null) return false;
      const groups = os.path.replace(/{\w+}/g, '{param}').split('{param}');
      while (groups.length > 0) {
        const part = groups.shift();
        if (part == null) throw new InternalError(`Unexpected operation spec path: ${os.path}`);
        if (!p.startsWith(part)) return false;
        p = p.replace(part, '');
        if (groups.length > 0) p = p.replace(/^[\w.]+/, '');
      }
      return p === '';
    });
    if (operationSpec == null) {
      throw new IllegalArgumentError(`Can't find operation spec corresponding to ${path}`);
    }
    return this.sendOperationRequest({}, {
      ...operationSpec,
      path,
      urlParameters: operationSpec.urlParameters?.filter(({
        parameterPath
      }) => parameterPath === '$host'),
      queryParameters: Array.from(new URLSearchParams(query)).map(([key, value]) => ({
        parameterPath: ['options', key],
        mapper: {
          defaultValue: value.toString(),
          serializedName: key,
          type: {
            name: 'String'
          }
        }
      }))
    });
  }
  async sendOperationRequest(operationArguments, operationSpec) {
    const response = await super.sendOperationRequest(operationArguments, operationSpec);
    if (!isMiddlewareRawPage(response)) return response;
    return new MiddlewarePage(response, this);
  }
}
;// ./src/aepp-wallet-communication/connection-proxy.ts
/**
 * Browser connection proxy
 * Provide functionality to easily forward messages from one connection to another and back
 * @category aepp wallet communication
 * @param con1 - first connection
 * @param con2 - second connection
 * @returns a function to stop proxying
 */
/* harmony default export */ const connection_proxy = ((con1, con2) => {
  con1.connect(msg => con2.sendMessage(msg), () => con2.disconnect());
  con2.connect(msg => con1.sendMessage(msg), () => con1.disconnect());
  return () => {
    con1.disconnect();
    con2.disconnect();
  };
});
;// ./src/aepp-wallet-communication/connection/Browser.ts


/**
 * Browser connection base interface
 * @category aepp wallet communication
 */
class BrowserConnection {
  constructor({
    debug = false
  }) {
    this.debug = debug;
  }

  /**
   * Connect
   * @param onMessage - Message handler
   * @param onDisconnect - trigger when runtime connection in closed
   */
  connect(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMessage,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDisconnect) {
    if (this.isConnected()) throw new AlreadyConnectedError('You already connected');
  }

  /**
   * Disconnect
   */
  disconnect() {
    if (!this.isConnected()) throw new NoWalletConnectedError('You dont have connection. Please connect before');
  }

  /**
   * Receive message
   */
  receiveMessage(message) {
    if (this.debug) console.log('Receive message:', message);
  }

  /**
   * Send message
   */
  sendMessage(message) {
    if (this.debug) console.log('Send message:', message);
  }

  /**
   * Check if connected
   * @returns Is connected
   */
}
;// ./src/aepp-wallet-communication/connection/BrowserWindowMessage.ts
function BrowserWindowMessage_classPrivateFieldInitSpec(e, t, a) { BrowserWindowMessage_checkPrivateRedeclaration(e, t), t.set(e, a); }
function BrowserWindowMessage_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function BrowserWindowMessage_classPrivateFieldGet(s, a) { return s.get(BrowserWindowMessage_assertClassBrand(s, a)); }
function BrowserWindowMessage_classPrivateFieldSet(s, a, r) { return s.set(BrowserWindowMessage_assertClassBrand(s, a), r), r; }
function BrowserWindowMessage_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }



var _onDisconnect = /*#__PURE__*/new WeakMap();
var _target = /*#__PURE__*/new WeakMap();
var _self = /*#__PURE__*/new WeakMap();
/**
 * Browser window Post Message connector module
 * @category aepp wallet communication
 */
class BrowserWindowMessageConnection extends BrowserConnection {
  /**
   * @param options - Options
   * @param options.target Target window for message
   * @param options.self Host window for message
   * @param options.origin Origin of receiver
   * @param options.sendDirection Wrapping messages into additional struct
   * `({ type: 'to_aepp' || 'to_waellet', data })`
   * Used for handling messages between content script and page
   * @param options.receiveDirection Unwrapping messages from additional struct
   */
  constructor({
    target,
    self = window,
    origin,
    sendDirection,
    receiveDirection = MESSAGE_DIRECTION.to_aepp,
    ...options
  } = {}) {
    super(options);
    BrowserWindowMessage_classPrivateFieldInitSpec(this, _onDisconnect, void 0);
    BrowserWindowMessage_classPrivateFieldInitSpec(this, _target, void 0);
    BrowserWindowMessage_classPrivateFieldInitSpec(this, _self, void 0);
    BrowserWindowMessage_classPrivateFieldSet(_target, this, target);
    BrowserWindowMessage_classPrivateFieldSet(_self, this, self);
    this.origin = origin;
    this.sendDirection = sendDirection;
    this.receiveDirection = receiveDirection;
  }
  isConnected() {
    return this.listener != null;
  }
  connect(onMessage, onDisconnect) {
    super.connect(onMessage, onDisconnect);
    this.listener = message => {
      var _message$data$jsonrpc;
      // TODO: strict validate origin and source instead of checking message structure
      if (typeof message.data !== 'object' || ((_message$data$jsonrpc = message.data.jsonrpc) !== null && _message$data$jsonrpc !== void 0 ? _message$data$jsonrpc : message.data.data?.jsonrpc) !== '2.0') return;
      if (this.origin != null && this.origin !== message.origin) return;
      if (BrowserWindowMessage_classPrivateFieldGet(_target, this) != null && BrowserWindowMessage_classPrivateFieldGet(_target, this) !== message.source) return;
      this.receiveMessage(message);
      let {
        data
      } = message;
      if (data.type != null) {
        if (message.data.type !== this.receiveDirection) return;
        data = data.data;
      }
      onMessage(data, message.origin, message.source);
    };
    BrowserWindowMessage_classPrivateFieldGet(_self, this).addEventListener('message', this.listener);
    BrowserWindowMessage_classPrivateFieldSet(_onDisconnect, this, onDisconnect);
  }
  disconnect() {
    super.disconnect();
    if (this.listener == null || BrowserWindowMessage_classPrivateFieldGet(_onDisconnect, this) == null) {
      throw new InternalError('Expected to not happen, required for TS');
    }
    BrowserWindowMessage_classPrivateFieldGet(_self, this).removeEventListener('message', this.listener);
    delete this.listener;
    BrowserWindowMessage_classPrivateFieldGet(_onDisconnect, this).call(this);
    BrowserWindowMessage_classPrivateFieldSet(_onDisconnect, this, undefined);
  }
  sendMessage(msg) {
    var _this$origin;
    if (BrowserWindowMessage_classPrivateFieldGet(_target, this) == null) throw new RpcConnectionError("Can't send messages without target");
    const message = this.sendDirection != null ? {
      type: this.sendDirection,
      data: msg
    } : msg;
    super.sendMessage(message);
    BrowserWindowMessage_classPrivateFieldGet(_target, this).postMessage(message, (_this$origin = this.origin) !== null && _this$origin !== void 0 ? _this$origin : '*');
  }
}
;// ./src/aepp-wallet-communication/wallet-detector.ts



/**
 * A function to detect available wallets
 * @category aepp wallet communication
 * @param connection - connection to use to detect wallets
 * @param onDetected - call-back function which trigger on new wallet
 * @returns a function to stop scanning
 */
/* harmony default export */ const wallet_detector = ((connection, onDetected) => {
  if (window == null) throw new UnsupportedPlatformError('Window object not found, you can run wallet detector only in browser');
  const wallets = {};
  connection.connect(({
    method,
    params
  }, origin, source) => {
    if (method !== METHODS.readyToConnect || wallets[params.id] != null) return;
    const wallet = {
      info: params,
      getConnection() {
        return new BrowserWindowMessageConnection({
          target: source,
          ...(params.type === 'extension' ? {
            sendDirection: MESSAGE_DIRECTION.to_waellet,
            receiveDirection: MESSAGE_DIRECTION.to_aepp,
            ...(window.origin !== 'null' && {
              origin: window.origin
            })
          } : {
            origin: params.origin
          })
        });
      }
    };
    wallets[wallet.info.id] = wallet;
    onDetected({
      wallets,
      newWallet: wallet
    });
  }, () => {});
  return () => connection.disconnect();
});
;// ./src/aepp-wallet-communication/connection/BrowserRuntime.ts
function BrowserRuntime_classPrivateFieldInitSpec(e, t, a) { BrowserRuntime_checkPrivateRedeclaration(e, t), t.set(e, a); }
function BrowserRuntime_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function BrowserRuntime_classPrivateFieldSet(s, a, r) { return s.set(BrowserRuntime_assertClassBrand(s, a), r), r; }
function BrowserRuntime_classPrivateFieldGet(s, a) { return s.get(BrowserRuntime_assertClassBrand(s, a)); }
function BrowserRuntime_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }



/**
 * BrowserRuntimeConnection
 * Handle browser runtime communication
 * @category aepp wallet communication
 */
var _listeners = /*#__PURE__*/new WeakMap();
class BrowserRuntimeConnection extends BrowserConnection {
  /**
   * @param options - Options
   */
  constructor({
    port,
    ...options
  }) {
    super(options);
    BrowserRuntime_classPrivateFieldInitSpec(this, _listeners, void 0);
    this.port = port;
  }
  disconnect() {
    super.disconnect();
    this.port.disconnect();
    if (BrowserRuntime_classPrivateFieldGet(_listeners, this) == null) throw new UnexpectedTsError();
    this.port.onMessage.removeListener(BrowserRuntime_classPrivateFieldGet(_listeners, this)[0]);
    this.port.onDisconnect.removeListener(BrowserRuntime_classPrivateFieldGet(_listeners, this)[1]);
    BrowserRuntime_classPrivateFieldSet(_listeners, this, undefined);
  }
  connect(onMessage, onDisconnect) {
    super.connect(onMessage, onDisconnect);
    BrowserRuntime_classPrivateFieldSet(_listeners, this, [(message, port) => {
      var _port$sender$url;
      this.receiveMessage(message);
      // TODO: make `origin` optional because sender url is not available on aepp side
      onMessage(message, (_port$sender$url = port.sender?.url) !== null && _port$sender$url !== void 0 ? _port$sender$url : '', port);
    }, onDisconnect]);
    this.port.onMessage.addListener(BrowserRuntime_classPrivateFieldGet(_listeners, this)[0]);
    this.port.onDisconnect.addListener(BrowserRuntime_classPrivateFieldGet(_listeners, this)[1]);
  }
  sendMessage(message) {
    super.sendMessage(message);
    this.port.postMessage(message);
  }
  isConnected() {
    return BrowserRuntime_classPrivateFieldGet(_listeners, this) != null;
  }
}
;// ./src/index-browser.ts



/**
 * @category utils
 * @deprecated use {@link verifySignature} instead
 */

/**
 * @deprecated use {@link hashMessage} instead
 * @category utils
 */

/**
 * @deprecated use {@link verifyMessageSignature} instead
 * @category utils
 */





/**
 * @category contract
 * @deprecated use {@link buildContractId} instead
 */

/**
 * @category AENS
 * @deprecated use {@link isName} instead
 */


// TODO: move to constants



























/**
 * @deprecated Use {@link AccountMemory} instead
 * @category account
 */



















;// external "child_process"
const external_child_process_namespaceObject = require("child_process");
;// external "os"
const external_os_namespaceObject = require("os");
;// external "path"
const external_path_namespaceObject = require("path");
;// external "fs/promises"
const promises_namespaceObject = require("fs/promises");
// EXTERNAL MODULE: external "url"
var external_url_ = __webpack_require__(7016);
;// ./src/contract/compiler/Cli.ts
function Cli_classPrivateMethodInitSpec(e, a) { Cli_checkPrivateRedeclaration(e, a), a.add(e); }
function Cli_classPrivateFieldInitSpec(e, t, a) { Cli_checkPrivateRedeclaration(e, t), t.set(e, a); }
function Cli_checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function Cli_classPrivateFieldGet(s, a) { return s.get(Cli_assertClassBrand(s, a)); }
function Cli_classPrivateFieldSet(s, a, r) { return s.set(Cli_assertClassBrand(s, a), r), r; }
function Cli_assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }









const getPackagePath = () => {
  const path = (0,external_path_namespaceObject.dirname)((0,external_url_.fileURLToPath)((__webpack_require__(7016).pathToFileURL)(__filename).toString()));
  if ((0,external_path_namespaceObject.basename)(path) === 'dist') return (0,external_path_namespaceObject.resolve)(path, '..');
  if ((0,external_path_namespaceObject.basename)(path) === 'compiler') return (0,external_path_namespaceObject.resolve)(path, '../../..');
  throw new InternalError("Can't get package path");
};

/**
 * A wrapper around aesophia_cli, available only in Node.js.
 * Requires Erlang installed, assumes that `escript` is available in PATH.
 * @category contract
 */
var _path = /*#__PURE__*/new WeakMap();
var _ensureCompatibleVersion = /*#__PURE__*/new WeakMap();
var _CompilerCli_brand = /*#__PURE__*/new WeakSet();
class CompilerCli extends CompilerBase {
  /**
   * @param compilerPath - A path to aesophia_cli binary, by default uses the integrated one
   * @param options - Options
   * @param options.ignoreVersion - Print warning instead of throwing exception if compiler version
   * is not supported, use with caution
   */
  constructor(compilerPath = (0,external_path_namespaceObject.resolve)(getPackagePath(), './bin/aesophia_cli'), {
    ignoreVersion = false
  } = {}) {
    super();
    Cli_classPrivateMethodInitSpec(this, _CompilerCli_brand);
    Cli_classPrivateFieldInitSpec(this, _path, void 0);
    Cli_classPrivateFieldInitSpec(this, _ensureCompatibleVersion, void 0);
    Cli_classPrivateFieldSet(_path, this, compilerPath);
    Cli_classPrivateFieldSet(_ensureCompatibleVersion, this, this.version().then(version => {
      const versions = [version, '8.0.0', '9.0.0'];
      if (!semverSatisfies(...versions)) {
        const error = new UnsupportedVersionError('compiler', ...versions);
        if (ignoreVersion) console.warn(error.message);else throw error;
      }
    }));
  }
  async compile(path) {
    await Cli_classPrivateFieldGet(_ensureCompatibleVersion, this);
    try {
      const [compileRes, aci] = await Promise.all([Cli_assertClassBrand(_CompilerCli_brand, this, _runWithStderr).call(this, path), this.generateAci(path)]);
      return {
        bytecode: compileRes.stdout.trimEnd(),
        aci,
        warnings: compileRes.stderr.split('Warning in ').slice(1).map(warning => {
          const reg = /^'(.+)' at line (\d+), col (\d+):\n(.+)$/s;
          const match = warning.match(reg);
          if (match == null) throw new InternalError(`Can't parse compiler output: "${warning}"`);
          return {
            message: match[4].trimEnd(),
            pos: {
              ...(match[1] !== path && {
                file: match[1]
              }),
              line: +match[2],
              col: +match[3]
            }
          };
        })
      };
    } catch (error) {
      ensureError(error);
      throw new CompilerError(error.message);
    }
  }
  async compileBySourceCode(sourceCode, fileSystem) {
    const tmp = await _saveContractToTmpDir.call(CompilerCli, sourceCode, fileSystem);
    try {
      return await this.compile(tmp);
    } finally {
      await (0,promises_namespaceObject.rm)((0,external_path_namespaceObject.dirname)(tmp), {
        recursive: true
      });
    }
  }
  async generateAci(path) {
    await Cli_classPrivateFieldGet(_ensureCompatibleVersion, this);
    try {
      return JSON.parse(await Cli_assertClassBrand(_CompilerCli_brand, this, _run).call(this, '--no_code', '--create_json_aci', path));
    } catch (error) {
      ensureError(error);
      throw new CompilerError(error.message);
    }
  }
  async generateAciBySourceCode(sourceCode, fileSystem) {
    const tmp = await _saveContractToTmpDir.call(CompilerCli, sourceCode, fileSystem);
    try {
      return await this.generateAci(tmp);
    } finally {
      await (0,promises_namespaceObject.rm)((0,external_path_namespaceObject.dirname)(tmp), {
        recursive: true
      });
    }
  }
  async validate(bytecode, path) {
    await Cli_classPrivateFieldGet(_ensureCompatibleVersion, this);
    try {
      return (await Cli_assertClassBrand(_CompilerCli_brand, this, _run).call(this, path, '--validate', bytecode)).includes('Validation successful.');
    } catch (error) {
      return false;
    }
  }
  async validateBySourceCode(bytecode, sourceCode, fileSystem) {
    const tmp = await _saveContractToTmpDir.call(CompilerCli, sourceCode, fileSystem);
    try {
      return await this.validate(bytecode, tmp);
    } finally {
      await (0,promises_namespaceObject.rm)((0,external_path_namespaceObject.dirname)(tmp), {
        recursive: true
      });
    }
  }
  async version() {
    const verMessage = await Cli_assertClassBrand(_CompilerCli_brand, this, _run).call(this, '--version');
    const ver = verMessage.match(/Sophia compiler version ([\d.]+.*)\n/)?.[1];
    if (ver == null) throw new CompilerError("Can't get compiler version");
    return ver;
  }
}
async function _runWithStderr(...parameters) {
  return new Promise((pResolve, pReject) => {
    (0,external_child_process_namespaceObject.execFile)('escript', [Cli_classPrivateFieldGet(_path, this), ...parameters], (error, stdout, stderr) => {
      if (error != null) pReject(error);else pResolve({
        stdout,
        stderr
      });
    });
  });
}
async function _run(...parameters) {
  const {
    stderr,
    stdout
  } = await Cli_assertClassBrand(_CompilerCli_brand, this, _runWithStderr).call(this, ...parameters);
  if (stderr !== '') throw new CompilerError(stderr);
  return stdout;
}
async function _saveContractToTmpDir(sourceCode, fileSystem = {}) {
  const randomName = () => Math.random().toString(36).slice(2);
  const path = (0,external_path_namespaceObject.resolve)((0,external_os_namespaceObject.tmpdir)(), `aepp-sdk-js-${randomName()}`);
  await (0,promises_namespaceObject.mkdir)(path);
  const sourceCodePath = (0,external_path_namespaceObject.resolve)(path, `${randomName()}.aes`);
  await (0,promises_namespaceObject.writeFile)(sourceCodePath, sourceCode);
  await Promise.all(Object.entries(fileSystem).map(async ([name, src]) => {
    const p = (0,external_path_namespaceObject.resolve)(path, name);
    await (0,promises_namespaceObject.mkdir)((0,external_path_namespaceObject.dirname)(p), {
      recursive: true
    });
    return (0,promises_namespaceObject.writeFile)(p, src);
  }));
  return sourceCodePath;
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/flags.js
var flags = __webpack_require__(2730);
var flags_default = /*#__PURE__*/__webpack_require__.n(flags);
;// ./src/contract/compiler/getFileSystem.ts




const defaultIncludes = ['List.aes', 'Option.aes', 'String.aes', 'Func.aes', 'Pair.aes', 'Triple.aes', 'BLS12_381.aes', 'Frac.aes', 'Set.aes', 'Bitwise.aes'];
const includeRegExp = /^include\s*"([\w/.-]+)"/im;
const includesRegExp = new RegExp(includeRegExp.source, `${flags_default()(includeRegExp)}g`);
async function getFileSystemRec(root, relative) {
  var _sourceCode$match;
  const sourceCode = await (0,promises_namespaceObject.readFile)((0,external_path_namespaceObject.resolve)(root, relative), 'utf8');
  const filesystem = {};
  await Promise.all(((_sourceCode$match = sourceCode.match(includesRegExp)) !== null && _sourceCode$match !== void 0 ? _sourceCode$match : []).map(include => {
    const m = include.match(includeRegExp);
    if (m?.length !== 2) throw new InternalError('Unexpected match length');
    return m[1];
  }).filter(include => !defaultIncludes.includes(include)).map(async include => {
    const includePath = (0,external_path_namespaceObject.resolve)(root, include);
    filesystem[include] = await (0,promises_namespaceObject.readFile)(includePath, 'utf8');
    Object.assign(filesystem, await getFileSystemRec(root, include));
  }));
  return filesystem;
}

/**
 * Reads all files included in the provided contract
 * Available only in Node.js
 * @param path - a path to the main contract source code
 * @category contract
 */
async function getFileSystem(path) {
  return getFileSystemRec((0,external_path_namespaceObject.dirname)(path), (0,external_path_namespaceObject.basename)(path));
}
;// ./src/contract/compiler/HttpNode.ts




/**
 * Contract Compiler over HTTP for Nodejs
 *
 * Inherits CompilerHttp and implements `compile`, `validate` methods
 * @category contract
 * @example CompilerHttpNode('COMPILER_URL')
 */
class CompilerHttpNode extends CompilerHttp {
  async compile(path) {
    const fileSystem = await getFileSystem(path);
    const sourceCode = await (0,promises_namespaceObject.readFile)(path, 'utf8');
    return this.compileBySourceCode(sourceCode, fileSystem);
  }
  async generateAci(path) {
    const fileSystem = await getFileSystem(path);
    const sourceCode = await (0,promises_namespaceObject.readFile)(path, 'utf8');
    return this.generateAciBySourceCode(sourceCode, fileSystem);
  }
  async validate(bytecode, path) {
    const fileSystem = await getFileSystem(path);
    const sourceCode = await (0,promises_namespaceObject.readFile)(path, 'utf8');
    return this.validateBySourceCode(bytecode, sourceCode, fileSystem);
  }
}
;// ./src/index.ts




})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=aepp-sdk.cjs.map